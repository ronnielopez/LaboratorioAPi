<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ITHit.WebDAV.Server</name>
    </assembly>
    <members>
        <member name="T:ITHit.WebDAV.Server.Acl.AceType">
            <summary>
            Type of <see cref="T:ITHit.WebDAV.Server.Acl.ReadAce"/> or <see cref="T:ITHit.WebDAV.Server.Acl.WriteAce"/> record.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Grant">
            <summary>
            Grants permissions.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Deny">
            <summary>
            Denies permissions.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.AclRestriction">
            <summary>
            Defines the types of ACLs supported by the server, to avoid clients needlessly getting
            errors.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.GrantOnly">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges"/> are not allowed.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.NoInvert">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges"/> == false are not supported.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.RequiredPrincipals">
            <summary>
            Indicates which principals are required to be present in ACL.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IAccessControl">
            <summary>
            Represents an item that supports WebDAV ACL. Enables <b>access-control</b> feature support discovery.
            </summary>
            <remarks>
            <param>This is a marker interface, it does not provide any propertes or methods.</param>
            <param>
            Items that implement this interface report ACL support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>access-control</b> token.
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync">
            <summary>
            Interface to be implemented by hierarchy items that support setting permissions (ACL). 
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetOwnerAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl" /> privilege), clients might display the resource owner in their
            user interface.
            </summary>
            <param name="value">Identifies whether to search by owner or group.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.SetOwnerAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetOwnerAsync">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl" /> privilege), clients might display the resource owner in their user
            interface.
            </summary>
            <returns>
            Item that represents owner of this item and implements <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync" />.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>Can be null.</remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetOwnerAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetGroupAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <param name="value">Identifies whether to search by owner or group.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.SetGroupAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetGroupAsync">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <returns>
            Group principal that implements <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync" />.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            Can return null if group is not assigned.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetGroupAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync">
            <summary>
            Retrieves the privileges defined for the resource.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.Acl.SupportedPrivilege" />.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync">
            <summary>
            Retrieves the exact set of privileges (as computed by
            the server) granted to the currently authenticated HTTP user. Aggregate privileges and their contained
            privileges are listed. A user-agent can use the value of this property to adjust its user interface to
            make actions inaccessible (e.g., by graying out a menu item or button) for which the current principal
            does not have permission. This property is also useful for determining what operations the current
            principal can perform, without having to actually execute an operation.
            </summary>
            <returns>
            List of current user privileges.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Specifies the list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <param name="propertyNames">List of properties that might be retrieved from those <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync" />
            returned.</param>
            <returns>
            A set of privileges.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            <paramref name="propertyNames" />Is for optimization purposes and you may ignore it.
            For "principal-pop-set" report engine will call this method, retrieve all principals from result
            and extract properties specified in <paramref name="propertyNames" /> from it. In this case prefetching
            these properties may improve performance.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetAclAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})">
            <summary>
            Sets list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <param name="aces">Identifies whether to search by owner or group.</param>
            <remarks>
            Two common operations are to add or remove an ACE from an existing access
            control list. To accomplish this, a client uses the PROPFIND method to retrieve the value of the DAV:acl
            property, then parses the returned access control list to remove all inherited and protected ACEs (these
            ACEs are tagged with the DAV:inherited and DAV:protected XML elements). In the remaining set of
            non-inherited, non-protected ACEs, the client can add or remove one or more ACEs before submitting the
            final ACE set in the request body of the ACL method.
            It is possible that the ACEs visible to the current user in the DAV:acl property may only be a portion of
            the complete set of ACEs on that resource. If this is the case, an ACL request only modifies the set of
            ACEs visible to the current user, and does not affect any non-visible ACE.
            </remarks>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            It is possible for status code to be <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT" /> and error description one of values
            in <see cref="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails" /> class.
            </exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.SetAclAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclRestrictionsAsync">
            <summary>
            Defines the types of ACLs supported by this server, to avoid clients needlessly getting
            errors. When a client tries to set an ACL via the ACL method, the server may reject the attempt to set
            the ACL as specified.
            </summary>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Acl.AclRestriction" />.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetAclRestrictionsAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetInheritedAclSetAsync">
            <summary>
            Contains a set of items that also control the access to this item.
            To have a privilege on an item, not only must the ACL on that item (specified in the <see cref="N:ITHit.WebDAV.Server.Acl" />
            property of that item) grant the privilege, but so must the ACL of each items identified in the
            <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetInheritedAclSetAsync" /> property of that item. Effectively, the privileges granted by the current
            ACL are ANDed with the privileges granted by each inherited ACL.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync" /> items.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetInheritedAclSetAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync">
            <summary>
            Retrieves a set of root collections that contain the
            principals that are available on the server that implements this resource. It can be used to retrieve the 
            <see cref="!:IHierarchyItemAsync.Name" /> properties
            of all principals on that server, thereby yielding human-readable
            names for each principal that could be displayed in a user interface.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync" /> items.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Returns predefined principal.
            </summary>
            <param name="wellKnownPrincipal">One of <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal" /> values.</param>
            <returns>Well known principal or <c>null</c> if it is not supported.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetItemsByPropertyAsync(ITHit.WebDAV.Server.Acl.MatchBy,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Find all resources in the subtree which have either Group or Owner (defined by <paramref name="matchBy" />
            parameter) which identifies current user or group current user belongs to.
            For example, this report can return all of the resources in a collection
            hierarchy that are owned by the current user.
            </summary>
            <param name="matchBy">Identifies whether to search by owner or group.</param>
            <param name="props">Properties requested for found items.</param>
            <returns>List of matching resources, each implementing <see cref="T:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync" />.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItemAsync.GetItemsByPropertyAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipalAsync">
            <summary>
            Assists in finding currently loged-in user. Provides <b>current-user-principal</b> feature support.
            Required by iOS and OS X CalDAV and CardDAV clients on folders pointed to by '.well-known' requests (context path folder).
            </summary>
            <remarks>
            <param>
            This interface provides <see cref="M:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipalAsync.GetCurrentUserPrincipalAsync"/>) method that is called by the Engine 
            when client is discovering currently logged-in user.
            </param>
            <param>
            This interface is optional on hierarchy items. However, to support iOS and OS X CalDAV and CardDAV 
            clients this interface must be implemented on item redirected to by /.well-known/caldav and 
            /.well-known/carddav responses. iOS and OS X CalDAV and CardDAV clients request 
            <b>current-user-principal</b> and <b>principal-URL</b> properties on these items and would not connect to server if 
            no proper responce is provided.
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipalAsync.GetCurrentUserPrincipalAsync">
            <summary>
            Retrieves currently logged in principal.
            </summary>
            <remarks>The Engine will request <see cref="!:IHierarchyItemAsync.Path" /> on the returned item.</remarks>
            <returns>Currently logged in principal.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ICurrentUserPrincipalAsync.GetCurrentUserPrincipalAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync">
            <summary>
            Represents a principal - a distinct human or computational actor that initiates access to
            items in WebDAV repository.
            </summary>
            <remarks>
            <param>
            Users and groups are represented as principals in many implementations;
            other types of principals are also possible. 
            A principal item may be a group, where a group is a principal that represents a set of other principals,
            called the members of the group. If a person or computational agent matches a principal resource that is a
            member of a group, they also match the group. Membership in a group is recursive, so if a principal is a
            member of group GRPA, and GRPA is a member of group GRPB, then the principal is also a member of
            GRPB.
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.SetGroupMembersAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.IPrincipalAsync})">
            <summary>
            Replaces members of the group to be those specified in <paramref name="members" /> parameter.
            </summary>
            <param name="members">New member(user or groups) list.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalAsync.SetGroupMembersAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembersAsync">
            <summary>
            Retrieves principals that are direct members of this group. 
            </summary>
            <remarks>
            Since a group
            may be a member of another group, a group may also have indirect members (i.e., the members of its direct
            members). 
            </remarks>
            <returns>Members of the group identified by this principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalAsync.GetGroupMembersAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.IsWellKnownPrincipal(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Determines whether the principal is well known, the one that is defined by
            <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal" /> enumeration.
            </summary>
            <param name="wellknownPrincipal">Type of wellknown principal to check this one against.</param>
            <returns>Whether the principal is <paramref name="wellknownPrincipal" />.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalAsync.IsWellKnownPrincipal&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembershipAsync">
            <summary>
            Identifies the groups in which the principal is directly a member. 
            </summary>
            <remarks>
            Note that a server may
            allow a group to be a member of another group, in which case the <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembershipAsync" />
            of those other groups would need to be queried in order to determine the groups in which the principal
            is indirectly a member.
            </remarks>
            <returns>Returns group this principal belongs to.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalAsync.GetGroupMembershipAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync">
            <summary>
            Represents a folder that contains principals.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.CreateFolderAsync(System.String)">
            <summary>
            Creates principal folder with given name.
            </summary>
            <param name="name">Principal folder name.</param>
            <returns>Newly created folder.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolderAsync.CreateFolderAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.CreatePrincipalAsync(System.String)">
            <summary>
            Creates principal with given name.
            </summary>
            <param name="name">Principal name</param>
            <returns>Newly created principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            The principal created can be either group or user. One of the way to distinguish is
            to create separate folders for users and for groups, so in one folder only users
            can be created, and in another one only groups.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolderAsync.CreatePrincipalAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.FindPrincipalsByPropertyValuesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Performs a search for all principals in this folder whose properties contain
            character data that matches the search criteria specified.
            One expected use of this method is to
            discover principals by searching for them by name. This is
            done by searching over <see cref="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME" /> (<see cref="!:IHierarchyItemAsync.Name" />),
            which is defined on all principals.
            </summary>
            <param name="propValuesToSearch">Properties with values to search for.</param>
            <param name="propsToReturn">Properties to return for each item found.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            If there are too many items server may return this exception with status
            <see cref="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED" /> and description 
            <see cref="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS" />
            </exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolderAsync.FindPrincipalsByPropertyValuesAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.GetPrincipalSearcheablePropertiesAsync">
            <summary>
            Identifies those properties that may be searched using the
            <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.FindPrincipalsByPropertyValuesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})" /> method (DAV:principal-property-search REPORT defined
            in Section 9.4).
            A client could use the results of this method
            to present a query interface to the user for retrieving principals.
            </summary>
            <returns>Searcheable properties.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolderAsync.GetPrincipalSearcheablePropertiesAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.GetMatchingPrincipalsAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Is used to find all groups residing in the subtree of current item which contain currently authenticated
            user. The user itself shall also be included if it is located in the subtree of this item.
            </summary>
            <param name="props">Properties to return with every item found.</param>
            <returns>Groups which contain currently authenticated user.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolderAsync.GetMatchingPrincipalsAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.MatchBy">
            <summary>
            Is used by <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetItemsByPropertyAsync(ITHit.WebDAV.Server.Acl.MatchBy,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> to identify by which
            property items shall be retrieved.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Group">
            <summary>
            This value is used to indicate that items whose Group contains currently
            logged in principal shall be returned.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Owner">
            <summary>
            This value is used to indicate that items whose Owner corresponds
            to or contains currently logged in principal shall be returned.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">
            <summary>
            Indicates that an operation failed due to insufficient privileges for one or more items.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String,System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
            <param name="path">Item path.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RequiredPrivileges">
            <summary>
            List of &lt;item path, missing privilege> pairs.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.AddRequiredPrivilege(System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Adds privilege that is required to perform the operation on the item.
            </summary>
            <param name="path">Item which misses the privilege.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>
            <param name="item">Instance of <see cref="T:ITHit.Server.IHierarchyItemBaseAsync"/>.</param>
            <param name="renderContent">Whether contents shall be written to output.</param>
            <remarks>
            If exception is rendered 'inline', then it shall write only it's body.
            Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            Otherwise full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RenderInlineAsync(System.Xml.XmlWriter,ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Renders exception as part of multistatus exception.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in
            <see cref="M:ITHit.WebDAV.Server.DavException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)"/> method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.Privilege">
            <summary>
            Specifies a privilege that can be given to a principal on an item.
            </summary>
            <remarks>
            Ability to perform a method on an item is controlled by one or more privileges.
            A principal with no privileges to a resource will be denied any access to that resource, unless the principal
            matches an ACE constructed using the <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated"/>, or <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated"/>
            pseudo-principals.
            Privileges may be containers of other privileges, in which case they are termed "aggregate privileges". If a
            principal is granted or denied an aggregate privilege, it is semantically equivalent to granting or denying each
            of the aggregated privileges individually. For example, an implementation may define add-member and
            remove-member privileges that control the ability to add and remove a member of a group. Since these
            privileges control the ability to update the state of a group, these privileges would be aggregated by the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege on a group, and granting the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege
            on a group would also grant the add-member and remove-member privileges.
            Privileges may be declared to be "abstract" for a given resource, in which case they cannot be set in an ACE on
            that resource. Aggregate and non-aggregate privileges are both capable of being abstract. Abstract privileges
            are useful for modeling privileges that otherwise would not be exposed via the protocol. Abstract privileges
            also provide server implementations with flexibility in implementing the privileges.  For example, if a server
            is incapable of separating the read item capability from the read ACL  capability, it can still model the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> privileges defined in this specification by
            declaring them abstract, and containing them within a non-abstract aggregate privilege (say, read-all) that
            holds <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>. In this way, it is possible to set
            the aggregate privilege, read-all, thus coupling the setting of <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, but it is not possible to set <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, or
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> individually. Since aggregate privileges can be abstract, it is also possible
            to use abstract privileges to group or organize non-abstract privileges. Privilege containment loops are not
            allowed; therefore, a privilege MUST NOT contain itself. For example, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> cannot
            contain <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>. The set of privileges that apply to a particular item may vary with the 
            type of item (folder, resource), as well as between different server implementations. To promote 
            interoperability, however, a set of well-known privileges (e.g., <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.All"/>) is defined, which can at least
            be used to classify the other privileges defined on a particular resource. 
            Server implementations MAY define new privileges beyond those defined in <see cref="T:ITHit.WebDAV.Server.Acl.Privilege"/>. Privileges
            defined by individual implementations MUST NOT use the DAV: namespace, and instead should use a
            namespace that they control, such as an http scheme URL.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Namespace">
            <summary>
            Namespace of privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Name">
            <summary>
            Privilege name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Read">
            <summary>
            Controls methods that return information about the state of the resource, including the
            resource's properties. Affected methods include downloading content and retrieving information about item.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to donwloading content and retrieving
            information must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> - if an ACL grants
            access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, the client may expect that no other privilege needs to be granted to have
            access to downloading content and retrieving information.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Write">
            <summary>
            Controls methods that lock an item or modify the content, properties, or 
            membership of a collection.
            </summary>
            <remarks>
            State modification is  also controlled via locking, so effective write access requires that both write
            privileges and write locking requirements are satisfied. Any implementation-defined privilege that also
            controls access to methods modifying content, properties or folder membership must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, the client may expect that no
            other privilege needs to be granted to modify item's state.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties">
            <summary>
            Controls methods that modify properties of the resource.
            Such as <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/>.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to methods modifying
            properties must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/> - e.g., if an ACL grants access to
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/>, the client can safely expect that no other privilege needs to be granted
            to have access to modifying properties.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent">
            <summary>
            Controls methods that modify the content of an existing resource, such as <see cref="!:IContentAsync.WriteAsync"/>.
             </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to content must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/> - e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/>,
            the client can safely expect that no other privilege needs to be granted to have access to modifying content.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock">
            <summary>
            Controls the use of the <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/> method by a principal other than the lock owner
            (the principal that created a lock can always perform an <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/>).
            </summary>
            <remarks>
            While the set of users who may lock a
            resource is most commonly the same set of users who may modify a resource, servers may allow various kinds
            of administrators to unlock resources locked by others. Any privilege controlling access by non-lock owners
            to <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/> must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/>.
            A lock owner can always remove a lock by issuing an <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/> with the correct lock token
            and authentication credentials. That is, even if a principal does not have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege,
            they can still remove locks they own. Principals other than the lock owner can remove a lock only if they
            have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege and they issue an <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/> with the correct lock
            token. Lock timeout is not affected by the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl">
            <summary>
            Controls the use of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet">
            <summary>
            Controls the use of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync"/>.
            </summary>
            <remarks>
            Clients are intended to use this property to visually indicate in their UI items that are dependent on the
            permissions of a resource, for example, by graying out resources that are not writable.
            This privilege is separate from <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> because there is a need to allow most users access
            to the privileges permitted the current user (due to its use in creating the UI), while the full ACL
            contains information that may not be appropriate for the current authenticated user. As a result, the
            set of users who can view the full ACL is expected to be much smaller than those who can read the current
            user privilege set, and hence distinct
            privileges are needed for each.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl">
            <summary>
            Controls user of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Bind">
            <summary>
            Allows creating child items in a collection.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unbind">
            <summary>
            Allows removing child items from collection (for example using <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.DeleteAsync(ITHit.WebDAV.Server.MultistatusException)"/>
            or <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.MoveToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,ITHit.WebDAV.Server.MultistatusException)"/>).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.All">
            <summary>
            Is an aggregate privilege that contains the entire set of privileges that can be applied to the item.
            </summary>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the Privilege class.
            </summary>
            <param name="namespace">Privilege namespace.</param>
            <param name="name">Privilege name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Equality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Inequality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.ToString">
            <summary>
            Returns string representation of a privilege.
            </summary>
            <returns>String representation of the privilege.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.PropertyDescription">
            <summary>
            Used in result of <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.GetPrincipalSearcheablePropertiesAsync"/>.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Name">
            <summary>
            Property name.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Description">
            <summary>
            Property description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Lang">
            <summary>
            Property description language.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.ReadAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal">
            <summary>
            Principal to which privileges are granted and denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsProtected">
            <summary>
            Indicates that this ACE is protected and an attempt to remove it will fail.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.InheritedFrom">
            <summary>
            If not null indicates a resource from which this Ace is inherited.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsInvert">
            <summary>
            If this property is true then this ACE grants/denies privileges to all
            principals NOT matching the one in <see cref="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal"/> property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails">
            <summary>
            Error codes that can be returned as part of <see cref="T:ITHit.WebDAV.Server.DavException"/> during call
            to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with each other. This is
            a catchall error code indicating that an implementation-specific ACL restriction has been violated.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoProtectedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            protected ACEs on the resource. For example, if the resource has a protected ACE granting DAV:write to a
            given principal, then it would not be consistent if the ACL request submitted an ACE denying DAV:write to
            the same principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInheritedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            inherited ACEs on the resource. For example, if the resource inherits an ACE from its parent collection
            granting DAV:write to a given principal, then it would not be consistent if the ACL request submitted an ACE
            denying DAV:write to the same principal. Note that reporting of this error will be implementation-dependent.
            Implementations MUST either report this error or allow the ACE to be set, and then let normal ACE evaluation
            rules determine whether the new ACE has any impact on the privileges available to a specific principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.LimitedNumberOfAces">
            <summary>
            (DAV:limited-number-of-aces): The number of ACEs submitted in the ACL request MUST NOT exceed the
            number of ACEs allowed on that resource. However, ACL-compliant servers MUST support at least one ACE
            granting privileges to a single principal, and one ACE granting privileges to a group.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.DenyBeforeGrant">
            <summary>
            All non-inherited deny ACEs MUST precede all non-inherited grant ACEs.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.GrantOnly">
            <summary>
            The ACEs submitted in the ACL request MUST NOT include a deny ACE. This
            precondition applies only when the ACL restrictions of the resource include the DAV:grant-only constraint
            (defined in Section 5.6.1).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInvert">
            <summary>
            The ACL request MUST NOT include a DAV:invert element. This precondition applies only
            when the ACL semantics of the resource includes the DAV:no-invert constraint (defined in Section 5.6.2).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAbstract">
            <summary>
            The ACL request MUST NOT attempt to grant or deny an abstract privilege (see
            Section 5.3).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NotSupporterPrivilege">
            <summary>
            The ACEs submitted in the ACL request MUST be supported by the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.MissingRequiredPrincipal">
            <summary>
            The result of the ACL request MUST have at least one ACE for each
            principal identified in a DAV:required-principal XML element in the ACL semantics of that resource (see
            Section 5.5).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.RecognizedPrincipal">
            <summary>
            Every principal URL in the ACL request MUST identify a principal resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.AllowedPrincipal">
            <summary>
            The principals specified in the ACEs submitted in the ACL request MUST be
            allowed as principals for the resource. For example, a server where only authenticated principals can access
            resources would not allow the DAV:all or DAV:unauthenticated principals to be used in an ACE, since these
            would allow unauthenticated access to resources.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SupportedPrivilege">
            <summary>
            Identifies the privileges defined for the resource.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.SupportedPrivilege.#ctor">
            <summary>
            Initializes a new instance of the SupportedPrivilege class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Privilege">
            <summary>
            Privilege that this object describes.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.IsAbstract">
            <summary>
            An abstract privilege MUST NOT be used in an ACE for that resource. Servers MUST fail an attempt to set an
            abstract privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Description">
            <summary>
            A description is a human-readable description of what this privilege controls access to.
            </summary>        
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.DescriptionLanguage">
            <summary>
            Language of description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.AggregatedPrivileges">
            <summary>
            Aggregate privileges list all of the privileges this privilege aggregates.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal">
            <summary>
            Lists predefined principals having special meaning in WebDav.
            Urls of these principals will be retrieved using <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All">
            <summary>
            Matches all principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated">
            <summary>
            Matches all authenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated">
            <summary>
            Matches all unauthenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Self">
            <summary>
            Matches currently logged in principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Owner">
            <summary>
            Matches principal that is owner of hierarchy item.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Group">
            <summary>
            Matches principal that is group of hierarchy item.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WriteAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.Principal">
            <summary>
            Principal to which privileges are granted/denied.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports user and permissions management.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by the calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBeShared">
            <summary>
            Indicates that the calendar collection can be shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBePublished">
            <summary>
            Indicates that the calendar collection can be published.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleShare">
            <summary>
            Describes sharing operation specific to Apple iCal.
            </summary>
            <remarks>The list of items of this type is passed to <see cref="M:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.UpdateSharingAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.CalDav.AppleShare})"/> metod.</remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.AppleShare.FromXmlNode(System.Xml.Linq.XElement)">
            <summary>
            Parses node and sets AppleShere instance
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Operation">
            <summary>
            Describes sharing operation applied to calendar item.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleSharingOperation">
            <summary>
            Describes sharing operations that are specific to Apple iCal
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Read">
            <summary>
            Grant read privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.ReadWrite">
            <summary>
            Grant read and write privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Withdraw">
            <summary>
            Withdraw access to the calendar.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarComponentType">
            <summary>
            Specifies the calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.
            </summary>
            <remarks>
            For more details see: http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VEVENT">
            <summary>
            Event calendar component.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VTODO">
            <summary>
            To-do calendar component.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarSharedBy">
            <summary>
            Indicates that the calendar is shared and if it is shared by the current user who is the owner of the calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.NotShared">
            <summary>
            Indicates that the calendar is not shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner">
            <summary>
            Indicates that the calendar is owned by the current user and is being shared by them.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared">
            <summary>
            Indicates that the calendar is owned by another user and is being shared to the current user.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync">
            <summary>
            Calendars that imlement this interface support calendar 
            sharing from iCal on iOS and Mac OS X. Enables <b>calendarserver-sharing</b> feature support discovery.
            </summary>
            <remarks>
            <param>
            Adding this interace on calendar item 
            enables 'Share Calendar' menu option in Calendar on iOS and Mac OS X.
            </param>
            <param>
            Items with this interface will add <b>calendarserver-sharing</b> token to <b>DAV</b> header on OPTIONS requests.
            </param>
            <param>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</param>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.AllowedSharingModes">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by this calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.UpdateSharingAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.CalDav.AppleShare})">
            <summary>
            This metod is called when user is granting or 
            withdrowing acces to the calendar. 
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <param>
            In this metod implementation you will grant 
            or withdraw acces to the calendar as well as you will send sharing invitation.
            </param>
            <param>
            When user is updating acces rights, for example changing 
            acces rights from read-write to read-only the Apple iCal client application 
            submits 'delete share' and 'add share' with new access rights in a  
            single request. Your implementation must first delete all shares and 
            than add new shares regardless of the order they are sent and listed 
            in <see href="sharesToAddAndRemove"/> parameter.
            </param>
            <param>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</param>
            </remarks>
            <param name="sharesToAddAndRemove">Each item in this list describes the share to 
            add or delete.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.GetInviteAsync">
            <summary>
            Provides a list of users to whom the calendar has been shared.
            </summary>
            <remarks>
            <param>
            If calendar is shared, in addition to the list of <see cref="T:ITHit.WebDAV.Server.CalDav.SharingInvite"/> it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </param>
            <param>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.GetSharedByAsync">
            <summary>
            Indicates that the calendar is shared and if it is shared by owner.
            </summary>
            <remarks>
            <param>
            If calendar is shared, it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </param>
            <param>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.1)  
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync">
            <summary>
            Assists in finding calendars on a CalDAV server. Enables <b>calendar-home-set</b> feature support discovery.
            </summary>
            <remarks>
            <param>
            This interface helps finding folders that contain calendars. You will implement this interface on principal items, 
            as well as on any other items that you wish to report <b>calendar-home-set</b> feature support and list folders that 
            contain calendars owned by currently logged-in user. 
            </param>
            <param>
            This interface provides <see cref="M:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync.GetCalendarHomeSetAsync" />) method that is called by the Engine 
            when client is discovering list of folders that contain calendars.
            </param>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class Discovery : ICalendarDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetCalendarHomeSetAsync()
    {
        return new[] { new CalendarsRootFolder(Context) };
    }

    public bool CalendarHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
      <code lang="VB"><![CDATA[Public Class Discovery
    Implements ICalendarDiscoveryAsync

    Protected Context As DavContext

    Public Sub New(context As DavContext)
        Me.Context = context
    End Sub

    Public Async Function GetCalendarHomeSetAsync() As Task(Of IEnumerable(Of IItemCollectionAsync)) Implements ICalendarDiscoveryAsync.GetCalendarHomeSetAsync
        Return {New CalendarsRootFolder(Context)}
    End Function

    Public ReadOnly Property CalendarHomeSetEnabled As Boolean Implements ICalendarDiscoveryAsync.CalendarHomeSetEnabled
        Get
            Return True
        End Get
    End Property
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class Discovery : IAddressbookDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetAddressbookHomeSetAsync()
    {
        return new[] { new AddressbooksRootFolder(Context) };
    }

    public bool AddressbookHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
      <code lang="VB"><![CDATA[Public Class Discovery
    Implements IAddressbookDiscoveryAsync

    Protected Context As DavContext

    Public Sub New(context As DavContext)
        Me.Context = context
    End Sub

    Public Async Function GetAddressbookHomeSetAsync() As Task(Of IEnumerable(Of IItemCollectionAsync)) Implements IAddressbookDiscoveryAsync.GetAddressbookHomeSetAsync
        Return {New AddressbooksRootFolder(Context)}
    End Function

    Public ReadOnly Property AddressbookHomeSetEnabled As Boolean Implements IAddressbookDiscoveryAsync.AddressbookHomeSetEnabled
        Get
            Return True
        End Get
    End Property
End Class
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class CalendarsRootFolder : LogicalFolder, IFolderAsync
{
    private static readonly string calendarsRootFolderName = "calendars";

    public static string CalendarsRootFolderPath = DavLocationFolder.DavLocationFolderPath + calendarsRootFolderName + '/';

    public CalendarsRootFolder(DavContext context)
        : base(context, CalendarsRootFolderPath)
    {
    }

    public override async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {           
        // Here we list calendars from back-end storage. 
        // You can filter calendars if requied and return only calendars that user has access to.
        return new PageResults((await CalendarFolder.LoadAllAsync(Context)).OrderBy(x => x.Name), null);
    }

    public Task<IFileAsync> CreateFileAsync(string name)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task CreateFolderAsync(string name)
    {
        await CalendarFolder.CreateCalendarFolderAsync(Context, name, "");
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class CalendarsRootFolder
    Inherits LogicalFolder
    Implements IFolderAsync

    Private Shared ReadOnly calendarsRootFolderName As String = "calendars"

    Public Shared CalendarsRootFolderPath As String = DavLocationFolder.DavLocationFolderPath & calendarsRootFolderName & "/"c

    Public Sub New(context As DavContext)
        MyBase.New(context, CalendarsRootFolderPath)
    End Sub

    Public Overrides Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we list calendars from back-end storage. 
        ' You can filter calendars if requied and return only calendars that user has access to.
        Return New PageResults((Await CalendarFolder.LoadAllAsync(Context)).OrderBy(Function(x) x.Name), Nothing)
    End Function

    Public Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Await CalendarFolder.CreateCalendarFolderAsync(Context, name, "")
    End Function
End Class
Namespace
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[// Note:
//  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
//  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.

public class CalendarFolder : DavHierarchyItem, ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<ICalendarFolderAsync> LoadByIdAsync(DavContext context, Guid calendarFolderId)
    {
        // Load only calendar that the use has access to. 
        // Also load complete ACL for this calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@CalendarFolderId", calendarFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<ICalendarFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only calendars that the use has access to. 
        // Also load complete ACL for each calendar, but only if user has access to that calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFolderAsync> calendarFolders = new List<ICalendarFolderAsync>();
        
        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))                    
        {
            DataTable calendars = new DataTable();
            calendars.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowCalendarFolder in calendars.Rows)
            {
                Guid calendarFolderId = rowCalendarFolder.Field<Guid>("CalendarFolderId");

                string filter = string.Format("CalendarFolderId = '{0}'", calendarFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                calendarFolders.Add(new CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess));
            }
        }

        return calendarFolders;
    }

    public static async Task CreateCalendarFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create calendar.
        // 2. Grant owner privileges to the user on the created calendar.
        string sql = @"INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid calendarFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid calendarFolderId;

    private readonly DataRow rowCalendarFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowCalendarFolder != null ? rowCalendarFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId);
        }
    }

    private CalendarFolder(DavContext context, Guid calendarFolderId, DataRow calendar, DataRow[] rowsAccess)
        : base(context)
    {
        this.calendarFolderId = calendarFolderId;
        this.rowCalendarFolder = calendar;
        this.rowsAccess = rowsAccess;
    }

    public async Task<IEnumerable<ICalendarFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of UIDs from path list.
        IEnumerable<string> uids = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICalendarFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList(), null, null, null)).Page.Cast<ICalendarFileAsync>();
    }

    public IEnumerable<CalendarComponentType> SupportedComponentTypes
    {
        get
        {
            return new[]
                {
                    CalendarComponentType.VEVENT,
                    CalendarComponentType.VTODO,
                };
        }
    }

    public string CalendarDescription 
    {
        get { return rowCalendarFolder.Field<string>("Description"); }
    }

    public ulong MaxResourceSize
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxInstances
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxAttendeesPerInstance
    {
        get { return ulong.MaxValue; }
    }

    public DateTime UtcMinDateTime
    {
        get { return DateTime.MinValue.ToUniversalTime(); }
    }

    public DateTime UtcMaxDateTime
    {
        get { return DateTime.MaxValue.ToUniversalTime(); }
    }

    public async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {
        // Here we enumerate all events and to-dos contained in this calendar.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync, that follow this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return new PageResults((await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum)), null);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual event or to-do object is created in datatbase in CardFile.Write call.
        return CalendarFile.CreateCalendarFile(Context, calendarFolderId);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only calendars renaming. Check that user has permissions to write.
        string sql = @"UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , destName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                "@CalendarFolderId", calendarFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))            
        {
            while (await reader.ReadAsync())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , prop.QualifiedName.Name,
            "@Namespace"        , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , name,
            "@Namespace"        , ns);
    }


    public IEnumerable<AppleAllowedSharingMode> AllowedSharingModes
    {
        get
        {
            return new[]
                {
                    AppleAllowedSharingMode.CanBePublished,
                    AppleAllowedSharingMode.CanBeShared,
                };
        }
    }

    public async Task UpdateSharingAsync(IList<AppleShare> sharesToAddAndRemove)
    {
        // Drop all shares first regardless of operation order. When resending 
        // invitations Apple Calendar drops and adds shares for the user in one \
        // request.
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation == AppleSharingOperation.Withdraw)
            {
                // remove sharing here
                // share.Address
                // share.CommonName
            }
        }

        // Add new shares
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation != AppleSharingOperation.Withdraw)
            {
                // enable sharing and send invitation here
                // share.Address
                // share.CommonName
            }
        }
    }

    public async Task<IEnumerable<SharingInvite>> GetInviteAsync()
    {

        IList<SharingInvite> invites = new List<SharingInvite>();

        foreach (DataRow rowAccess in rowsAccess)
        {
            if (rowAccess.Field<bool>("Owner"))
                continue;

            string userId = rowAccess.Field<string>("UserId");
            System.Web.Security.MembershipUser user = System.Web.Security.Membership.GetUser(userId);

            SharingInvite ace = new SharingInvite
            {
                  Address       = string.Format("email:{0}", user.Email)
                , Access        = rowAccess.Field<bool>("Write") ? SharingInviteAccess.ReadWrite : SharingInviteAccess.Read
                , CommonName    = user.UserName
                , Status        = SharingInviteStatus.Accepted
            };
        }

        return invites;
    }

    public async Task<CalendarSharedBy> GetSharedByAsync()
    {
        if (rowsAccess.Any(x => !x.Field<bool>("Owner")))
        {
            return CalendarSharedBy.NotShared;
        }

        string ownerId = rowsAccess.First(x => x.Field<bool>("Owner")).Field<string>("UserId");
        if (ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase))
        {
            return CalendarSharedBy.SharedByOwner;
        }
        else
        {
            return CalendarSharedBy.Shared;
        }
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId") == Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
      <code lang="VB"><![CDATA[' Note:
'  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
'  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.
Public Class CalendarFolder
    Inherits DavHierarchyItem
    Implements ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync

    Public Shared Async Function LoadByIdAsync(context As DavContext, calendarFolderId As Guid) As Task(Of ICalendarFolderAsync)
        ' Load only calendar that the use has access to. 
        ' Also load complete ACL for this calendar.
        Dim sql As String = "SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)"
        Return(Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@CalendarFolderId", calendarFolderId
                              )).FirstOrDefault()
    End Function

    Public Shared Async Function LoadAllAsync(context As DavContext) As Task(Of IEnumerable(Of ICalendarFolderAsync))
        ' Load only calendars that the use has access to. 
        ' Also load complete ACL for each calendar, but only if user has access to that calendar.
        Dim sql As String = "SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)"
        Return Await LoadAsync(context, sql, "@UserId", context.UserId)
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of ICalendarFolderAsync))
        Dim calendarFolders As IList(Of ICalendarFolderAsync) = New List(Of ICalendarFolderAsync)()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim calendars As DataTable = New DataTable()
            calendars.Load(reader)
            Dim access As DataTable = New DataTable()
            access.Load(reader)
            For Each rowCalendarFolder As DataRow In calendars.Rows
                Dim calendarFolderId As Guid = rowCalendarFolder.Field(Of Guid)("CalendarFolderId")
                Dim filter As String = String.Format("CalendarFolderId = '{0}'", calendarFolderId)
                Dim rowsAccess As DataRow() = access.Select(filter)
                calendarFolders.Add(New CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess))
            Next
        End Using

        Return calendarFolders
    End Function

    Public Shared Async Function CreateCalendarFolderAsync(context As DavContext, name As String, description As String) As Task
        ' 1. Create calendar.
        ' 2. Grant owner privileges to the user on the created calendar.
        Dim sql As String = "INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )"
        Dim calendarFolderId As Guid = Guid.NewGuid()
        Await context.ExecuteNonQueryAsync(sql,
                                          "@CalendarFolderId", calendarFolderId,
                                          "@Name", name,
                                          "@Description", description,
                                          "@UserId", context.UserId,
                                          "@Owner", True, "@Read", True, "@Write", True)
    End Function

    Private ReadOnly calendarFolderId As Guid

    Private ReadOnly rowCalendarFolder As DataRow

    Private ReadOnly rowsAccess As DataRow()

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            Return If(rowCalendarFolder IsNot Nothing, rowCalendarFolder.Field(Of String)("Name"), Nothing)
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Return String.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId)
        End Get
    End Property

    Private Sub New(context As DavContext, calendarFolderId As Guid, calendar As DataRow, rowsAccess As DataRow())
        MyBase.New(context)
        Me.calendarFolderId = calendarFolderId
        Me.rowCalendarFolder = calendar
        Me.rowsAccess = rowsAccess
    End Sub

    Public Async Function MultiGetAsync(pathList As IEnumerable(Of String), propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICalendarFileAsync)) Implements ICalendarReportAsync.MultiGetAsync
        ' Get list of UIDs from path list.
        Dim uids As IEnumerable(Of String) = pathList.Select(Function(a) System.IO.Path.GetFileNameWithoutExtension(a))
        Return Await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All)
    End Function

    Public Async Function QueryAsync(rawQuery As String, propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICalendarFileAsync)) Implements ICalendarReportAsync.QueryAsync
        ' For the sake of simplicity we just call GetChildren returning all items. 
        ' Typically you will return only items that match the query.
        Return(Await GetChildrenAsync(propNames.ToList(), Nothing, Nothing, Nothing)).Page.Cast(Of ICalendarFileAsync)()
    End Function

    Public ReadOnly Property SupportedComponentTypes As IEnumerable(Of CalendarComponentType) Implements ICalendarFolderAsync.SupportedComponentTypes
        Get
            Return {CalendarComponentType.VEVENT,
                   CalendarComponentType.VTODO}
        End Get
    End Property

    Public ReadOnly Property CalendarDescription As String Implements ICalendarFolderAsync.CalendarDescription
        Get
            Return rowCalendarFolder.Field(Of String)("Description")
        End Get
    End Property

    Public ReadOnly Property MaxResourceSize As ULong Implements ICalendarFolderAsync.MaxResourceSize
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property MaxInstances As ULong Implements ICalendarFolderAsync.MaxInstances
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property MaxAttendeesPerInstance As ULong Implements ICalendarFolderAsync.MaxAttendeesPerInstance
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property UtcMinDateTime As DateTime Implements ICalendarFolderAsync.UtcMinDateTime
        Get
            Return DateTime.MinValue.ToUniversalTime()
        End Get
    End Property

    Public ReadOnly Property UtcMaxDateTime As DateTime Implements ICalendarFolderAsync.UtcMaxDateTime
        Get
            Return DateTime.MaxValue.ToUniversalTime()
        End Get
    End Property

    Public Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we enumerate all events and to-dos contained in this calendar.
        ' You can filter children items in this implementation and 
        ' return only items that you want to be available for this 
        ' particular user.
        ' Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        ' The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        ' report, in MultiGetAsync, that follow this request.
        ' Bynari submits PROPFIND without props - Engine will request getcontentlength
        Dim children As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
        Return New PageResults((Await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum)), Nothing)
    End Function

    Public Async Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        ' The actual event or to-do object is created in datatbase in CardFile.Write call.
        Return CalendarFile.CreateCalendarFile(Context, calendarFolderId)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Throw New DavException("Not allowed.", DavStatus.NOT_ALLOWED)
    End Function

    Public Overrides Async Function MoveToAsync(destFolder As IItemCollectionAsync, destName As String, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.MoveToAsync
        ' Here we support only calendars renaming. Check that user has permissions to write.
        Dim sql As String = "UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@CalendarFolderId", calendarFolderId,
                                             "@Name", destName) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        ' Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        Dim sql As String = "DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@CalendarFolderId", calendarFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function GetPropertiesAsync(names As IList(Of PropertyName), allprop As Boolean) As Task(Of IEnumerable(Of PropertyValue)) Implements IHierarchyItemAsync.GetPropertiesAsync
        Dim propVals As IList(Of PropertyValue) = Await GetPropertyValuesAsync("SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                                                                              "@CalendarFolderId", calendarFolderId)
        If allprop Then
            Return propVals
        Else
            Dim requestedPropVals As IList(Of PropertyValue) = New List(Of PropertyValue)()
            For Each p As PropertyValue In propVals
                If names.Contains(p.QualifiedName) Then
                    requestedPropVals.Add(p)
                End If
            Next

            Return requestedPropVals
        End If
    End Function

    Public Overrides Async Function UpdatePropertiesAsync(setProps As IList(Of PropertyValue),
                                                         delProps As IList(Of PropertyName),
                                                         multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.UpdatePropertiesAsync
        For Each p As PropertyValue In setProps
            Await SetPropertyAsync(p)
        Next

        For Each p As PropertyName In delProps
            Await RemovePropertyAsync(p.Name, p.Namespace)
        Next
    End Function

    Private Async Function GetPropertyValuesAsync(command As String, ParamArray prms As Object()) As Task(Of IList(Of PropertyValue))
        Dim l As List(Of PropertyValue) = New List(Of PropertyValue)()
        Using reader As SqlDataReader = Await Context.ExecuteReaderAsync(command, prms)
            While Await reader.ReadAsync()
                Dim name As String = reader.GetString(reader.GetOrdinal("Name"))
                Dim ns As String = reader.GetString(reader.GetOrdinal("Namespace"))
                Dim value As String = reader.GetString(reader.GetOrdinal("PropVal"))
                l.Add(New PropertyValue(New PropertyName(name, ns), value))
            End While
        End Using

        Return l
    End Function

    Private Async Function SetPropertyAsync(prop As PropertyValue) As Task
        Dim selectCommand As String = "SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
        Dim count As Integer = Await Context.ExecuteScalarAsync(Of Integer)(selectCommand,
                                                                           "@CalendarFolderId", calendarFolderId,
                                                                           "@Name", prop.QualifiedName.Name,
                                                                           "@Namespace", prop.QualifiedName.Namespace)
        ' insert
        If count = 0 Then
            Dim insertCommand As String = "INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)"
            Await Context.ExecuteNonQueryAsync(insertCommand,
                                              "@PropVal", prop.Value,
                                              "@CalendarFolderId", calendarFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        Else
            ' update
            Dim command As String = "UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
            Await Context.ExecuteNonQueryAsync(command,
                                              "@PropVal", prop.Value,
                                              "@CalendarFolderId", calendarFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        End If
    End Function

    Private Async Function RemovePropertyAsync(name As String, ns As String) As Task
        Dim command As String = "DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace"
        Await Context.ExecuteNonQueryAsync(command,
                                          "@CalendarFolderId", calendarFolderId,
                                          "@Name", name,
                                          "@Namespace", ns)
    End Function

    Public ReadOnly Property AllowedSharingModes As IEnumerable(Of AppleAllowedSharingMode) Implements IAppleCalendarAsync.AllowedSharingModes
        Get
            Return {AppleAllowedSharingMode.CanBePublished,
                   AppleAllowedSharingMode.CanBeShared}
        End Get
    End Property

    Public Async Function UpdateSharingAsync(sharesToAddAndRemove As IList(Of AppleShare)) As Task Implements IAppleCalendarAsync.UpdateSharingAsync
        ' Drop all shares first regardless of operation order. When resending 
        ' invitations Apple Calendar drops and adds shares for the user in one \
        ' request.
        For Each share As AppleShare In sharesToAddAndRemove
            If share.Operation = AppleSharingOperation.Withdraw Then
                ' remove sharing here
                ' share.Address
                ' share.CommonName
                 End If
        Next

        ' Add new shares
        For Each share As AppleShare In sharesToAddAndRemove
            If share.Operation <> AppleSharingOperation.Withdraw Then
                ' enable sharing and send invitation here
                ' share.Address
                ' share.CommonName
                 End If
        Next
    End Function

    Public Async Function GetInviteAsync() As Task(Of IEnumerable(Of SharingInvite)) Implements IAppleCalendarAsync.GetInviteAsync
        Dim invites As IList(Of SharingInvite) = New List(Of SharingInvite)()
        For Each rowAccess As DataRow In rowsAccess
            If rowAccess.Field(Of Boolean)("Owner") Then Continue For
            Dim userId As String = rowAccess.Field(Of String)("UserId")
            Dim user As System.Web.Security.MembershipUser = System.Web.Security.Membership.GetUser(userId)
            Dim ace As SharingInvite = New SharingInvite With {.Address = String.Format("email:{0}", user.Email),
                                                         .Access = If(rowAccess.Field(Of Boolean)("Write"), SharingInviteAccess.ReadWrite, SharingInviteAccess.Read),
                                                         .CommonName = user.UserName,
                                                         .Status = SharingInviteStatus.Accepted
                                                         }
        Next

        Return invites
    End Function

    Public Async Function GetSharedByAsync() As Task(Of CalendarSharedBy) Implements IAppleCalendarAsync.GetSharedByAsync
        If rowsAccess.Any(Function(x) Not x.Field(Of Boolean)("Owner")) Then
            Return CalendarSharedBy.NotShared
        End If

        Dim ownerId As String = rowsAccess.First(Function(x) x.Field(Of Boolean)("Owner")).Field(Of String)("UserId")
        If ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase) Then
            Return CalendarSharedBy.SharedByOwner
        Else
            Return CalendarSharedBy.Shared
        End If
    End Function

    Public Function SetOwnerAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetOwnerAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetOwnerAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetOwnerAsync
        Dim rowOwner As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of Boolean)("Owner") = True)
        If rowOwner Is Nothing Then Return Nothing
        Return Await Acl.User.GetUserAsync(Context, rowOwner.Field(Of String)("UserId"))
    End Function

    Public Function SetGroupAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetGroupAsync
        Throw New DavException("Group cannot be set", DavStatus.FORBIDDEN)
    End Function

    Public Async Function GetGroupAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetGroupAsync
        Return Nothing
    End Function

    Public Async Function GetSupportedPrivilegeSetAsync() As Task(Of IEnumerable(Of SupportedPrivilege)) Implements IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync
        Return {New SupportedPrivilege With {.Privilege = Privilege.Read, .IsAbstract = False, .DescriptionLanguage = "en",
                                       .Description = "Allows or denies the user the ability to read content and properties of files/folders."},
               New SupportedPrivilege With {.Privilege = Privilege.Write, .IsAbstract = False, .DescriptionLanguage = "en",
                                                                                                                                                                                                                                                             .Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."}}
    End Function

    Public Async Function GetCurrentUserPrivilegeSetAsync() As Task(Of IEnumerable(Of Privilege)) Implements IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync
        Dim rowAccess As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of String)("UserId") = Context.UserId)
        If rowAccess Is Nothing Then Return Nothing
        Dim privileges As List(Of Privilege) = New List(Of Privilege)()
        If rowAccess.Field(Of Boolean)("Read") Then privileges.Add(Privilege.Read)
        If rowAccess.Field(Of Boolean)("Write") Then privileges.Add(Privilege.Write)
        Return privileges
    End Function

    Public Async Function GetAclAsync(propertyNames As IList(Of PropertyName)) As Task(Of IEnumerable(Of ReadAce)) Implements IAclHierarchyItemAsync.GetAclAsync
        Dim aceList As IList(Of ReadAce) = New List(Of ReadAce)()
        For Each rowAccess As DataRow In rowsAccess
            Dim ace As ReadAce = New ReadAce()
            ace.Principal = Await Acl.User.GetUserAsync(Context, rowAccess.Field(Of String)("UserId"))
            If rowAccess.Field(Of Boolean)("Read") Then ace.GrantPrivileges.Add(Privilege.Read)
            If rowAccess.Field(Of Boolean)("Write") Then ace.GrantPrivileges.Add(Privilege.Write)
            ace.IsProtected = rowAccess.Field(Of Boolean)("Owner")
            aceList.Add(ace)
        Next

        Return aceList
    End Function

    Public Function SetAclAsync(aces As IList(Of WriteAce)) As Task Implements IAclHierarchyItemAsync.SetAclAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetAclRestrictionsAsync() As Task(Of AclRestriction) Implements IAclHierarchyItemAsync.GetAclRestrictionsAsync
        Return New AclRestriction With {.NoInvert = True, .GrantOnly = True}
    End Function

    Public Async Function GetInheritedAclSetAsync() As Task(Of IEnumerable(Of IHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetInheritedAclSetAsync
        Return New IHierarchyItemAsync() {}
    End Function

    Public Async Function GetPrincipalCollectionSetAsync() As Task(Of IEnumerable(Of IPrincipalFolderAsync)) Implements IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync
        Return New IPrincipalFolderAsync() {New Acl.UsersFolder(Context)}
    End Function

    Public Async Function ResolveWellKnownPrincipalAsync(wellKnownPrincipal As WellKnownPrincipal) As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync
        Return Nothing
    End Function

    Public Function GetItemsByPropertyAsync(matchBy As MatchBy, props As IList(Of PropertyName)) As Task(Of IEnumerable(Of IAclHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetItemsByPropertyAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync.CalendarHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>calendar-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <param>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>calendar-home-set</b> feature for specific client. 
            </param>
            <param>
            iOS and OS X does require <b>calendar-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CalDAV client. iOS starts immediate synchronization of all calendars found on the server 
            via home-set request. Typically you will always enable home-set for iOS and OS X CalDAV clients, but may disable it for other clients.
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync.GetCalendarHomeSetAsync">
            <summary>
            Returns list of folder items that contain calendars owned by this principal.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <param>
            Note that this property returns list of folders that contain calendar folders, NOT the calendar folders themselves.
            </param>
            <param>
            http://tools.ietf.org/html/rfc4791#section-6.2.1
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFileAsync">
            <summary>
            Represents calendar file. 
            </summary>
            <remarks>
            <param>
            Items of this type will return content returned from 
            <see cref="!:IContentAsync.ReadAsync" /> method in <b>calendar-data</b> 
            CalDAV property.
            </param>
            <param>
            This is the marker interface, it does not provide any methods or properties in 
            addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync" /> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem" /> interfaces.
            </param>
            <param>
            Calendar file contains definition of the calendar resource in the iCalendar format. 
            </param>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[

// +--- Calendar file [UID1].ics ---------+
// |                                      |
// |  +-- Time zone component ---------+  | -- Time zones are are not stored in DB, they are generated automatically 
// |  | TZID: Zone X                   |  |    during serialization, based on TZIDs found in event or to-do.
// |  | ...                            |  |
// |  +--------------------------------+  |
// |                                      |
// |  +-- Time zone component ---------+  |
// |  | TZID: Zone Y                   |  | -- Time zone IDs could be either IANA (Olson) IDs or System (Windows) IDs.
// |  | ...                            |  |
// |  +--------------------------------+  |
// |  ...                                 |
// |                                      |
// |                                      |
// |  +-- Event component -------------+  | -- Event / do-do components are stored in [cal_EventComponent] table.
// |  | UID: [UID1]                    |  |    
// |  | RRULE: FREQ=DAILY              |  | 
// |  | SUMMARY: Event A               |  |
// |  | ...                            |  |
// |  +--------------------------------+  |
// |                                      |
// |  +-- Event component -------------+  | -- In case of recurring events/to-dos there could be more than one component
// |  | UID: [UID1]                    |  |    per file. All event/to-do components within a single calendar file share
// |  | RECURRENCE-ID: 20151028        |  |    the same UID but have different RECURRENCE-IDs. 
// |  | SUMMARY: Instance 5 of Event A |  |    
// |  | ...                            |  |    iOS / OS X UIDs are case sensitive (uppercase GUIDs).
// |  +--------------------------------+  |    Bynari WebDAV Collaborator for MS Outlook UIDs are over 100 chars in length.
// |  ...                                 |
// |                                      |
// |                                      |
// +--------------------------------------+
// 
// 
// 
//    +-- Event component -------------+
//    |                                |
//    | UID: [UID1]                    | 
//    | SUMMARY: Event A               |
//    | START: 20151016T080000         |
//    | RRULE: FREQ=DAILY              |
//    | ...                            |
//    |                                |
//    | EXDATE: 20151018T080000        | -- Recurrence exception dates are stored in [cal_RecurrenceException] table.
//    | EXDATE: 20151020T080000        |
//    | ...                            |
//    |                                |
//    | ATTENDEE: mail1@server.com     | -- Attendees are stored in [cal_Attendee] table.
//    | ATTENDEE: mail2@srvr.com       |
//    | ...                            |
//    |                                |
//    | ATTACH: /9j/4VGuf+Sw...        | -- Attachments are stored in [cal_Attachment] table.
//    | ATTACH: https://serv/file.docx |
//    | ...                            |
//    |                                |
//    |  +-- Alarm Component -------+  | -- Alarms are stored in [cal_Alarm] table.
//    |  | ACTION: DISPLAY          |  |
//    |  | ...                      |  |
//    |  +--------------------------+  |
//    |                                |
//    |  +-- Alarm Component -------+  |
//    |  | ACTION: EMAIL            |  |
//    |  | ...                      |  |
//    |  +--------------------------+  |
//    |  ...                           |
//    |                                |
//    +--------------------------------+

public class CalendarFile : DavHierarchyItem, ICalendarFileAsync
{
    public static string Extension = ".ics";

    public static async Task<IEnumerable<ICalendarFileAsync>> LoadByCalendarFolderIdAsync(DavContext context, Guid calendarFolderId, PropsToLoad propsToLoad)
    {
        // propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CalDAV clients
        // [Summary] is typically not required in GetChildren call, 
        // they are extracted for demo purposes only, to be displayed in Ajax File Browser.

        // propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.

        if (propsToLoad != PropsToLoad.Minimum)
            throw new NotImplementedException("LoadByCalendarFolderIdAsync is implemented only with PropsToLoad.Minimum.");

        string sql = @"SELECT * FROM [cal_CalendarFile] 
                       WHERE [CalendarFolderId] = @CalendarFolderId
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

                      ;SELECT [UID], [Summary] FROM [cal_EventComponent] 
                       WHERE [UID] IN (SELECT [UID] FROM [cal_CalendarFile] 
                                       WHERE [CalendarFolderId] = @CalendarFolderId)";

        sql = string.Format(sql, GetScPropsToLoad(propsToLoad));
        
        return await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@CalendarFolderId"   , calendarFolderId);
    }

    public static async Task<IEnumerable<ICalendarFileAsync>> LoadByUidsAsync(DavContext context, IEnumerable<string> uids, PropsToLoad propsToLoad)
    {
        // Get IN clause part with list of file UIDs for SELECT.
        string selectIn = string.Join(", ", uids.Select(a => string.Format("'{0}'", a)).ToArray());

        string sql = @"SELECT * FROM [cal_CalendarFile] 
                       WHERE [UID] IN ({1})
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        if(propsToLoad==PropsToLoad.All)
        {
            // Here we do not select attachments content because it could be very large,
            // we only set [ContentExists] flag marking that it should be loaded during IContent.ReadAsync call.
            sql += @";SELECT * FROM [cal_EventComponent]      WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_RecurrenceException] WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Alarm]               WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Attendee]            WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_CustomProperty]      WHERE [UID] IN ({1})
                     ;SELECT [AttachmentId], [EventComponentId], [UID], [MediaType], [ExternalUrl], 
                         (CASE WHEN [Content] IS NULL THEN 0 ELSE 1 END) AS [ContentExists] 
                               FROM [cal_Attachment]          WHERE [UID] IN ({1})";
        }

        sql = string.Format(sql, GetScPropsToLoad(propsToLoad), selectIn);

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFileAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFileAsync> items = new List<ICalendarFileAsync>();

        Stopwatch stopWatch = Stopwatch.StartNew();
       
        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))           
        {
            DataTable calendarFiles = new DataTable();
            calendarFiles.Load(reader);

            DataTable eventComponents = new DataTable();
            if (!reader.IsClosed)
                eventComponents.Load(reader);

            DataTable recurrenceExceptions = new DataTable();
            if (!reader.IsClosed)
                recurrenceExceptions.Load(reader);

            DataTable alarms = new DataTable();
            if (!reader.IsClosed)
                alarms.Load(reader);

            DataTable attendees = new DataTable();
            if (!reader.IsClosed)
                attendees.Load(reader);

            DataTable customProperties = new DataTable();
            if (!reader.IsClosed)
                customProperties.Load(reader);

            DataTable attachments = new DataTable();
            if (!reader.IsClosed)
                attachments.Load(reader);


            stopWatch.Stop();
            context.Engine.Logger.LogDebug(string.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds));


            foreach (DataRow rowCalendarFile in calendarFiles.Rows)
            {
                DataRow[] rowsEventComponents      = new DataRow[0];
                DataRow[] rowsRecurrenceExceptions = new DataRow[0];
                DataRow[] rowsAlarms               = new DataRow[0];
                DataRow[] rowsAttendees            = new DataRow[0];
                DataRow[] rowsCustomProperties     = new DataRow[0];
                DataRow[] rowsAttachments          = new DataRow[0];

                string uid = rowCalendarFile.Field<string>("UID");

                string filter = string.Format("UID = '{0}'", uid);

                if (eventComponents.Columns["UID"] != null)
                    rowsEventComponents = eventComponents.Select(filter);
                if (recurrenceExceptions.Columns["UID"] != null)
                    rowsRecurrenceExceptions = recurrenceExceptions.Select(filter);
                if (alarms.Columns["UID"] != null)
                    rowsAlarms = alarms.Select(filter);
                if (attendees.Columns["UID"] != null)
                    rowsAttendees = attendees.Select(filter);
                if (customProperties.Columns["UID"] != null)
                    rowsCustomProperties = customProperties.Select(filter);
                if (attachments.Columns["UID"] != null)
                    rowsAttachments = attachments.Select(filter);

                items.Add(new CalendarFile(context, uid, rowCalendarFile, rowsEventComponents, rowsRecurrenceExceptions, rowsAlarms, rowsAttendees, rowsCustomProperties, rowsAttachments));
            }
        }

        return items;
    }

    private static string GetScPropsToLoad(PropsToLoad propsToLoad)
    {
        switch (propsToLoad)
        {
            case PropsToLoad.None:
                return "[UID]";
            case PropsToLoad.Minimum:
                // [Summary] is typically not required in GetChildren call, 
                // they are extracted for demo purposes only, to be displayed in Ajax File Browser as a file display name.
                return "[UID], [Summary]";
            case PropsToLoad.All:
                return "*";
        }
        throw new Exception("Should never come here.");
    }

    public static CalendarFile CreateCalendarFile(DavContext context, Guid calendarFolderId)
    {
        CalendarFile calendarFile = new CalendarFile(context, null, null, null, null, null, null, null, null);
        calendarFile.calendarFolderId = calendarFolderId;
        return calendarFile;
    }

    private readonly string uid = null;

    private readonly DataRow rowCalendarFile = null;

    private readonly DataRow[] rowsEventComponents = null;

    private readonly DataRow[] rowsRecurrenceExceptions = null;

    private readonly DataRow[] rowsAlarms = null;

    private readonly DataRow[] rowsAttendees = null;

    private readonly DataRow[] rowsCustomProperties = null;

    private readonly DataRow[] rowsAttachments = null;

    private bool isNew
    {
        get { return calendarFolderId != Guid.Empty; }
    }

    private int paramIndex = 0;

    private Guid calendarFolderId = Guid.Empty;

    public override string Name
    {
        get
        {
            // Show all components summaries contained in this file.
            return string.Join(", ", rowsEventComponents.Select(x => string.Format("[{0}]", x.Field<string>("Summary"))).ToArray());
        }
    }

    public override string Path
    {
        get
        {
            Guid calendarFolderId = rowCalendarFile.Field<Guid>("CalendarFolderId");
            string uid              = rowCalendarFile.Field<string>("UID");
            return string.Format("{0}{1}/{2}{3}", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId, uid, Extension);
        }
    }

    public string Etag
    {
        get
        {
            byte[] bETag = rowCalendarFile.Field<byte[]>("ETag");
            return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString(); // convert timestamp value to number
        }
    }

    public override DateTime Created
    {
        get { return rowCalendarFile.Field<DateTime>("CreatedUtc"); }
    }

    public override DateTime Modified
    {
        get { return rowCalendarFile.Field<DateTime>("ModifiedUtc"); }
    }

    public long ContentLength
    {
        get { return -1; }
    }

    public string ContentType
    {
     get { return "text/calendar"; }
    }

    private CalendarFile(DavContext context, string uid,
        DataRow rowCalendarFile, DataRow[] rowsEventComponents, DataRow[] rowsRecurrenceExceptions, DataRow[] rowsAlarms,
        DataRow[] rowsAttendees, DataRow[] rowsCustomProperties, DataRow[] rowsAttachments)
        : base(context)
    {
        this.uid                      = uid;
        this.rowCalendarFile          = rowCalendarFile;
        this.rowsEventComponents      = rowsEventComponents;
        this.rowsRecurrenceExceptions = rowsRecurrenceExceptions;
        this.rowsAlarms               = rowsAlarms;
        this.rowsAttendees            = rowsAttendees;
        this.rowsCustomProperties     = rowsCustomProperties;
        this.rowsAttachments          = rowsAttachments;
    }

    public async Task<bool> WriteAsync(Stream stream, string contentType, long startIndex, long totalFileSize)
    {
        //Set timeout to maximum value to be able to upload iCalendar files with large file attachments.
        System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
        string iCalendar;
        using (StreamReader reader = new StreamReader(stream))
        {
            iCalendar = await reader.ReadToEndAsync();
        }

        // Typically the stream contains a single iCalendar that contains one or more event or to-do components.
        IEnumerable<IComponent> calendars = new vFormatter().Deserialize(iCalendar);
        ICalendar2 calendar = calendars.First() as ICalendar2;

        IEnumerable<IEventBase> components = calendar.Events.Cast<IEventBase>();
        if (!components.Any())
        {
            components = calendar.ToDos.Cast<IEventBase>();
        }

        if (components == null)
            throw new DavException("Event or to-do was expected in the input stream, no events or to-dos were found.", DavStatus.UNSUPPORTED_MEDIA_TYPE);

        // All components inside calendar file has the same UID which is equal to file name.
        string uid = components.First().Uid.Text;

        // Save data to [cal_CalendarFile] table.
        await WriteCalendarFileAsync(Context, uid, calendarFolderId, isNew);

        foreach (IEventBase component in components)
        {
            Guid eventComponentId = Guid.NewGuid();

            // Save data to [cal_EventComponent] table.
            await WriteEventComponentAsync(Context, component, eventComponentId, uid);

            // Save recurrence days exceptions for recurring events and to-dos. 
            await WriteRecurrenceExceptionsAsync(Context, component.ExceptionDateTimes, eventComponentId, uid);

            // Save alarms.
            await WriteAlarmsAsync(Context, component.Alarms, eventComponentId, uid);

            // Save attendees.
            await WriteAttendeesAsync(Context, component.Attendees, eventComponentId, uid);

            // Save attachments.
            await WriteAttachmentsAsync(Context, component.Attachments, eventComponentId, uid);
        }

        // Notify attendees that event is created or modified.
        calendar.Method = calendar.CreateMethodProp(MethodType.Request);
        await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, calendar);

        return true;
    }

    private static async Task WriteCalendarFileAsync(DavContext context, string uid, Guid calendarFolderId, bool isNew)
    {
        string sql;
        if (isNew)
        {
            sql =
              @"IF EXISTS (SELECT 1 FROM [cal_Access] WHERE [CalendarFolderId]=@CalendarFolderId AND [UserId]=@UserId AND [Write]=1)
                INSERT INTO [cal_CalendarFile] (
                      [UID]
                    , [CalendarFolderId]
                ) VALUES (
                      @UID
                    , @CalendarFolderId
                )";
        }
        else
        {
            // We can only update record in [cal_CalendarFile] table.
            // There is no way to update [cal_EventComponent], [cal_RecurrenceException], [cal_Alarm], [cal_Attendee], 
            // [cal_Attachment] and [cal_CustomProperty] for existing event, we must delete all records for this UID and recreate.

            // [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql =
              @"IF EXISTS (SELECT 1 FROM [cal_CalendarFile]
                    WHERE UID = @UID
                    AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1))
                BEGIN
                    UPDATE [cal_CalendarFile] SET 
                        [ModifiedUtc] = @ModifiedUtc
                    WHERE [UID] = @UID

                    ; DELETE FROM [cal_EventComponent]      WHERE [UID] = @UID
                    ; DELETE FROM [cal_RecurrenceException] WHERE [UID] = @UID
                    ; DELETE FROM [cal_Alarm]               WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attendee]            WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attachment]          WHERE [UID] = @UID
                    ; DELETE FROM [cal_CustomProperty]      WHERE [UID] = @UID
                END";
        }

        if(await context.ExecuteNonQueryAsync(sql,
              "@UID"                , uid
            , "UserId"              , context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@ModifiedUtc"        , DateTime.UtcNow) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    private async Task WriteEventComponentAsync(DavContext context, IEventBase sc, Guid eventComponentId, string uid)
    {
        string sql =
                @"INSERT INTO [cal_EventComponent] (
                      [EventComponentId]
                    , [UID]
                    , [ComponentType]
                    , [DateTimeStampUtc]
                    , [CreatedUtc]
                    , [LastModifiedUtc]
                    , [Summary]
                    , [Description]
                    , [OrganizerEmail]
                    , [OrganizerCommonName]
                    , [Start]
                    , [StartTimeZoneId]
                    , [End]
                    , [EndTimeZoneId]
                    , [Duration]
                    , [AllDay]
                    , [Class]
                    , [Location]
                    , [Priority]
                    , [Sequence]
                    , [Status]
                    , [Categories]
                    , [RecurFrequency]
                    , [RecurInterval]
                    , [RecurUntil]
                    , [RecurCount]
                    , [RecurWeekStart]
                    , [RecurByDay]
                    , [RecurByMonthDay]
                    , [RecurByMonth]
                    , [RecurBySetPos]
                    , [RecurrenceIdDate]
                    , [RecurrenceIdTimeZoneId]
                    , [RecurrenceIdThisAndFuture]
                    , [EventTransparency]
                    , [ToDoCompletedUtc]
                    , [ToDoPercentComplete]
                ) VALUES (
                      @EventComponentId
                    , @UID
                    , @ComponentType
                    , @DateTimeStampUtc 
                    , @CreatedUtc
                    , @LastModifiedUtc
                    , @Summary
                    , @Description
                    , @OrganizerEmail
                    , @OrganizerCommonName
                    , @Start, @StartTimeZoneId
                    , @End, @EndTimeZoneId
                    , @Duration
                    , @AllDay
                    , @Class
                    , @Location
                    , @Priority
                    , @Sequence
                    , @Status
                    , @Categories
                    , @RecurFrequency
                    , @RecurInterval
                    , @RecurUntil
                    , @RecurCount
                    , @RecurWeekStart
                    , @RecurByDay
                    , @RecurByMonthDay
                    , @RecurByMonth
                    , @RecurBySetPos
                    , @RecurrenceIdDate
                    , @RecurrenceIdTimeZoneId
                    , @RecurrenceIdThisAndFuture
                    , @EventTransparency
                    , @ToDoCompletedUtc
                    , @ToDoPercentComplete
                )";


        bool isEvent = sc is IEvent;

        // Get END in case of event or DUE in case of to-do component. 
        ICalDate endProp = isEvent ? (sc as IEvent).End : (sc as IToDo).Due;
        
        await context.ExecuteNonQueryAsync(sql,
              "@EventComponentId"       , eventComponentId
            , "@UID"                    , uid                                                                   // UID value
            , "@ComponentType"          , isEvent
            , "@DateTimeStampUtc"       , sc.DateTimeStampUtc?.Value?.DateVal                                   // DTSTAMP value
            , "@CreatedUtc"             , sc.CreatedUtc?.Value?.DateVal                                         // CREATED value
            , "@LastModifiedUtc"        , sc.LastModifiedUtc?.Value?.DateVal                                    // LAST-MODIFIED value
            , "@Summary"                , sc.Summary?.Text                                                      // SUMMARY value
            , "@Description"            , sc.Description?.Text                                                  // DESCRIPTION value
            , "@OrganizerEmail"         , sc.Organizer?.Uri?.Replace("mailto:", "")                             // ORGANIZER value
            , "@OrganizerCommonName"    , sc.Organizer?.CommonName                                              // ORGANIZER CN param
            , "@Start"                  , sc.Start?.Value?.DateVal                                              // DTSTART value
            , "@StartTimeZoneId"        , sc.Start?.Value?.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : sc.Start?.TimeZoneId  // DTSTART TZID param
            , "@End"                    , endProp?.Value?.DateVal                                               // DTEND or DUE value
            , "@EndTimeZoneId"          , endProp?.Value?.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : endProp?.TimeZoneId    // DTEND or DUE TZID param
            , "@Duration"               , sc.Duration?.Value?.Ticks                                             // DURATION value
            , "@AllDay"                 , !sc.Start?.Value?.Components.HasFlag(DateComponents.Time) // Check if start contains the time part to determine if this is a all-day event/to-do.
            , "@Class"                  , sc.Class?.Value.Name                                                  // CLASS value
            , "@Location"               , sc.Location?.Text                                                     // LOCATION value
            , "@Priority"               , sc.Priority?.Value                                                    // PRIORITY value
            , "@Sequence"               , sc.Sequence?.Value                                                    // SEQUENCE value
            , "@Status"                 , sc.Status?.Value.Name                                                 // STATUS value
            , "@Categories"             , ListToString<string>(sc.Categories.Select(x => ListToString<string>(x.Categories, ",")), ";") // CATEGORIES value
            , "@RecurFrequency"         , sc.RecurrenceRule?.Frequency?.ToString()                              // RRULE FREQ value part
            , "@RecurInterval"          , (int?)sc.RecurrenceRule?.Interval                                     // RRULE INTERVAL value part
            , "@RecurUntil"             , sc.RecurrenceRule?.Until?.DateVal                                     // RRULE UNTIL value part
            , "@RecurCount"             , (int?)sc.RecurrenceRule?.Count                                        // RRULE COUNT value part
            , "@RecurWeekStart"         , sc.RecurrenceRule?.WeekStart?.ToString()                              // RRULE WKST value part
            , "@RecurByDay"             , ListToString<DayRule>(sc.RecurrenceRule?.ByDay)                       // RRULE BYDAY value part
            , "@RecurByMonthDay"        , ListToString<short>(sc.RecurrenceRule?.ByMonthDay)                    // RRULE BYMONTHDAY value part
            , "@RecurByMonth"           , ListToString<ushort>(sc.RecurrenceRule?.ByMonth)                      // RRULE BYMONTH value part
            , "@RecurBySetPos"          , ListToString<short>(sc.RecurrenceRule?.BySetPos)                      // RRULE BYSETPOS value part
            , "@RecurrenceIdDate"       , sc.RecurrenceId?.Value.DateVal                                        // RECURRENCE-ID value
            , "@RecurrenceIdTimeZoneId" , sc.RecurrenceId?.TimeZoneId                                           // RECURRENCE-ID TZID param
            , "@RecurrenceIdThisAndFuture", sc.RecurrenceId?.IsThisAndFuture                                    // RECURRENCE-ID RANGE param
            , "@EventTransparency"      , (sc as IEvent)?.Transparency?.IsTransparent                           // VEVENT TRANSP value
            , "@ToDoCompletedUtc"       , (sc as IToDo)?.CompletedUtc?.Value?.DateVal                           // VTODO COMPLETED value
            , "@ToDoPercentComplete"    , (sc as IToDo)?.PercentComplete?.Value                                 // VTODO PERCENT-COMPLETE value
            );

        // Save custom properties and parameters of this component to [cal_CustomProperty] table.
        string customPropsSqlInsert;
        List<object> customPropsParamsInsert;
        if (PrepareSqlCustomPropertiesOfComponentAsync(sc, eventComponentId, uid, out customPropsSqlInsert, out customPropsParamsInsert))
        {
            await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray());
        }
    }

    private static string ListToString<T>(IEnumerable<T> arr, string separator = ",")
    {
        if ((arr == null) || !arr.Any())
            return null;
        return string.Join<T>(separator, arr);
    }

    private static async Task WriteRecurrenceExceptionsAsync(DavContext context, IPropertyList<ICalDateList> recurrenceExceptions, Guid eventComponentId, string uid)
    {
        // Typically CalDAV clients pass a single date value per EXDATE property.

        string sql =
            @"INSERT INTO [cal_RecurrenceException] (
                  [EventComponentId]
                , [UID]
                , [ExceptionDate]
                , [TimeZoneId]
                , [AllDay]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (ICalDateList dateListProp in recurrenceExceptions)
        {
            foreach (Date date in dateListProp.Dates)
            {
                if (date == null)
                    continue; // failed fo parse date

                valuesSql.Add(string.Format(@"(
                  @EventComponentId
                , @UID
                , @ExceptionDate{0}
                , @TimeZoneId{0}
                , @AllDay{0}
                )", i));

                parameters.AddRange(new object[] {
              //  "@EventComponentId"
              //  "@UID" added for performance optimization purposes
                  "@ExceptionDate" +i, date.DateVal                                                                         // EXDATE value
                , "@TimeZoneId"    +i, date.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : dateListProp.TimeZoneId// EXDATE TZID param
                , "@AllDay"        +i, !date.Components.HasFlag(DateComponents.Time)                                        // EXDATE DATE or DATE-TIME
                });
            }
            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAlarmsAsync(DavContext context, IComponentList<IAlarm> alarms, Guid eventComponentId, string uid)
    {
        string sql =
            @"INSERT INTO [cal_Alarm] (
                  [AlarmId]
                , [EventComponentId]
                , [UID]
                , [Action]
                , [TriggerAbsoluteDateTimeUtc]
                , [TriggerRelativeOffset]
                , [TriggerRelatedStart]
                , [Summary]
                , [Description]
                , [Duration]
                , [Repeat]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (IAlarm alarm in alarms)
        {
            Guid alarmId = Guid.NewGuid();

            valuesSql.Add(string.Format(@"(
                  @AlarmId{0}
                , @EventComponentId
                , @UID
                , @Action{0}
                , @TriggerAbsoluteDateTimeUtc{0}
                , @TriggerRelativeOffset{0}
                , @TriggerRelatedStart{0}
                , @Summary{0}
                , @Description{0}
                , @Duration{0}
                , @Repeat{0}
                )", i));

            parameters.AddRange(new object[] {
                  "@AlarmId"                    +i, alarmId
              //, "@EventComponentId"
              //, "@UID" added for performance optimization purposes
                , "@Action"                     +i, alarm.Action.Action.Name                                                        // Alarm ACTION property
                , "@TriggerAbsoluteDateTimeUtc" +i, alarm.Trigger?.AbsoluteDateTimeUtc                                              // Alarm TRIGGER property
                , "@TriggerRelativeOffset"      +i, alarm.Trigger?.RelativeOffset?.Ticks                                            // Alarm TRIGGER property
                , "@TriggerRelatedStart"        +i, alarm.Trigger==null ? (bool?)null : alarm.Trigger.Related == RelatedType.Start  // Alarm trigger RELATED param
                , "@Summary"                    +i, alarm.Summary?.Text                                                             // Alarm SUMMARY property
                , "@Description"                +i, alarm.Description?.Text                                                         // Alarm DESCRIPTION property
                , "@Duration"                   +i, alarm.Duration?.Value?.Ticks                                                    // Alarm DURATION property
                , "@Repeat"                     +i, alarm.Repeat?.Value                                                             // Alarm REPEAT property
            });

            // Create SQL to save custom properties of this component of this component to [cal_CustomProperty] table.
            string customPropsSqlInsert;
            List<object> customPropsParamsInsert;
            if (PrepareSqlCustomPropertiesOfComponentAsync(alarm, alarmId, uid, out customPropsSqlInsert, out customPropsParamsInsert))
            {
                sql += "; " + customPropsSqlInsert;
                parameters.AddRange(customPropsParamsInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAttendeesAsync(DavContext context, IPropertyList<IAttendee> attendees, Guid eventComponentId, string uid)
    {
        string sql =
            @"INSERT INTO [cal_Attendee] (
                  [AttendeeId]
                , [EventComponentId]
                , [UID]
                , [Email]
                , [CommonName]
                , [DirectoryEntryRef]
                , [Language]
                , [UserType]
                , [SentBy]
                , [DelegatedFrom]
                , [DelegatedTo]
                , [Rsvp]
                , [ParticipationRole]
                , [ParticipationStatus]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (IAttendee attendee in attendees)
        {
            valuesSql.Add(string.Format(@"(
                  @AttendeeId{0}
                , @EventComponentId
                , @UID
                , @Email{0}
                , @CommonName{0}
                , @DirectoryEntryRef{0}
                , @Language{0}
                , @UserType{0}
                , @SentBy{0}
                , @DelegatedFrom{0}
                , @DelegatedTo{0}
                , @Rsvp{0}
                , @ParticipationRole{0}
                , @ParticipationStatus{0}
            )", i));

            Guid attendeeId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@AttendeeId"         +i, attendeeId
              //, "@EventComponentId"
              //, "@UID" added for performance optimization purposes
                , "@Email"              +i, attendee.Uri?.Replace("mailto:", "")    // Attendee value
                , "@CommonName"         +i, attendee.CommonName                     // Attendee CN parameter
                , "@DirectoryEntryRef"  +i, attendee.Dir                            // Attendee DIR parameter
                , "@Language"           +i, attendee.Language                       // Attendee LANGUAGE parameter
                , "@UserType"           +i, attendee.UserType?.Name                 // Attendee CUTYPE parameter
                , "@SentBy"             +i, attendee.SentBy                         // Attendee SENT-BY parameter
                , "@DelegatedFrom"      +i, attendee.DelegatedFrom.FirstOrDefault() // Attendee DELEGATED-FROM parameter, here we assume only 1 delegator for the sake of simplicity
                , "@DelegatedTo"        +i, attendee.DelegatedTo.FirstOrDefault()   // Attendee DELEGATED-TO parameter, here we assume only 1 delegatee for the sake of simplicity
                , "@Rsvp"               +i, attendee.Rsvp == RsvpType.True          // Attendee RSVP parameter
                , "@ParticipationRole"  +i, attendee.ParticipationRole?.Name        // Attendee ROLE parameter
                , "@ParticipationStatus"+i, attendee.ParticipationStatus?.Name      // Attendee PARTSTAT parameter
            });

            // Prepare SQL to save custom property parameters to [cal_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ATTENDEE", attendee.RawProperty, attendeeId, uid, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAttachmentsAsync(DavContext context, IPropertyList<IMedia> attachments, Guid eventComponentId, string uid)
    {
        // It is recommended to keep attchment size below 256Kb. In case files over 1Mb should 
        // be stored, use SQL FILESTREAM, FileTable or store content in file system.

        string sqlAttachment =
            @"INSERT INTO [cal_Attachment] (
                  [AttachmentId]
                , [EventComponentId]
                , [UID]
                , [MediaType]
                , [ExternalUrl]
                , [Content]
            ) VALUES (
                  @AttachmentId
                , @EventComponentId
                , @UID
                , @MediaType
                , @ExternalUrl
                , @Content
            )";

        string customPropertiesSql = "";
        List<object> customPropertiesParameters = new List<object>();

        foreach (IMedia attachment in attachments)
        {
            // To insert NULL to VARBINARY column SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            SqlParameter contentParam = new SqlParameter("@Content", SqlDbType.VarBinary, -1);
            contentParam.Value = DBNull.Value;

            if (!attachment.IsExternal)
            {
                byte[] content = Convert.FromBase64String(attachment.Base64Data);
                contentParam.Size = content.Length;
                contentParam.Value = content;
            }

            Guid attachmentId = Guid.NewGuid();

            await context.ExecuteNonQueryAsync(sqlAttachment,
                  "@AttachmentId"       , attachmentId
                , "@EventComponentId"   , eventComponentId
                , "@UID"                , uid
                , "@MediaType"          , attachment.MediaType
                , "@ExternalUrl"        , attachment.IsExternal ? attachment.Uri : null
                , contentParam
                );

            // Prepare SQL to save custom property parameters to [].
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ATTACH", attachment.RawProperty, attachmentId, uid, out customPropSqlInsert, out customPropParametersInsert))
            {
                customPropertiesSql += "; " + customPropSqlInsert;
                customPropertiesParameters.AddRange(customPropParametersInsert);
            }
        }

        if (!string.IsNullOrEmpty(customPropertiesSql))
        {
            await context.ExecuteNonQueryAsync(customPropertiesSql, customPropertiesParameters.ToArray());
        }
    }

    private bool PrepareSqlParamsWriteCustomProperty(string propName, IRawProperty prop, Guid parentId, string uid, out string sql, out List<object> parameters)
    {
        sql =
            @"INSERT INTO [cal_CustomProperty] (
                  [ParentId]
                , [UID]
                , [PropertyName]
                , [ParameterName]
                , [Value]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        parameters = new List<object>();

        int origParamsCount = parameters.Count();

        bool isCustomProp = propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase);

        string paramName = null;

        // Save custom prop value.
        if (isCustomProp)
        {
            string val = prop.RawValue;
            valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex));

            parameters.AddRange(new object[] {
                              "@ParentId"     +paramIndex, parentId
                            , "@UID"          +paramIndex, uid       // added for performance optimization purposes
                            , "@PropertyName" +paramIndex, propName
                            , "@ParameterName"+paramIndex, paramName // null is inserted into the ParameterName field to mark prop value
                            , "@Value"        +paramIndex, val
                            });
            paramIndex++;
        }

        // Save parameters and their values.
        foreach (Parameter param in prop.Parameters)
        {
            paramName = param.Name;

            // For standard properties we save only custom params (that start with 'X-'). All standard patrams go to their fields in DB.
            // For custom properies we save all params.
            if (!isCustomProp && !paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase))
                continue;

            foreach (string value in param.Values)
            {
                string val = value;

                valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex));

                parameters.AddRange(new object[] {
                              "@ParentId"     +paramIndex, parentId
                            , "@UID"          +paramIndex, uid       // added for performance optimization purposes
                            , "@PropertyName" +paramIndex, propName
                            , "@ParameterName"+paramIndex, paramName
                            , "@Value"        +paramIndex, val
                            });
                paramIndex++;
            }
        }

        if (origParamsCount < parameters.Count())
        {
            sql = string.Format(sql, string.Join(", ", valuesSql.ToArray()));
            return true;
        }
        return false;
    }

    private bool PrepareSqlCustomPropertiesOfComponentAsync(IComponent component, Guid parentId, string uid, out string sql, out List<object> parameters)
    {
        sql = "";
        parameters = new List<object>();

        // We save only single custom props here, multiple props are saved in other methods.
        string[] multiProps = new string[] { "ATTACH", "ATTENDEE", "EXDATE" };

        // Properties in IComponent.Properties are grouped by name.
        foreach (KeyValuePair<string, IList<IRawProperty>> pair in component.Properties)
        {
            if (multiProps.Contains(pair.Key.ToUpper()) || (pair.Value.Count != 1))
                continue;

            string sqlInsert;
            List<object> parametersInsert;
            if (PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, out sqlInsert, out parametersInsert))
            {
                sql += "; " + sqlInsert;
                parameters.AddRange(parametersInsert);
            }
        }

        return !string.IsNullOrEmpty(sql);
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        ICalendar2 cal = await GetCalendarAsync();

        string sql = @"DELETE FROM [cal_CalendarFile] 
                       WHERE UID=@UID
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId AND [Write]=1)";

        if(await Context.ExecuteNonQueryAsync(sql, 
              "@UID", uid
            , "@UserId", Context.UserId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }

        // Notify attendees that event is canceled if deletion is successful.
        cal.Method = cal.CreateMethodProp(MethodType.Cancel);
        await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, cal);
    }

    public async Task ReadAsync(Stream output, long startIndex, long count)
    {
        ICalendar2 cal = await GetCalendarAsync();
        new vFormatter().Serialize(output, cal);
    }
    
    private async Task<ICalendar2> GetCalendarAsync()
    {
        ICalendar2 cal = CalendarFactory.CreateCalendar2();
        cal.ProductId = cal.CreateTextProp("-//IT Hit//Collab Lib//EN");

        // Recurrent event or to-do can contain more than one VEVENT/VTODO component in one file.
        foreach (DataRow rowEventComponent in rowsEventComponents)
        {

            // add either event or to-do to the calendar
            bool isEvent = rowEventComponent.Field<bool>("ComponentType");
            IEventBase sc;
            if (isEvent)
            {
                sc = cal.Events.CreateComponent();
                cal.Events.Add(sc as IEvent);
            }
            else
            {
                sc = cal.ToDos.CreateComponent();
                cal.ToDos.Add(sc as IToDo);
            }

            // Read component properties from previously loaded [cal_EventComponent] rows.
            ReadEventComponent(sc, rowEventComponent, cal);


            Guid eventComponentId = rowEventComponent.Field<Guid>("EventComponentId");

            // Get [cal_RecurrenceException] rows that belong to this event component only and read recurrence exceptions dates.
            IEnumerable<DataRow> rowsThisScRecurrenceExceptions = rowsRecurrenceExceptions.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadRecurrenceExceptions(sc.ExceptionDateTimes, rowsThisScRecurrenceExceptions, cal);

            // Get [cal_Alarm] rows that belong to this event component only and read alarms.
            IEnumerable<DataRow> rowsThisScAlarms = rowsAlarms.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadAlarms(sc.Alarms, rowsThisScAlarms, cal);

            // Get [cal_Attendee] rows that belong to this event component only and read attendees.
            IEnumerable<DataRow> rowsThisScAttendees = rowsAttendees.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadAttendees(sc.Attendees, rowsThisScAttendees, cal);

            // Get [cal_Attachment] rows that belong to this event component only.
            // Read attachments, load [cal_Attachment].[Content] if required.
            IEnumerable<DataRow> rowsThisScAttachments = rowsAttachments.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            await ReadAttachmentsAsync(Context, sc.Attachments, rowsThisScAttachments, cal);
        }

        // Generate VTIMEZONE components based on TZID parameters.
        cal.AutoGenerateTimeZones = true;

        return cal;
    }

    private void ReadEventComponent(IEventBase sc, DataRow row, ICalendar2 cal)
    {
        bool isAllDay = row.Field<bool?>("AllDay").GetValueOrDefault();

        sc.Uid              = cal.CreateTextProp(row.Field<string>("UID"));                                     // UID property, iOS / OS X UID is case sensitive, Bynari WebDAV Collaborator UID is over 100 chars long
        sc.DateTimeStampUtc = cal.CreateDateProp(row.Field<DateTime?>("DateTimeStampUtc"), DateTimeKind.Utc);   // DTSTAMP property
        sc.CreatedUtc       = cal.CreateDateProp(row.Field<DateTime?>("CreatedUtc"), DateTimeKind.Utc);         // CREATED property
        sc.LastModifiedUtc  = cal.CreateDateProp(row.Field<DateTime?>("LastModifiedUtc"), DateTimeKind.Utc);    // LAST-MODIFIED property
        sc.Summary          = cal.CreateCalTextProp(row.Field<string>("Summary"));                              // SUMMARY property
        sc.Description      = cal.CreateCalTextProp(row.Field<string>("Description"));                          // DESCRIPTION property
        sc.Start            = cal.CreateCalDateProp(row.Field<DateTime?>("Start"), row.Field<string>("StartTimeZoneId"), isAllDay);                 // DTSTART property
        sc.Duration         = cal.CreateDurationProp(row.Field<long?>("Duration"));                             // DURATION property
        sc.Class            = cal.CreateClassProp(row.Field<string>("Class"));                                  // CLASS property
        sc.Location         = cal.CreateCalTextProp(row.Field<string>("Location"));                             // LOCATION property
        sc.Priority         = cal.CreateIntegerProp(row.Field<byte?>("Priority"));                              // PRIORITY property
        sc.Sequence         = cal.CreateIntegerProp(row.Field<int?>("Sequence"));                               // SEQ property
        sc.Status           = cal.CreateStatusProp(row.Field<string>("Status"));                                // STATUS property
        sc.Organizer        = cal.CreateCalAddressProp(EmailToUri(row.Field<string>("OrganizerEmail")), row.Field<string>("OrganizerCommonName"));  // ORGANIZER property

        // RECURRENCE-ID property
        sc.RecurrenceId     = cal.CreateRecurrenceIdProp(
            row.Field<DateTime?>("RecurrenceIdDate")                                                            // RECURRENCE-ID value
            , row.Field<string>("RecurrenceIdTimeZoneId")                                                       // RECURRENCE-ID TZID param
            , isAllDay                                                                                          // RECURRENCE-ID DATE or DATE-TIME
            , row.Field<bool?>("RecurrenceIdThisAndFuture").GetValueOrDefault());                                             // RECURRENCE-ID RANGE param

        // CATEGORIES property list
        string categories = row.Field<string>("Categories") as string;
        if (!string.IsNullOrEmpty(categories))
        {
            string[] strCatProp = categories.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string categoryList in strCatProp)
            {
                ICategories catProp = sc.Categories.CreateProperty();
                catProp.Categories = categoryList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                sc.Categories.Add(catProp);
            }
        }

        // RRULE property
        string recurFrequency = row.Field<string>("RecurFrequency");
        if (!string.IsNullOrEmpty(recurFrequency))
        {
            sc.RecurrenceRule = cal.CreateProperty<IRecurrenceRule>();

            sc.RecurrenceRule.Frequency = ExtendibleEnum.FromString<FrequencyType>(recurFrequency);             // FREQ rule part
            sc.RecurrenceRule.Interval  = (uint?)row.Field<int?>("RecurInterval");                              // INTERVAL rule part
            sc.RecurrenceRule.Count     = (uint?)row.Field<int?>("RecurCount");                                 // COUNT rule part

            // WKST rule part
            string weekStart = row.Field<string>("RecurWeekStart");
            if (!string.IsNullOrEmpty(weekStart))
            {
                sc.RecurrenceRule.WeekStart = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), weekStart);
            }

            // UNTIL rule part
            DateTime? until = row.Field<DateTime?>("RecurUntil");
            if (until != null)
            {
                // UNTIL must be in UTC if DTSTART contains time zone or DTSTART is UTC.
                // UNTIL must be 'floating' if DTSTART is 'floating'.
                // UNTIL must be 'all day' if the DTSTART is 'all day'.
                // https://tools.ietf.org/html/rfc5545#section-3.3.10
                sc.RecurrenceRule.Until = new Date(
                    DateTime.SpecifyKind(until.Value,
                    sc.Start.Value.DateVal.Kind != DateTimeKind.Local /*floating*/ ? DateTimeKind.Utc : DateTimeKind.Local),
                    sc.Start.Value.Components);
            }

            // BYDAY rule part
            string byDay = row.Field<string>("RecurByDay");
            if (!string.IsNullOrEmpty(byDay))
            {
                sc.RecurrenceRule.ByDay = byDay.Split(',').Select(x => DayRule.Parse(x)).ToArray();
            }

            // BYMONTHDAY rule part
            string byMonthDay = row.Field<string>("RecurByMonthDay");
            if (!string.IsNullOrEmpty(byMonthDay))
            {
                sc.RecurrenceRule.ByMonthDay = byMonthDay.Split(',').Select(x => short.Parse(x)).ToArray();
            }

            // BYMONTH rule part
            string byMonth = row.Field<string>("RecurByMonth");
            if (!string.IsNullOrEmpty(byMonth))
            {
                sc.RecurrenceRule.ByMonth = byMonth.Split(',').Select(x => ushort.Parse(x)).ToArray();
            }

            // BYSETPOS  rule part
            string bySetPos = row.Field<string>("RecurBySetPos");
            if (!string.IsNullOrEmpty(bySetPos))
            {
                sc.RecurrenceRule.BySetPos = bySetPos.Split(',').Select(x => short.Parse(x)).ToArray();
            }      
        }

        if (sc is IEvent)
        {
            // Properties specific for events only
            IEvent vEvent = sc as IEvent;
            vEvent.End          = cal.CreateCalDateProp(row.Field<DateTime?>("End"), row.Field<string>("EndTimeZoneId"), isAllDay); // DTEND property
            vEvent.Transparency = cal.CreateTransparencyProp(row.Field<bool?>("EventTransparency"));                                // TRANSP property
        }
        else
        {
            // Properties specific for to-dos only
            IToDo vToDo = sc as IToDo;
            vToDo.Due           = cal.CreateCalDateProp(row.Field<DateTime?>("End"), row.Field<string>("EndTimeZoneId"), isAllDay); // DUE property
            vToDo.CompletedUtc  = cal.CreateDateProp(row.Field<DateTime?>("ToDoCompletedUtc"), DateTimeKind.Utc);                   // COMPLETED property
            vToDo.PercentComplete = cal.CreateIntegerProp(row.Field<byte?>("ToDoPercentComplete"));                                 // PERCENT-COMPLETE
        }

        // Get custom properties and custom parameters
        Guid eventComponentId = row.Field<Guid>("EventComponentId");
        IEnumerable<DataRow> rowsEventCustomProperties = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == eventComponentId);
        ReadCustomProperties(sc, rowsEventCustomProperties);
    }

    private static void ReadRecurrenceExceptions(IPropertyList<ICalDateList> recurrenceExceptions, IEnumerable<DataRow> rowsRecurrenceExceptions, ICalendar2 cal)
    {
        foreach (DataRow rowRecurrenceException in rowsRecurrenceExceptions)
        {
            // EXDATE property
            ICalDateList exdate = cal.CreateCalDateListProp(
                new DateTime[] { rowRecurrenceException.Field<DateTime>("ExceptionDate") }                          // EXDATE value
                , rowRecurrenceException.Field<string>("TimeZoneId")                                                // EXDATE TZID param
                , rowRecurrenceException.Field<bool?>("AllDay").GetValueOrDefault()                                 // EXDATE DATE or DATE-TIME
                );
            recurrenceExceptions.Add(exdate);
        }
    }

    private void ReadAlarms(IComponentList<IAlarm> alarms, IEnumerable<DataRow> rowsAlarms, ICalendar2 cal)
    {
        foreach (DataRow rowAlarm in rowsAlarms)
        {
            IAlarm alarm = alarms.CreateComponent();                                            // VALARM component

            alarm.Action        = cal.CreateActionProp(rowAlarm.Field<string>("Action"));       // Alarm ACTION property
            alarm.Summary       = cal.CreateCalTextProp(rowAlarm.Field<string>("Summary"));     // Alarm SUMMARY property
            alarm.Description   = cal.CreateCalTextProp(rowAlarm.Field<string>("Description")); // Alarm DESCRIPTION property
            alarm.Duration      = cal.CreateDurationProp(rowAlarm.Field<long?>("Duration"));    // Alarm DURATION property
            alarm.Repeat        = cal.CreateIntegerProp(rowAlarm.Field<int?>("Repeat"));        // Alarm REPEAT property

            // Alarm TRIGGER property
            alarm.Trigger = cal.CreateProperty<ITrigger>();

            DateTime? absolute = rowAlarm.Field<DateTime?>("TriggerAbsoluteDateTimeUtc");
            if (absolute != null)
            {
                alarm.Trigger.AbsoluteDateTimeUtc = DateTime.SpecifyKind(absolute.Value, DateTimeKind.Utc);
            }

            long? offset = rowAlarm.Field<long?>("TriggerRelativeOffset");
            if (offset != null)
            {
                alarm.Trigger.RelativeOffset = new TimeSpan(offset.Value);
            }

            // Alarm trigger RELATED param
            bool? related = rowAlarm.Field<bool?>("TriggerRelatedStart");
            if (related != null)
            {
                alarm.Trigger.Related = related.Value ? RelatedType.Start : RelatedType.End;
            }

            // Get custom properties and custom parameters
            Guid alarmId = rowAlarm.Field<Guid>("AlarmId");
            IEnumerable<DataRow> rowsEventCustomProperties = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == alarmId);
            ReadCustomProperties(alarm, rowsEventCustomProperties);

            alarms.Add(alarm);
        }
    }

    private void ReadAttendees(IPropertyList<IAttendee> attendees, IEnumerable<DataRow> rowsAttendees, ICalendar2 cal)
    {
        foreach (DataRow rowAttendee in rowsAttendees)
        {                
            IAttendee attendee = attendees.CreateProperty();                                                // ATTENDEE property

            attendee.Uri            = EmailToUri(rowAttendee.Field<string>("Email"));                       // Attendee value
            attendee.CommonName     = rowAttendee.Field<string>("CommonName");                              // Attendee CN parameter
            attendee.Dir            = rowAttendee.Field<string>("DirectoryEntryRef");                       // Attendee DIR parameter
            attendee.Language       = rowAttendee.Field<string>("Language");                                // Attendee LANGUAGE parameter
            attendee.UserType       = StringToEnum<CalendarUserType>(rowAttendee.Field<string>("UserType"));// Attendee CUTYPE parameter
            attendee.SentBy         = EmailToUri(rowAttendee.Field<string>("SentBy"));                      // Attendee SENT-BY parameter
            attendee.DelegatedFrom  = new[] { EmailToUri(rowAttendee.Field<string>("DelegatedFrom")) };     // Attendee DELEGATED-FROM parameter, here we assume only 1 delegator for the sake of simplicity
            attendee.DelegatedTo    = new[] { EmailToUri(rowAttendee.Field<string>("DelegatedTo")) };       // Attendee DELEGATED-TO parameter, here we assume only 1 delegatee for the sake of simplicity

            // Attendee RSVP parameter
            bool? rsvp = rowAttendee.Field<bool?>("Rsvp");
            if (rsvp != null)
            {
                attendee.Rsvp       = rsvp.Value ? RsvpType.True : RsvpType.False;
            }

            attendee.ParticipationRole   = StringToEnum<ParticipationRoleType>(rowAttendee.Field<string>("ParticipationRole"));     // Attendee ROLE parameter
            attendee.ParticipationStatus = StringToEnum<ParticipationStatusType>(rowAttendee.Field<string>("ParticipationStatus")); // Attendee PARTSTAT parameter

            AddParamValues(rowAttendee.Field<Guid>("AttendeeId"), attendee.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

            attendees.Add(attendee);
        }
    }

    private async Task ReadAttachmentsAsync(DavContext context, IPropertyList<IMedia> attachments, IEnumerable<DataRow> rowsAttachments, ICalendar2 cal)
    {
        // Find if any attachments content should be read from datatbase.
        bool loadContent = rowsAttachments.Any(x => (x.Field<int>("ContentExists") == 1));

        if (loadContent)
        {
            // Reading attachments content from database.

            // Set timeout to maximum value to be able to download iCalendar files with large file attachments.
            System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
            
            Guid eventComponentId = rowsAttachments.First().Field<Guid>("EventComponentId");
            string sql = "SELECT [AttachmentId], [MediaType], [ExternalUrl], [Content] FROM [cal_Attachment] WHERE [EventComponentId]=@EventComponentId";
            
            using (SqlDataReader reader = await context.ExecuteReaderAsync(CommandBehavior.SequentialAccess, sql, "@EventComponentId", eventComponentId))                
            {
                while(await reader.ReadAsync())
                {
                    IMedia attachment = attachments.CreateProperty();                   // ATTACH property
                    Guid attachmentId = await reader.GetFieldValueAsync<Guid>(reader.GetOrdinal("AttachmentId"));

                    // Attachment FMTTYPE parameter
                    int ordMediaType = reader.GetOrdinal("MediaType");
                    if (!await reader.IsDBNullAsync(ordMediaType))
                    {
                        attachment.MediaType = await reader.GetFieldValueAsync<string>(ordMediaType);
                    }

                    // Attachment value as URL
                    int ordExternalUrl = reader.GetOrdinal("ExternalUrl");
                    if (!await reader.IsDBNullAsync(ordExternalUrl))
                    {
                        attachment.Uri = await reader.GetFieldValueAsync<string>(ordExternalUrl);
                    }
                                 
                    // Attachment value as inline content
                    int ordContent = reader.GetOrdinal("Content");
                    if (!await reader.IsDBNullAsync(ordContent))
                    {
                        using (Stream stream = reader.GetStream(ordContent))
                        {
                            using(MemoryStream memory = new MemoryStream())
                            {
                                await stream.CopyToAsync(memory);
                                attachment.Base64Data = Convert.ToBase64String(memory.ToArray());
                            }
                        }
                    }

                    AddParamValues(attachmentId, attachment.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

                    attachments.Add(attachment);
                }
            }
        }
        else
        {
            // Attachments contain only URLs to external files.
            foreach (DataRow rowAttachment in rowsAttachments)
            {
                IMedia attachment = attachments.CreateProperty();                   // ATTACH property

                attachment.MediaType = rowAttachment.Field<string>("MediaType");    // Attachment FMTTYPE parameter
                attachment.Uri       = rowAttachment.Field<string>("ExternalUrl");  // Attachment value

                AddParamValues(rowAttachment.Field<Guid>("AttachmentId"), attachment.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

                attachments.Add(attachment);
            }
        }
    }

    private static void ReadCustomProperties(IComponent component, IEnumerable<DataRow> rowsCustomProperies)
    {
        foreach (DataRow rowCustomProperty in rowsCustomProperies)
        {
            string propertyName = rowCustomProperty.Field<string>("PropertyName");

            IRawProperty prop;
            if (!component.Properties.ContainsKey(propertyName))
            {
                prop = component.CreateRawProperty();
                component.AddProperty(propertyName, prop);
            }
            else
            {
                prop = component.Properties[propertyName].FirstOrDefault();
            }

            string paramName = rowCustomProperty.Field<string>("ParameterName");
            string value = rowCustomProperty.Field<string>("Value");
            if (paramName == null)
            {
                // If ParameterName is null the Value contains property value
                prop.RawValue = value;
            }
            else
            {
                AddParamValue(prop, paramName, value);
            }
        }
    }

    private void AddParamValues(Guid propertyId, IRawProperty prop)
    {
        IEnumerable<DataRow> rowsCustomParams = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == propertyId);
        foreach (DataRow rowCustomParam in rowsCustomParams)
        {
            string paramName = rowCustomParam.Field<string>("ParameterName");
            string paramValue = rowCustomParam.Field<string>("Value");
            AddParamValue(prop, paramName, paramValue);
        }
    }

    private static void AddParamValue(IRawProperty prop, string paramName, string paramValue)
    {
        // There could be parameters with identical name withing one property.

        // This call returns all values from all properties with specified name.
        IEnumerable<string> paramVals = prop.Parameters[paramName];

        // Add value.
        List<string> paramNewVals = paramVals.ToList();
        paramNewVals.Add(paramValue);

        // This call removes any parameters with identical names if any and 
        // replaces it with a single parameter with a lost of specified values.
        prop.Parameters[paramName] = paramNewVals;
    }

    private static string EmailToUri(string email)
    {
        if (email == null)
            return null;

        if (email.IndexOf('@') > 0)
            return string.Format("mailto:{0}", email);

        return email;
    }

    private static T StringToEnum<T>(string value) where T : ExtendibleEnum, new()
    {
        if (value == null)
            return null;

        T res;
        if (!ExtendibleEnum.TryFromString<T>(value, out res))
        {
            // If no matching value is found create new ExtendibleEnum or type T 
            // with specified string value and default numeric value (-1).
            res = new T();
            res.Name = value;
        }

        return res;
    }
}
]]></code>
      <code lang="VB"><![CDATA[' +--- Calendar file [UID1].ics ---------+
' |                                      |
' |  +-- Time zone component ---------+  | -- Time zones are are not stored in DB, they are generated automatically 
' |  | TZID: Zone X                   |  |    during serialization, based on TZIDs found in event or to-do.
' |  | ...                            |  |
' |  +--------------------------------+  |
' |                                      |
' |  +-- Time zone component ---------+  |
' |  | TZID: Zone Y                   |  | -- Time zone IDs could be either IANA (Olson) IDs or System (Windows) IDs.
' |  | ...                            |  |
' |  +--------------------------------+  |
' |  ...                                 |
' |                                      |
' |                                      |
' |  +-- Event component -------------+  | -- Event / do-do components are stored in [cal_EventComponent] table.
' |  | UID: [UID1]                    |  |    
' |  | RRULE: FREQ=DAILY              |  | 
' |  | SUMMARY: Event A               |  |
' |  | ...                            |  |
' |  +--------------------------------+  |
' |                                      |
' |  +-- Event component -------------+  | -- In case of recurring events/to-dos there could be more than one component
' |  | UID: [UID1]                    |  |    per file. All event/to-do components within a single calendar file share
' |  | RECURRENCE-ID: 20151028        |  |    the same UID but have different RECURRENCE-IDs. 
' |  | SUMMARY: Instance 5 of Event A |  |    
' |  | ...                            |  |    iOS / OS X UIDs are case sensitive (uppercase GUIDs).
' |  +--------------------------------+  |    Bynari WebDAV Collaborator for MS Outlook UIDs are over 100 chars in length.
' |  ...                                 |
' |                                      |
' |                                      |
' +--------------------------------------+
' 
' 
' 
'    +-- Event component -------------+
'    |                                |
'    | UID: [UID1]                    | 
'    | SUMMARY: Event A               |
'    | START: 20151016T080000         |
'    | RRULE: FREQ=DAILY              |
'    | ...                            |
'    |                                |
'    | EXDATE: 20151018T080000        | -- Recurrence exception dates are stored in [cal_RecurrenceException] table.
'    | EXDATE: 20151020T080000        |
'    | ...                            |
'    |                                |
'    | ATTENDEE: mail1@server.com     | -- Attendees are stored in [cal_Attendee] table.
'    | ATTENDEE: mail2@srvr.com       |
'    | ...                            |
'    |                                |
'    | ATTACH: /9j/4VGuf+Sw...        | -- Attachments are stored in [cal_Attachment] table.
'    | ATTACH: https:'serv/file.docx |
'    | ...                            |
'    |                                |
'    |  +-- Alarm Component -------+  | -- Alarms are stored in [cal_Alarm] table.
'    |  | ACTION: DISPLAY          |  |
'    |  | ...                      |  |
'    |  +--------------------------+  |
'    |                                |
'    |  +-- Alarm Component -------+  |
'    |  | ACTION: EMAIL            |  |
'    |  | ...                      |  |
'    |  +--------------------------+  |
'    |  ...                           |
'    |                                |
'    +--------------------------------+
Public Class CalendarFile
    Inherits DavHierarchyItem
    Implements ICalendarFileAsync

    Public Shared Extension As String = ".ics"

    Public Shared Async Function LoadByCalendarFolderIdAsync(context As DavContext, calendarFolderId As Guid, propsToLoad As PropsToLoad) As Task(Of IEnumerable(Of ICalendarFileAsync))
        ' propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CalDAV clients
        ' [Summary] is typically not required in GetChildren call, 
        ' they are extracted for demo purposes only, to be displayed in Ajax File Browser.
        ' propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.
        If propsToLoad <> PropsToLoad.Minimum Then Throw New NotImplementedException("LoadByCalendarFolderIdAsync is implemented only with PropsToLoad.Minimum.")
        Dim sql As String = "SELECT * FROM [cal_CalendarFile] 
                       WHERE [CalendarFolderId] = @CalendarFolderId
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

                      ;SELECT [UID], [Summary] FROM [cal_EventComponent] 
                       WHERE [UID] IN (SELECT [UID] FROM [cal_CalendarFile] 
                                       WHERE [CalendarFolderId] = @CalendarFolderId)"
        sql = String.Format(sql, GetScPropsToLoad(propsToLoad))
        Return Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@CalendarFolderId", calendarFolderId)
    End Function

    Public Shared Async Function LoadByUidsAsync(context As DavContext, uids As IEnumerable(Of String), propsToLoad As PropsToLoad) As Task(Of IEnumerable(Of ICalendarFileAsync))
        ' Get IN clause part with list of file UIDs for SELECT.
        Dim selectIn As String = String.Join(", ", uids.Select(Function(a) String.Format("'{0}'", a)).ToArray())
        Dim sql As String = "SELECT * FROM [cal_CalendarFile] 
                       WHERE [UID] IN ({1})
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)"
        If propsToLoad = PropsToLoad.All Then
            ' Here we do not select attachments content because it could be very large,
            ' we only set [ContentExists] flag marking that it should be loaded during IContent.ReadAsync call.
            sql += ";SELECT * FROM [cal_EventComponent]      WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_RecurrenceException] WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Alarm]               WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Attendee]            WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_CustomProperty]      WHERE [UID] IN ({1})
                     ;SELECT [AttachmentId], [EventComponentId], [UID], [MediaType], [ExternalUrl], 
                         (CASE WHEN [Content] IS NULL THEN 0 ELSE 1 END) AS [ContentExists] 
                               FROM [cal_Attachment]          WHERE [UID] IN ({1})"
        End If

        sql = String.Format(sql, GetScPropsToLoad(propsToLoad), selectIn)
        Return Await LoadAsync(context, sql, "@UserId", context.UserId)
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of ICalendarFileAsync))
        Dim items As IList(Of ICalendarFileAsync) = New List(Of ICalendarFileAsync)()
        Dim stopWatch As Stopwatch = Stopwatch.StartNew()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim calendarFiles As DataTable = New DataTable()
            calendarFiles.Load(reader)
            Dim eventComponents As DataTable = New DataTable()
            If Not reader.IsClosed Then eventComponents.Load(reader)
            Dim recurrenceExceptions As DataTable = New DataTable()
            If Not reader.IsClosed Then recurrenceExceptions.Load(reader)
            Dim alarms As DataTable = New DataTable()
            If Not reader.IsClosed Then alarms.Load(reader)
            Dim attendees As DataTable = New DataTable()
            If Not reader.IsClosed Then attendees.Load(reader)
            Dim customProperties As DataTable = New DataTable()
            If Not reader.IsClosed Then customProperties.Load(reader)
            Dim attachments As DataTable = New DataTable()
            If Not reader.IsClosed Then attachments.Load(reader)
            stopWatch.Stop()
            context.Engine.Logger.LogDebug(String.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds))
            For Each rowCalendarFile As DataRow In calendarFiles.Rows
                Dim rowsEventComponents As DataRow() = New DataRow(-1) {}
                Dim rowsRecurrenceExceptions As DataRow() = New DataRow(-1) {}
                Dim rowsAlarms As DataRow() = New DataRow(-1) {}
                Dim rowsAttendees As DataRow() = New DataRow(-1) {}
                Dim rowsCustomProperties As DataRow() = New DataRow(-1) {}
                Dim rowsAttachments As DataRow() = New DataRow(-1) {}
                Dim uid As String = rowCalendarFile.Field(Of String)("UID")
                Dim filter As String = String.Format("UID = '{0}'", uid)
                If eventComponents.Columns("UID") IsNot Nothing Then rowsEventComponents = eventComponents.Select(filter)
                If recurrenceExceptions.Columns("UID") IsNot Nothing Then rowsRecurrenceExceptions = recurrenceExceptions.Select(filter)
                If alarms.Columns("UID") IsNot Nothing Then rowsAlarms = alarms.Select(filter)
                If attendees.Columns("UID") IsNot Nothing Then rowsAttendees = attendees.Select(filter)
                If customProperties.Columns("UID") IsNot Nothing Then rowsCustomProperties = customProperties.Select(filter)
                If attachments.Columns("UID") IsNot Nothing Then rowsAttachments = attachments.Select(filter)
                items.Add(New CalendarFile(context, uid, rowCalendarFile, rowsEventComponents, rowsRecurrenceExceptions, rowsAlarms, rowsAttendees, rowsCustomProperties, rowsAttachments))
            Next
        End Using

        Return items
    End Function

    Private Shared Function GetScPropsToLoad(propsToLoad As PropsToLoad) As String
        Select Case propsToLoad
            Case PropsToLoad.None
                Return "[UID]"
            Case PropsToLoad.Minimum
                ' [Summary] is typically not required in GetChildren call, 
                ' they are extracted for demo purposes only, to be displayed in Ajax File Browser as a file display name.
                Return "[UID], [Summary]"
            Case PropsToLoad.All
                Return "*"
        End Select

        Throw New Exception("Should never come here.")
    End Function

    Public Shared Function CreateCalendarFile(context As DavContext, calendarFolderId As Guid) As CalendarFile
        Dim calendarFile As CalendarFile = New CalendarFile(context, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing)
        calendarFile.calendarFolderId = calendarFolderId
        Return calendarFile
    End Function

    Private ReadOnly uid As String = Nothing

    Private ReadOnly rowCalendarFile As DataRow = Nothing

    Private ReadOnly rowsEventComponents As DataRow() = Nothing

    Private ReadOnly rowsRecurrenceExceptions As DataRow() = Nothing

    Private ReadOnly rowsAlarms As DataRow() = Nothing

    Private ReadOnly rowsAttendees As DataRow() = Nothing

    Private ReadOnly rowsCustomProperties As DataRow() = Nothing

    Private ReadOnly rowsAttachments As DataRow() = Nothing

    Private ReadOnly Property isNew As Boolean
        Get
            Return calendarFolderId <> Guid.Empty
        End Get
    End Property

    Private paramIndex As Integer = 0

    Private calendarFolderId As Guid = Guid.Empty

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            ' Show all components summaries contained in this file.
            Return String.Join(", ", rowsEventComponents.Select(Function(x) String.Format("[{0}]", x.Field(Of String)("Summary"))).ToArray())
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Dim calendarFolderId As Guid = rowCalendarFile.Field(Of Guid)("CalendarFolderId")
            Dim uid As String = rowCalendarFile.Field(Of String)("UID")
            Return String.Format("{0}{1}/{2}{3}", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId, uid, Extension)
        End Get
    End Property

    Public ReadOnly Property Etag As String Implements IContentAsync.Etag
        Get
            Dim bETag As Byte() = rowCalendarFile.Field(Of Byte())("ETag")
            Return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString()
        End Get
    End Property

    Public Overrides ReadOnly Property Created As DateTime Implements IHierarchyItemBaseAsync.Created
        Get
            Return rowCalendarFile.Field(Of DateTime)("CreatedUtc")
        End Get
    End Property

    Public Overrides ReadOnly Property Modified As DateTime Implements IHierarchyItemBaseAsync.Modified
        Get
            Return rowCalendarFile.Field(Of DateTime)("ModifiedUtc")
        End Get
    End Property

    Public ReadOnly Property ContentLength As Long Implements IContentAsync.ContentLength
        Get
            Return -1
        End Get
    End Property

    Public ReadOnly Property ContentType As String Implements IContentAsync.ContentType
        Get
            Return "text/calendar"
        End Get
    End Property

    Private Sub New(context As DavContext, uid As String,
                   rowCalendarFile As DataRow, rowsEventComponents As DataRow(), rowsRecurrenceExceptions As DataRow(), rowsAlarms As DataRow(),
                   rowsAttendees As DataRow(), rowsCustomProperties As DataRow(), rowsAttachments As DataRow())
        MyBase.New(context)
        Me.uid = uid
        Me.rowCalendarFile = rowCalendarFile
        Me.rowsEventComponents = rowsEventComponents
        Me.rowsRecurrenceExceptions = rowsRecurrenceExceptions
        Me.rowsAlarms = rowsAlarms
        Me.rowsAttendees = rowsAttendees
        Me.rowsCustomProperties = rowsCustomProperties
        Me.rowsAttachments = rowsAttachments
    End Sub

    Public Async Function WriteAsync(stream As Stream, contentType As String, startIndex As Long, totalFileSize As Long) As Task(Of Boolean) Implements IContentAsync.WriteAsync
        'Set timeout to maximum value to be able to upload iCalendar files with large file attachments.
        System.Web.HttpContext.Current.Server.ScriptTimeout = Integer.MaxValue
        Dim iCalendar As String
        Using reader As StreamReader = New StreamReader(stream)
            iCalendar = Await reader.ReadToEndAsync()
        End Using

        ' Typically the stream contains a single iCalendar that contains one or more event or to-do components.
        Dim calendars As IEnumerable(Of IComponent) = New vFormatter().Deserialize(iCalendar)
        Dim calendar As ICalendar2 = TryCast(calendars.First(), ICalendar2)
        Dim components As IEnumerable(Of IEventBase) = calendar.Events.Cast(Of IEventBase)()
        If Not components.Any() Then
            components = calendar.ToDos.Cast(Of IEventBase)()
        End If

        If components Is Nothing Then Throw New DavException("Event or to-do was expected in the input stream, no events or to-dos were found.", DavStatus.UNSUPPORTED_MEDIA_TYPE)
        ' All components inside calendar file has the same UID which is equal to file name.
        Dim uid As String = components.First().Uid.Text
        ' Save data to [cal_CalendarFile] table.
        Await WriteCalendarFileAsync(Context, uid, calendarFolderId, isNew)
        For Each component As IEventBase In components
            Dim eventComponentId As Guid = Guid.NewGuid()
            ' Save data to [cal_EventComponent] table.
            Await WriteEventComponentAsync(Context, component, eventComponentId, uid)
            ' Save recurrence days exceptions for recurring events and to-dos. 
            Await WriteRecurrenceExceptionsAsync(Context, component.ExceptionDateTimes, eventComponentId, uid)
            ' Save alarms.
            Await WriteAlarmsAsync(Context, component.Alarms, eventComponentId, uid)
            ' Save attendees.
            Await WriteAttendeesAsync(Context, component.Attendees, eventComponentId, uid)
            ' Save attachments.
            Await WriteAttachmentsAsync(Context, component.Attachments, eventComponentId, uid)
        Next

        ' Notify attendees that event is created or modified.
        calendar.Method = calendar.CreateMethodProp(MethodType.Request)
        Await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, calendar)
        Return True
    End Function

    Private Shared Async Function WriteCalendarFileAsync(context As DavContext, uid As String, calendarFolderId As Guid, isNew As Boolean) As Task
        Dim sql As String
        If isNew Then
            sql = "IF EXISTS (SELECT 1 FROM [cal_Access] WHERE [CalendarFolderId]=@CalendarFolderId AND [UserId]=@UserId AND [Write]=1)
                INSERT INTO [cal_CalendarFile] (
                      [UID]
                    , [CalendarFolderId]
                ) VALUES (
                      @UID
                    , @CalendarFolderId
                )"
        Else
            ' We can only update record in [cal_CalendarFile] table.
            ' There is no way to update [cal_EventComponent], [cal_RecurrenceException], [cal_Alarm], [cal_Attendee], 
            ' [cal_Attachment] and [cal_CustomProperty] for existing event, we must delete all records for this UID and recreate.
            ' [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql = "IF EXISTS (SELECT 1 FROM [cal_CalendarFile]
                    WHERE UID = @UID
                    AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1))
                BEGIN
                    UPDATE [cal_CalendarFile] SET 
                        [ModifiedUtc] = @ModifiedUtc
                    WHERE [UID] = @UID

                    ; DELETE FROM [cal_EventComponent]      WHERE [UID] = @UID
                    ; DELETE FROM [cal_RecurrenceException] WHERE [UID] = @UID
                    ; DELETE FROM [cal_Alarm]               WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attendee]            WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attachment]          WHERE [UID] = @UID
                    ; DELETE FROM [cal_CustomProperty]      WHERE [UID] = @UID
                END"
        End If

        If Await context.ExecuteNonQueryAsync(sql,
                                             "@UID", uid,
                                             "UserId", context.UserId,
                                             "@CalendarFolderId", calendarFolderId,
                                             "@ModifiedUtc", DateTime.UtcNow) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Private Async Function WriteEventComponentAsync(context As DavContext, sc As IEventBase, eventComponentId As Guid, uid As String) As Task
        Dim sql As String = "INSERT INTO [cal_EventComponent] (
                      [EventComponentId]
                    , [UID]
                    , [ComponentType]
                    , [DateTimeStampUtc]
                    , [CreatedUtc]
                    , [LastModifiedUtc]
                    , [Summary]
                    , [Description]
                    , [OrganizerEmail]
                    , [OrganizerCommonName]
                    , [Start]
                    , [StartTimeZoneId]
                    , [End]
                    , [EndTimeZoneId]
                    , [Duration]
                    , [AllDay]
                    , [Class]
                    , [Location]
                    , [Priority]
                    , [Sequence]
                    , [Status]
                    , [Categories]
                    , [RecurFrequency]
                    , [RecurInterval]
                    , [RecurUntil]
                    , [RecurCount]
                    , [RecurWeekStart]
                    , [RecurByDay]
                    , [RecurByMonthDay]
                    , [RecurByMonth]
                    , [RecurBySetPos]
                    , [RecurrenceIdDate]
                    , [RecurrenceIdTimeZoneId]
                    , [RecurrenceIdThisAndFuture]
                    , [EventTransparency]
                    , [ToDoCompletedUtc]
                    , [ToDoPercentComplete]
                ) VALUES (
                      @EventComponentId
                    , @UID
                    , @ComponentType
                    , @DateTimeStampUtc 
                    , @CreatedUtc
                    , @LastModifiedUtc
                    , @Summary
                    , @Description
                    , @OrganizerEmail
                    , @OrganizerCommonName
                    , @Start, @StartTimeZoneId
                    , @End, @EndTimeZoneId
                    , @Duration
                    , @AllDay
                    , @Class
                    , @Location
                    , @Priority
                    , @Sequence
                    , @Status
                    , @Categories
                    , @RecurFrequency
                    , @RecurInterval
                    , @RecurUntil
                    , @RecurCount
                    , @RecurWeekStart
                    , @RecurByDay
                    , @RecurByMonthDay
                    , @RecurByMonth
                    , @RecurBySetPos
                    , @RecurrenceIdDate
                    , @RecurrenceIdTimeZoneId
                    , @RecurrenceIdThisAndFuture
                    , @EventTransparency
                    , @ToDoCompletedUtc
                    , @ToDoPercentComplete
                )"
        Dim isEvent As Boolean = TypeOf sc Is IEvent
        ' Get END in case of event or DUE in case of to-do component. 
        Dim endProp As ICalDate = If(isEvent, TryCast(sc, IEvent).End, TryCast(sc, IToDo).Due)
        Await context.ExecuteNonQueryAsync(sql,
                                          "@EventComponentId", eventComponentId,
                                          "@UID", uid,                                                                   ' UID value
                                          "@ComponentType", isEvent,
                                          "@DateTimeStampUtc", sc.DateTimeStampUtc?.Value?.DateVal,                                   ' DTSTAMP value
                                          "@CreatedUtc", sc.CreatedUtc?.Value?.DateVal,                                         ' CREATED value
                                          "@LastModifiedUtc", sc.LastModifiedUtc?.Value?.DateVal,                                    ' LAST-MODIFIED value
                                          "@Summary", sc.Summary?.Text,                                                      ' SUMMARY value
                                          "@Description", sc.Description?.Text,                                                  ' DESCRIPTION value
                                          "@OrganizerEmail", sc.Organizer?.Uri?.Replace("mailto:", ""),                             ' ORGANIZER value
                                          "@OrganizerCommonName", sc.Organizer?.CommonName,                                              ' ORGANIZER CN param
                                          "@Start", sc.Start?.Value?.DateVal,                                              ' DTSTART value
                                          "@StartTimeZoneId", If(sc.Start?.Value?.DateVal.Kind = DateTimeKind.Utc, TimeZoneInfo.Utc.Id, sc.Start?.TimeZoneId),  ' DTSTART TZID param
                                          "@End", endProp?.Value?.DateVal,                                               ' DTEND or DUE value
                                          "@EndTimeZoneId", If(endProp?.Value?.DateVal.Kind = DateTimeKind.Utc, TimeZoneInfo.Utc.Id, endProp?.TimeZoneId),    ' DTEND or DUE TZID param
                                          "@Duration", CType(sc.Duration?.Value, TimeSpan?)?.Ticks,                                             ' DURATION value
                                          "@AllDay", Not sc.Start?.Value?.Components.HasFlag(DateComponents.Time), ' Check if start contains the time part to determine if this is a all-day event/to-do.
                                          "@Class", sc.Class?.Value.Name,                                                  ' CLASS value
                                          "@Location", sc.Location?.Text,                                                     ' LOCATION value
                                          "@Priority", sc.Priority?.Value,                                                    ' PRIORITY value
                                          "@Sequence", sc.Sequence?.Value,                                                    ' SEQUENCE value
                                          "@Status", sc.Status?.Value.Name,                                                 ' STATUS value
                                          "@Categories", ListToString(Of String)(sc.Categories.Select(Function(x) ListToString(Of String)(x.Categories, ",")), ";"), ' CATEGORIES value
                                          "@RecurFrequency", sc.RecurrenceRule?.Frequency?.ToString(),                              ' RRULE FREQ value part
                                          "@RecurInterval", CType(sc.RecurrenceRule?.Interval, Integer?),                                     ' RRULE INTERVAL value part
                                          "@RecurUntil", sc.RecurrenceRule?.Until?.DateVal,                                     ' RRULE UNTIL value part
                                          "@RecurCount", CType(sc.RecurrenceRule?.Count, Integer?),                                        ' RRULE COUNT value part
                                          "@RecurWeekStart", CType(sc.RecurrenceRule?.WeekStart, DayOfWeek?)?.ToString(),                              ' RRULE WKST value part
                                          "@RecurByDay", ListToString(Of DayRule)(sc.RecurrenceRule?.ByDay),                       ' RRULE BYDAY value part
                                          "@RecurByMonthDay", ListToString(Of Short)(sc.RecurrenceRule?.ByMonthDay),                    ' RRULE BYMONTHDAY value part
                                          "@RecurByMonth", ListToString(Of UShort)(sc.RecurrenceRule?.ByMonth),                      ' RRULE BYMONTH value part
                                          "@RecurBySetPos", ListToString(Of Short)(sc.RecurrenceRule?.BySetPos),                      ' RRULE BYSETPOS value part
                                          "@RecurrenceIdDate", sc.RecurrenceId?.Value.DateVal,                                        ' RECURRENCE-ID value
                                          "@RecurrenceIdTimeZoneId", sc.RecurrenceId?.TimeZoneId,                                           ' RECURRENCE-ID TZID param
                                          "@RecurrenceIdThisAndFuture", sc.RecurrenceId?.IsThisAndFuture,                                    ' RECURRENCE-ID RANGE param
                                          "@EventTransparency", TryCast(sc, IEvent)?.Transparency?.IsTransparent,                           ' VEVENT TRANSP value
                                          "@ToDoCompletedUtc", TryCast(sc, IToDo)?.CompletedUtc?.Value?.DateVal,                           ' VTODO COMPLETED value
                                          "@ToDoPercentComplete", TryCast(sc, IToDo)?.PercentComplete?.Value                                 ' VTODO PERCENT-COMPLETE value
                                          )
        ' Save custom properties and parameters of this component to [cal_CustomProperty] table.
        Dim customPropsSqlInsert As String
        Dim customPropsParamsInsert As List(Of Object)
        If PrepareSqlCustomPropertiesOfComponentAsync(sc, eventComponentId, uid, customPropsSqlInsert, customPropsParamsInsert) Then
            Await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray())
        End If
    End Function

    Private Shared Function ListToString(Of T)(arr As IEnumerable(Of T), Optional separator As String = ",") As String
        If(arr Is Nothing) OrElse Not arr.Any() Then Return Nothing
        Return String.Join(Of T)(separator, arr)
    End Function

    Private Shared Async Function WriteRecurrenceExceptionsAsync(context As DavContext, recurrenceExceptions As IPropertyList(Of ICalDateList), eventComponentId As Guid, uid As String) As Task
        ' Typically CalDAV clients pass a single date value per EXDATE property.
        Dim sql As String = "INSERT INTO [cal_RecurrenceException] (
                  [EventComponentId]
                , [UID]
                , [ExceptionDate]
                , [TimeZoneId]
                , [AllDay]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@EventComponentId", eventComponentId,
                                                                             "@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each dateListProp As ICalDateList In recurrenceExceptions
            For Each [date] As [Date] In dateListProp.Dates
                If [date] Is Nothing Then Continue For
                valuesSql.Add(String.Format("(
                  @EventComponentId
                , @UID
                , @ExceptionDate{0}
                , @TimeZoneId{0}
                , @AllDay{0}
                )", i))
                parameters.AddRange(New Object() {"@ExceptionDate" & i, [date].DateVal,                                                                         ' EXDATE value
                                                 "@TimeZoneId" & i, If([date].DateVal.Kind = DateTimeKind.Utc, TimeZoneInfo.Utc.Id, dateListProp.TimeZoneId),' EXDATE TZID param
                                                 "@AllDay" & i, Not [date].Components.HasFlag(DateComponents.Time)                                        ' EXDATE DATE or DATE-TIME
                                                 })
            Next

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteAlarmsAsync(context As DavContext, alarms As IComponentList(Of IAlarm), eventComponentId As Guid, uid As String) As Task
        Dim sql As String = "INSERT INTO [cal_Alarm] (
                  [AlarmId]
                , [EventComponentId]
                , [UID]
                , [Action]
                , [TriggerAbsoluteDateTimeUtc]
                , [TriggerRelativeOffset]
                , [TriggerRelatedStart]
                , [Summary]
                , [Description]
                , [Duration]
                , [Repeat]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@EventComponentId", eventComponentId,
                                                                             "@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each alarm As IAlarm In alarms
            Dim alarmId As Guid = Guid.NewGuid()
            valuesSql.Add(String.Format("(
                  @AlarmId{0}
                , @EventComponentId
                , @UID
                , @Action{0}
                , @TriggerAbsoluteDateTimeUtc{0}
                , @TriggerRelativeOffset{0}
                , @TriggerRelatedStart{0}
                , @Summary{0}
                , @Description{0}
                , @Duration{0}
                , @Repeat{0}
                )", i))
            parameters.AddRange(New Object() {"@AlarmId" & i, alarmId,
                                             "@Action" & i, alarm.Action.Action.Name,                                                        ' Alarm ACTION property
                                             "@TriggerAbsoluteDateTimeUtc" & i, alarm.Trigger?.AbsoluteDateTimeUtc,                                              ' Alarm TRIGGER property
                                             "@TriggerRelativeOffset" & i, CType(alarm.Trigger?.RelativeOffset, TimeSpan?)?.Ticks,                                            ' Alarm TRIGGER property
                                             "@TriggerRelatedStart" & i, If(alarm.Trigger Is Nothing, CType(Nothing, Boolean?), alarm.Trigger.Related = RelatedType.Start),  ' Alarm trigger RELATED param
                                             "@Summary" & i, alarm.Summary?.Text,                                                             ' Alarm SUMMARY property
                                             "@Description" & i, alarm.Description?.Text,                                                         ' Alarm DESCRIPTION property
                                             "@Duration" & i, CType(alarm.Duration?.Value, TimeSpan?)?.Ticks,                                                    ' Alarm DURATION property
                                             "@Repeat" & i, alarm.Repeat?.Value                                                             ' Alarm REPEAT property
                                             })
            ' Create SQL to save custom properties of this component of this component to [cal_CustomProperty] table.
            Dim customPropsSqlInsert As String
            Dim customPropsParamsInsert As List(Of Object)
            If PrepareSqlCustomPropertiesOfComponentAsync(alarm, alarmId, uid, customPropsSqlInsert, customPropsParamsInsert) Then
                sql += "; " & customPropsSqlInsert
                parameters.AddRange(customPropsParamsInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteAttendeesAsync(context As DavContext, attendees As IPropertyList(Of IAttendee), eventComponentId As Guid, uid As String) As Task
        Dim sql As String = "INSERT INTO [cal_Attendee] (
                  [AttendeeId]
                , [EventComponentId]
                , [UID]
                , [Email]
                , [CommonName]
                , [DirectoryEntryRef]
                , [Language]
                , [UserType]
                , [SentBy]
                , [DelegatedFrom]
                , [DelegatedTo]
                , [Rsvp]
                , [ParticipationRole]
                , [ParticipationStatus]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@EventComponentId", eventComponentId,
                                                                             "@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each attendee As IAttendee In attendees
            valuesSql.Add(String.Format("(
                  @AttendeeId{0}
                , @EventComponentId
                , @UID
                , @Email{0}
                , @CommonName{0}
                , @DirectoryEntryRef{0}
                , @Language{0}
                , @UserType{0}
                , @SentBy{0}
                , @DelegatedFrom{0}
                , @DelegatedTo{0}
                , @Rsvp{0}
                , @ParticipationRole{0}
                , @ParticipationStatus{0}
            )", i))
            Dim attendeeId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@AttendeeId" & i, attendeeId,
                                             "@Email" & i, attendee.Uri?.Replace("mailto:", ""),    ' Attendee value
                                             "@CommonName" & i, attendee.CommonName,                     ' Attendee CN parameter
                                             "@DirectoryEntryRef" & i, attendee.Dir,                            ' Attendee DIR parameter
                                             "@Language" & i, attendee.Language,                       ' Attendee LANGUAGE parameter
                                             "@UserType" & i, attendee.UserType?.Name,                 ' Attendee CUTYPE parameter
                                             "@SentBy" & i, attendee.SentBy,                         ' Attendee SENT-BY parameter
                                             "@DelegatedFrom" & i, attendee.DelegatedFrom.FirstOrDefault(), ' Attendee DELEGATED-FROM parameter, here we assume only 1 delegator for the sake of simplicity
                                             "@DelegatedTo" & i, attendee.DelegatedTo.FirstOrDefault(),   ' Attendee DELEGATED-TO parameter, here we assume only 1 delegatee for the sake of simplicity
                                             "@Rsvp" & i, attendee.Rsvp = RsvpType.True,          ' Attendee RSVP parameter
                                             "@ParticipationRole" & i, attendee.ParticipationRole?.Name,        ' Attendee ROLE parameter
                                             "@ParticipationStatus" & i, attendee.ParticipationStatus?.Name      ' Attendee PARTSTAT parameter
                                             })
            ' Prepare SQL to save custom property parameters to [cal_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("ATTENDEE", attendee.RawProperty, attendeeId, uid, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteAttachmentsAsync(context As DavContext, attachments As IPropertyList(Of IMedia), eventComponentId As Guid, uid As String) As Task
        ' It is recommended to keep attchment size below 256Kb. In case files over 1Mb should 
        ' be stored, use SQL FILESTREAM, FileTable or store content in file system.
        Dim sqlAttachment As String = "INSERT INTO [cal_Attachment] (
                  [AttachmentId]
                , [EventComponentId]
                , [UID]
                , [MediaType]
                , [ExternalUrl]
                , [Content]
            ) VALUES (
                  @AttachmentId
                , @EventComponentId
                , @UID
                , @MediaType
                , @ExternalUrl
                , @Content
            )"
        Dim customPropertiesSql As String = ""
        Dim customPropertiesParameters As List(Of Object) = New List(Of Object)()
        For Each attachment As IMedia In attachments
            ' To insert NULL to VARBINARY column SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            Dim contentParam As SqlParameter = New SqlParameter("@Content", SqlDbType.VarBinary, -1)
            contentParam.Value = DBNull.Value
            If Not attachment.IsExternal Then
                Dim content As Byte() = Convert.FromBase64String(attachment.Base64Data)
                contentParam.Size = content.Length
                contentParam.Value = content
            End If

            Dim attachmentId As Guid = Guid.NewGuid()
            Await context.ExecuteNonQueryAsync(sqlAttachment,
                                              "@AttachmentId", attachmentId,
                                              "@EventComponentId", eventComponentId,
                                              "@UID", uid,
                                              "@MediaType", attachment.MediaType,
                                              "@ExternalUrl", If(attachment.IsExternal, attachment.Uri, Nothing), contentParam
                                              )
            ' Prepare SQL to save custom property parameters to [].
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("ATTACH", attachment.RawProperty, attachmentId, uid, customPropSqlInsert, customPropParametersInsert) Then
                customPropertiesSql += "; " & customPropSqlInsert
                customPropertiesParameters.AddRange(customPropParametersInsert)
            End If
        Next

        If Not String.IsNullOrEmpty(customPropertiesSql) Then
            Await context.ExecuteNonQueryAsync(customPropertiesSql, customPropertiesParameters.ToArray())
        End If
    End Function

    Private Function PrepareSqlParamsWriteCustomProperty(propName As String, prop As IRawProperty, parentId As Guid, uid As String, ByRef sql As String, ByRef parameters As List(Of Object)) As Boolean
        sql = "INSERT INTO [cal_CustomProperty] (
                  [ParentId]
                , [UID]
                , [PropertyName]
                , [ParameterName]
                , [Value]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        parameters = New List(Of Object)()
        Dim origParamsCount As Integer = parameters.Count()
        Dim isCustomProp As Boolean = propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase)
        Dim paramName As String = Nothing
        ' Save custom prop value.
        If isCustomProp Then
            Dim val As String = prop.RawValue
            valuesSql.Add(String.Format("(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex))
            parameters.AddRange(New Object() {"@ParentId" & paramIndex, parentId,
                                             "@UID" & paramIndex, uid,       ' added for performance optimization purposes
                                             "@PropertyName" & paramIndex, propName,
                                             "@ParameterName" & paramIndex, paramName, ' null is inserted into the ParameterName field to mark prop value
                                             "@Value" & paramIndex, val
                                             })
            paramIndex += 1
        End If

        ' Save parameters and their values.
        For Each param As Parameter In prop.Parameters
            paramName = param.Name
            ' For standard properties we save only custom params (that start with 'X-'). All standard patrams go to their fields in DB.
            ' For custom properies we save all params.
            If Not isCustomProp AndAlso Not paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase) Then Continue For
            For Each value As String In param.Values
                Dim val As String = value
                valuesSql.Add(String.Format("(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex))
                parameters.AddRange(New Object() {"@ParentId" & paramIndex, parentId,
                                                 "@UID" & paramIndex, uid,       ' added for performance optimization purposes
                                                 "@PropertyName" & paramIndex, propName,
                                                 "@ParameterName" & paramIndex, paramName,
                                                 "@Value" & paramIndex, val
                                                 })
                paramIndex += 1
            Next
        Next

        If origParamsCount < parameters.Count() Then
            sql = String.Format(sql, String.Join(", ", valuesSql.ToArray()))
            Return True
        End If

        Return False
    End Function

    Private Function PrepareSqlCustomPropertiesOfComponentAsync(component As IComponent, parentId As Guid, uid As String, ByRef sql As String, ByRef parameters As List(Of Object)) As Boolean
        sql = ""
        parameters = New List(Of Object)()
        ' We save only single custom props here, multiple props are saved in other methods.
        Dim multiProps As String() = New String() {"ATTACH", "ATTENDEE", "EXDATE"}
        ' Properties in IComponent.Properties are grouped by name.
        For Each pair As KeyValuePair(Of String, IList(Of IRawProperty)) In component.Properties
            If multiProps.Contains(pair.Key.ToUpper()) OrElse (pair.Value.Count <> 1) Then Continue For
            Dim sqlInsert As String
            Dim parametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, sqlInsert, parametersInsert) Then
                sql += "; " & sqlInsert
                parameters.AddRange(parametersInsert)
            End If
        Next

        Return Not String.IsNullOrEmpty(sql)
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        Dim cal As ICalendar2 = Await GetCalendarAsync()
        Dim sql As String = "DELETE FROM [cal_CalendarFile] 
                       WHERE UID=@UID
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId AND [Write]=1)"
        If Await Context.ExecuteNonQueryAsync(sql, 
                                             "@UID", uid,
                                             "@UserId", Context.UserId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If

        ' Notify attendees that event is canceled if deletion is successful.
        cal.Method = cal.CreateMethodProp(MethodType.Cancel)
        Await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, cal)
    End Function

    Public Async Function ReadAsync(output As Stream, startIndex As Long, count As Long) As Task Implements IContentAsync.ReadAsync
        Dim cal As ICalendar2 = Await GetCalendarAsync()
        Call New vFormatter().Serialize(output, cal)
    End Function

    Private Async Function GetCalendarAsync() As Task(Of ICalendar2)
        Dim cal As ICalendar2 = CalendarFactory.CreateCalendar2()
        cal.ProductId = cal.CreateTextProp("-//IT Hit//Collab Lib//EN")
        ' Recurrent event or to-do can contain more than one VEVENT/VTODO component in one file.
        For Each rowEventComponent As DataRow In rowsEventComponents
            ' add either event or to-do to the calendar
            Dim isEvent As Boolean = rowEventComponent.Field(Of Boolean)("ComponentType")
            Dim sc As IEventBase
            If isEvent Then
                sc = cal.Events.CreateComponent()
                cal.Events.Add(TryCast(sc, IEvent))
            Else
                sc = cal.ToDos.CreateComponent()
                cal.ToDos.Add(TryCast(sc, IToDo))
            End If

            ' Read component properties from previously loaded [cal_EventComponent] rows.
            ReadEventComponent(sc, rowEventComponent, cal)
            Dim eventComponentId As Guid = rowEventComponent.Field(Of Guid)("EventComponentId")
            ' Get [cal_RecurrenceException] rows that belong to this event component only and read recurrence exceptions dates.
            Dim rowsThisScRecurrenceExceptions As IEnumerable(Of DataRow) = rowsRecurrenceExceptions.Where(Function(x) x.Field(Of Guid)("EventComponentId") = eventComponentId)
            ReadRecurrenceExceptions(sc.ExceptionDateTimes, rowsThisScRecurrenceExceptions, cal)
            ' Get [cal_Alarm] rows that belong to this event component only and read alarms.
            Dim rowsThisScAlarms As IEnumerable(Of DataRow) = rowsAlarms.Where(Function(x) x.Field(Of Guid)("EventComponentId") = eventComponentId)
            ReadAlarms(sc.Alarms, rowsThisScAlarms, cal)
            ' Get [cal_Attendee] rows that belong to this event component only and read attendees.
            Dim rowsThisScAttendees As IEnumerable(Of DataRow) = rowsAttendees.Where(Function(x) x.Field(Of Guid)("EventComponentId") = eventComponentId)
            ReadAttendees(sc.Attendees, rowsThisScAttendees, cal)
            ' Get [cal_Attachment] rows that belong to this event component only.
            ' Read attachments, load [cal_Attachment].[Content] if required.
            Dim rowsThisScAttachments As IEnumerable(Of DataRow) = rowsAttachments.Where(Function(x) x.Field(Of Guid)("EventComponentId") = eventComponentId)
            Await ReadAttachmentsAsync(Context, sc.Attachments, rowsThisScAttachments, cal)
        Next

        ' Generate VTIMEZONE components based on TZID parameters.
        cal.AutoGenerateTimeZones = True
        Return cal
    End Function

    Private Sub ReadEventComponent(sc As IEventBase, row As DataRow, cal As ICalendar2)
        Dim isAllDay As Boolean = row.Field(Of Boolean?)("AllDay").GetValueOrDefault()
        sc.Uid = cal.CreateTextProp(row.Field(Of String)("UID"))
        sc.DateTimeStampUtc = cal.CreateDateProp(row.Field(Of DateTime?)("DateTimeStampUtc"), DateTimeKind.Utc)
        sc.CreatedUtc = cal.CreateDateProp(row.Field(Of DateTime?)("CreatedUtc"), DateTimeKind.Utc)
        sc.LastModifiedUtc = cal.CreateDateProp(row.Field(Of DateTime?)("LastModifiedUtc"), DateTimeKind.Utc)
        sc.Summary = cal.CreateCalTextProp(row.Field(Of String)("Summary"))
        sc.Description = cal.CreateCalTextProp(row.Field(Of String)("Description"))
        sc.Start = cal.CreateCalDateProp(row.Field(Of DateTime?)("Start"), row.Field(Of String)("StartTimeZoneId"), isAllDay)
        sc.Duration = cal.CreateDurationProp(row.Field(Of Long?)("Duration"))
        sc.Class = cal.CreateClassProp(row.Field(Of String)("Class"))
        sc.Location = cal.CreateCalTextProp(row.Field(Of String)("Location"))
        sc.Priority = cal.CreateIntegerProp(row.Field(Of Byte?)("Priority"))
        sc.Sequence = cal.CreateIntegerProp(row.Field(Of Integer?)("Sequence"))
        sc.Status = cal.CreateStatusProp(row.Field(Of String)("Status"))
        sc.Organizer = cal.CreateCalAddressProp(EmailToUri(row.Field(Of String)("OrganizerEmail")), row.Field(Of String)("OrganizerCommonName"))
        ' RECURRENCE-ID property
        sc.RecurrenceId = cal.CreateRecurrenceIdProp(row.Field(Of DateTime?)("RecurrenceIdDate"),                                                            ' RECURRENCE-ID value
                                                    row.Field(Of String)("RecurrenceIdTimeZoneId"),                                                       ' RECURRENCE-ID TZID param
                                                    isAllDay,                                                                                          ' RECURRENCE-ID DATE or DATE-TIME
                                                    row.Field(Of Boolean?)("RecurrenceIdThisAndFuture").GetValueOrDefault())
        ' CATEGORIES property list
        Dim categories As String = TryCast(row.Field(Of String)("Categories"), String)
        If Not String.IsNullOrEmpty(categories) Then
            Dim strCatProp As String() = categories.Split({";"c}, StringSplitOptions.RemoveEmptyEntries)
            For Each categoryList As String In strCatProp
                Dim catProp As ICategories = sc.Categories.CreateProperty()
                catProp.Categories = categoryList.Split({","c}, StringSplitOptions.RemoveEmptyEntries)
                sc.Categories.Add(catProp)
            Next
        End If

        ' RRULE property
        Dim recurFrequency As String = row.Field(Of String)("RecurFrequency")
        If Not String.IsNullOrEmpty(recurFrequency) Then
            sc.RecurrenceRule = cal.CreateProperty(Of IRecurrenceRule)()
            sc.RecurrenceRule.Frequency = ExtendibleEnum.FromString(Of FrequencyType)(recurFrequency)
            sc.RecurrenceRule.Interval = CType(row.Field(Of Integer?)("RecurInterval"), UInteger?)
            sc.RecurrenceRule.Count = CType(row.Field(Of Integer?)("RecurCount"), UInteger?)
            ' WKST rule part
            Dim weekStart As String = row.Field(Of String)("RecurWeekStart")
            If Not String.IsNullOrEmpty(weekStart) Then
                sc.RecurrenceRule.WeekStart = CType([Enum].Parse(GetType(DayOfWeek), weekStart), DayOfWeek)
            End If

            ' UNTIL rule part
            Dim until As DateTime? = row.Field(Of DateTime?)("RecurUntil")
            If until IsNot Nothing Then
                ' UNTIL must be in UTC if DTSTART contains time zone or DTSTART is UTC.
                ' UNTIL must be 'floating' if DTSTART is 'floating'.
                ' UNTIL must be 'all day' if the DTSTART is 'all day'.
                ' https:'tools.ietf.org/html/rfc5545#section-3.3.10
                sc.RecurrenceRule.Until = New [Date](DateTime.SpecifyKind(until.Value,
                                                                         If(sc.Start.Value.DateVal.Kind <> DateTimeKind.Local, DateTimeKind.Utc, DateTimeKind.Local)),
                                                    sc.Start.Value.Components)
            End If

            ' BYDAY rule part
            Dim byDay As String = row.Field(Of String)("RecurByDay")
            If Not String.IsNullOrEmpty(byDay) Then
                sc.RecurrenceRule.ByDay = byDay.Split(","c).Select(Function(x) DayRule.Parse(x)).ToArray()
            End If

            ' BYMONTHDAY rule part
            Dim byMonthDay As String = row.Field(Of String)("RecurByMonthDay")
            If Not String.IsNullOrEmpty(byMonthDay) Then
                sc.RecurrenceRule.ByMonthDay = byMonthDay.Split(","c).Select(Function(x) Short.Parse(x)).ToArray()
            End If

            ' BYMONTH rule part
            Dim byMonth As String = row.Field(Of String)("RecurByMonth")
            If Not String.IsNullOrEmpty(byMonth) Then
                sc.RecurrenceRule.ByMonth = byMonth.Split(","c).Select(Function(x) UShort.Parse(x)).ToArray()
            End If

            ' BYSETPOS  rule part
            Dim bySetPos As String = row.Field(Of String)("RecurBySetPos")
            If Not String.IsNullOrEmpty(bySetPos) Then
                sc.RecurrenceRule.BySetPos = bySetPos.Split(","c).Select(Function(x) Short.Parse(x)).ToArray()
            End If
        End If

        If TypeOf sc Is IEvent Then
            ' Properties specific for events only
            Dim vEvent As IEvent = TryCast(sc, IEvent)
            vEvent.End = cal.CreateCalDateProp(row.Field(Of DateTime?)("End"), row.Field(Of String)("EndTimeZoneId"), isAllDay)
            vEvent.Transparency = cal.CreateTransparencyProp(row.Field(Of Boolean?)("EventTransparency"))
        Else
            ' Properties specific for to-dos only
            Dim vToDo As IToDo = TryCast(sc, IToDo)
            vToDo.Due = cal.CreateCalDateProp(row.Field(Of DateTime?)("End"), row.Field(Of String)("EndTimeZoneId"), isAllDay)
            vToDo.CompletedUtc = cal.CreateDateProp(row.Field(Of DateTime?)("ToDoCompletedUtc"), DateTimeKind.Utc)
            vToDo.PercentComplete = cal.CreateIntegerProp(row.Field(Of Byte?)("ToDoPercentComplete"))
        End If

        ' Get custom properties and custom parameters
        Dim eventComponentId As Guid = row.Field(Of Guid)("EventComponentId")
        Dim rowsEventCustomProperties As IEnumerable(Of DataRow) = rowsCustomProperties.Where(Function(x) x.Field(Of Guid)("ParentId") = eventComponentId)
        ReadCustomProperties(sc, rowsEventCustomProperties)
    End Sub

    Private Shared Sub ReadRecurrenceExceptions(recurrenceExceptions As IPropertyList(Of ICalDateList), rowsRecurrenceExceptions As IEnumerable(Of DataRow), cal As ICalendar2)
        For Each rowRecurrenceException As DataRow In rowsRecurrenceExceptions
            ' EXDATE property
            Dim exdate As ICalDateList = cal.CreateCalDateListProp(New DateTime() {rowRecurrenceException.Field(Of DateTime)("ExceptionDate")}, rowRecurrenceException.Field(Of String)("TimeZoneId"),                                                ' EXDATE TZID param
                                                                  rowRecurrenceException.Field(Of Boolean?)("AllDay").GetValueOrDefault()                                 ' EXDATE DATE or DATE-TIME
                                                                  )
            recurrenceExceptions.Add(exdate)
        Next
    End Sub

    Private Sub ReadAlarms(alarms As IComponentList(Of IAlarm), rowsAlarms As IEnumerable(Of DataRow), cal As ICalendar2)
        For Each rowAlarm As DataRow In rowsAlarms
            Dim alarm As IAlarm = alarms.CreateComponent()
            alarm.Action = cal.CreateActionProp(rowAlarm.Field(Of String)("Action"))
            alarm.Summary = cal.CreateCalTextProp(rowAlarm.Field(Of String)("Summary"))
            alarm.Description = cal.CreateCalTextProp(rowAlarm.Field(Of String)("Description"))
            alarm.Duration = cal.CreateDurationProp(rowAlarm.Field(Of Long?)("Duration"))
            alarm.Repeat = cal.CreateIntegerProp(rowAlarm.Field(Of Integer?)("Repeat"))
            ' Alarm TRIGGER property
            alarm.Trigger = cal.CreateProperty(Of ITrigger)()
            Dim absolute As DateTime? = rowAlarm.Field(Of DateTime?)("TriggerAbsoluteDateTimeUtc")
            If absolute IsNot Nothing Then
                alarm.Trigger.AbsoluteDateTimeUtc = DateTime.SpecifyKind(absolute.Value, DateTimeKind.Utc)
            End If

            Dim offset As Long? = rowAlarm.Field(Of Long?)("TriggerRelativeOffset")
            If offset IsNot Nothing Then
                alarm.Trigger.RelativeOffset = New TimeSpan(offset.Value)
            End If

            ' Alarm trigger RELATED param
            Dim related As Boolean? = rowAlarm.Field(Of Boolean?)("TriggerRelatedStart")
            If related IsNot Nothing Then
                alarm.Trigger.Related = If(related.Value, RelatedType.Start, RelatedType.End)
            End If

            ' Get custom properties and custom parameters
            Dim alarmId As Guid = rowAlarm.Field(Of Guid)("AlarmId")
            Dim rowsEventCustomProperties As IEnumerable(Of DataRow) = rowsCustomProperties.Where(Function(x) x.Field(Of Guid)("ParentId") = alarmId)
            ReadCustomProperties(alarm, rowsEventCustomProperties)
            alarms.Add(alarm)
        Next
    End Sub

    Private Sub ReadAttendees(attendees As IPropertyList(Of IAttendee), rowsAttendees As IEnumerable(Of DataRow), cal As ICalendar2)
        For Each rowAttendee As DataRow In rowsAttendees
            Dim attendee As IAttendee = attendees.CreateProperty()
            attendee.Uri = EmailToUri(rowAttendee.Field(Of String)("Email"))
            attendee.CommonName = rowAttendee.Field(Of String)("CommonName")
            attendee.Dir = rowAttendee.Field(Of String)("DirectoryEntryRef")
            attendee.Language = rowAttendee.Field(Of String)("Language")
            attendee.UserType = StringToEnum(Of CalendarUserType)(rowAttendee.Field(Of String)("UserType"))
            attendee.SentBy = EmailToUri(rowAttendee.Field(Of String)("SentBy"))
            attendee.DelegatedFrom = {EmailToUri(rowAttendee.Field(Of String)("DelegatedFrom"))}
            attendee.DelegatedTo = {EmailToUri(rowAttendee.Field(Of String)("DelegatedTo"))}
            ' Attendee RSVP parameter
            Dim rsvp As Boolean? = rowAttendee.Field(Of Boolean?)("Rsvp")
            If rsvp IsNot Nothing Then
                attendee.Rsvp = If(rsvp.Value, RsvpType.True, RsvpType.False)
            End If

            attendee.ParticipationRole = StringToEnum(Of ParticipationRoleType)(rowAttendee.Field(Of String)("ParticipationRole"))
            attendee.ParticipationStatus = StringToEnum(Of ParticipationStatusType)(rowAttendee.Field(Of String)("ParticipationStatus"))
            AddParamValues(rowAttendee.Field(Of Guid)("AttendeeId"), attendee.RawProperty)
            attendees.Add(attendee)
        Next
    End Sub

    Private Async Function ReadAttachmentsAsync(context As DavContext, attachments As IPropertyList(Of IMedia), rowsAttachments As IEnumerable(Of DataRow), cal As ICalendar2) As Task
        ' Find if any attachments content should be read from datatbase.
        Dim loadContent As Boolean = rowsAttachments.Any(Function(x)(x.Field(Of Integer)("ContentExists") = 1))
        If loadContent Then
            ' Reading attachments content from database.
            ' Set timeout to maximum value to be able to download iCalendar files with large file attachments.
            System.Web.HttpContext.Current.Server.ScriptTimeout = Integer.MaxValue
            Dim eventComponentId As Guid = rowsAttachments.First().Field(Of Guid)("EventComponentId")
            Dim sql As String = "SELECT [AttachmentId], [MediaType], [ExternalUrl], [Content] FROM [cal_Attachment] WHERE [EventComponentId]=@EventComponentId"
            Using reader As SqlDataReader = Await context.ExecuteReaderAsync(CommandBehavior.SequentialAccess, sql, "@EventComponentId", eventComponentId)
                While Await reader.ReadAsync()
                    Dim attachment As IMedia = attachments.CreateProperty()
                    Dim attachmentId As Guid = Await reader.GetFieldValueAsync(Of Guid)(reader.GetOrdinal("AttachmentId"))
                    ' Attachment FMTTYPE parameter
                    Dim ordMediaType As Integer = reader.GetOrdinal("MediaType")
                    If Not Await reader.IsDBNullAsync(ordMediaType) Then
                        attachment.MediaType = Await reader.GetFieldValueAsync(Of String)(ordMediaType)
                    End If

                    ' Attachment value as URL
                    Dim ordExternalUrl As Integer = reader.GetOrdinal("ExternalUrl")
                    If Not Await reader.IsDBNullAsync(ordExternalUrl) Then
                        attachment.Uri = Await reader.GetFieldValueAsync(Of String)(ordExternalUrl)
                    End If

                    ' Attachment value as inline content
                    Dim ordContent As Integer = reader.GetOrdinal("Content")
                    If Not Await reader.IsDBNullAsync(ordContent) Then
                        Using stream As Stream = reader.GetStream(ordContent)
                            Using memory As MemoryStream = New MemoryStream()
                                Await stream.CopyToAsync(memory)
                                attachment.Base64Data = Convert.ToBase64String(memory.ToArray())
                            End Using
                        End Using
                    End If

                    AddParamValues(attachmentId, attachment.RawProperty)
                    attachments.Add(attachment)
                End While
            End Using
        Else
            ' Attachments contain only URLs to external files.
            For Each rowAttachment As DataRow In rowsAttachments
                Dim attachment As IMedia = attachments.CreateProperty()
                attachment.MediaType = rowAttachment.Field(Of String)("MediaType")
                attachment.Uri = rowAttachment.Field(Of String)("ExternalUrl")
                AddParamValues(rowAttachment.Field(Of Guid)("AttachmentId"), attachment.RawProperty)
                attachments.Add(attachment)
            Next
        End If
    End Function

    Private Shared Sub ReadCustomProperties(component As IComponent, rowsCustomProperies As IEnumerable(Of DataRow))
        For Each rowCustomProperty As DataRow In rowsCustomProperies
            Dim propertyName As String = rowCustomProperty.Field(Of String)("PropertyName")
            Dim prop As IRawProperty
            If Not component.Properties.ContainsKey(propertyName) Then
                prop = component.CreateRawProperty()
                component.AddProperty(propertyName, prop)
            Else
                prop = component.Properties(propertyName).FirstOrDefault()
            End If

            Dim paramName As String = rowCustomProperty.Field(Of String)("ParameterName")
            Dim value As String = rowCustomProperty.Field(Of String)("Value")
            If paramName Is Nothing Then
                ' If ParameterName is null the Value contains property value
                prop.RawValue = value
            Else
                AddParamValue(prop, paramName, value)
            End If
        Next
    End Sub

    Private Sub AddParamValues(propertyId As Guid, prop As IRawProperty)
        Dim rowsCustomParams As IEnumerable(Of DataRow) = rowsCustomProperties.Where(Function(x) x.Field(Of Guid)("ParentId") = propertyId)
        For Each rowCustomParam As DataRow In rowsCustomParams
            Dim paramName As String = rowCustomParam.Field(Of String)("ParameterName")
            Dim paramValue As String = rowCustomParam.Field(Of String)("Value")
            AddParamValue(prop, paramName, paramValue)
        Next
    End Sub

    Private Shared Sub AddParamValue(prop As IRawProperty, paramName As String, paramValue As String)
        ' There could be parameters with identical name withing one property.
        ' This call returns all values from all properties with specified name.
        Dim paramVals As IEnumerable(Of String) = prop.Parameters(paramName)
        ' Add value.
        Dim paramNewVals As List(Of String) = paramVals.ToList()
        paramNewVals.Add(paramValue)
        ' This call removes any parameters with identical names if any and 
        ' replaces it with a single parameter with a lost of specified values.
        prop.Parameters(paramName) = paramNewVals
    End Sub

    Private Shared Function EmailToUri(email As String) As String
        If email Is Nothing Then Return Nothing
        If email.IndexOf("@"c) > 0 Then Return String.Format("mailto:{0}", email)
        Return email
    End Function

    Private Shared Function StringToEnum(Of T As {ExtendibleEnum, New})(value As String) As T
        If value Is Nothing Then Return Nothing
        Dim res As T
        If Not ExtendibleEnum.TryFromString(Of T)(value, res) Then
            ' If no matching value is found create new ExtendibleEnum or type T 
            ' with specified string value and default numeric value (-1).
            res = New T()
            res.Name = value
        End If

        Return res
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync">
            <summary>
            Represents a calendar on a CalDAV server.
            </summary>
            <remarks>
            <param>
            A calendar folder can contain calendar files only (items that implement 
            <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFileAsync" />) and folders that are not <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync" /> 
            folders. "Nesting" of calendar folders within other calendar folders at 
            any depth is NOT allowed.
            </param>
            <param>http://tools.ietf.org/html/rfc4791#section-4.2</param>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[// Note:
//  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
//  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.

public class CalendarFolder : DavHierarchyItem, ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<ICalendarFolderAsync> LoadByIdAsync(DavContext context, Guid calendarFolderId)
    {
        // Load only calendar that the use has access to. 
        // Also load complete ACL for this calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@CalendarFolderId", calendarFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<ICalendarFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only calendars that the use has access to. 
        // Also load complete ACL for each calendar, but only if user has access to that calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFolderAsync> calendarFolders = new List<ICalendarFolderAsync>();
        
        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))                    
        {
            DataTable calendars = new DataTable();
            calendars.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowCalendarFolder in calendars.Rows)
            {
                Guid calendarFolderId = rowCalendarFolder.Field<Guid>("CalendarFolderId");

                string filter = string.Format("CalendarFolderId = '{0}'", calendarFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                calendarFolders.Add(new CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess));
            }
        }

        return calendarFolders;
    }

    public static async Task CreateCalendarFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create calendar.
        // 2. Grant owner privileges to the user on the created calendar.
        string sql = @"INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid calendarFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid calendarFolderId;

    private readonly DataRow rowCalendarFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowCalendarFolder != null ? rowCalendarFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId);
        }
    }

    private CalendarFolder(DavContext context, Guid calendarFolderId, DataRow calendar, DataRow[] rowsAccess)
        : base(context)
    {
        this.calendarFolderId = calendarFolderId;
        this.rowCalendarFolder = calendar;
        this.rowsAccess = rowsAccess;
    }

    public async Task<IEnumerable<ICalendarFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of UIDs from path list.
        IEnumerable<string> uids = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICalendarFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList(), null, null, null)).Page.Cast<ICalendarFileAsync>();
    }

    public IEnumerable<CalendarComponentType> SupportedComponentTypes
    {
        get
        {
            return new[]
                {
                    CalendarComponentType.VEVENT,
                    CalendarComponentType.VTODO,
                };
        }
    }

    public string CalendarDescription 
    {
        get { return rowCalendarFolder.Field<string>("Description"); }
    }

    public ulong MaxResourceSize
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxInstances
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxAttendeesPerInstance
    {
        get { return ulong.MaxValue; }
    }

    public DateTime UtcMinDateTime
    {
        get { return DateTime.MinValue.ToUniversalTime(); }
    }

    public DateTime UtcMaxDateTime
    {
        get { return DateTime.MaxValue.ToUniversalTime(); }
    }

    public async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {
        // Here we enumerate all events and to-dos contained in this calendar.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync, that follow this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return new PageResults((await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum)), null);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual event or to-do object is created in datatbase in CardFile.Write call.
        return CalendarFile.CreateCalendarFile(Context, calendarFolderId);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only calendars renaming. Check that user has permissions to write.
        string sql = @"UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , destName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                "@CalendarFolderId", calendarFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))            
        {
            while (await reader.ReadAsync())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , prop.QualifiedName.Name,
            "@Namespace"        , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , name,
            "@Namespace"        , ns);
    }


    public IEnumerable<AppleAllowedSharingMode> AllowedSharingModes
    {
        get
        {
            return new[]
                {
                    AppleAllowedSharingMode.CanBePublished,
                    AppleAllowedSharingMode.CanBeShared,
                };
        }
    }

    public async Task UpdateSharingAsync(IList<AppleShare> sharesToAddAndRemove)
    {
        // Drop all shares first regardless of operation order. When resending 
        // invitations Apple Calendar drops and adds shares for the user in one \
        // request.
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation == AppleSharingOperation.Withdraw)
            {
                // remove sharing here
                // share.Address
                // share.CommonName
            }
        }

        // Add new shares
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation != AppleSharingOperation.Withdraw)
            {
                // enable sharing and send invitation here
                // share.Address
                // share.CommonName
            }
        }
    }

    public async Task<IEnumerable<SharingInvite>> GetInviteAsync()
    {

        IList<SharingInvite> invites = new List<SharingInvite>();

        foreach (DataRow rowAccess in rowsAccess)
        {
            if (rowAccess.Field<bool>("Owner"))
                continue;

            string userId = rowAccess.Field<string>("UserId");
            System.Web.Security.MembershipUser user = System.Web.Security.Membership.GetUser(userId);

            SharingInvite ace = new SharingInvite
            {
                  Address       = string.Format("email:{0}", user.Email)
                , Access        = rowAccess.Field<bool>("Write") ? SharingInviteAccess.ReadWrite : SharingInviteAccess.Read
                , CommonName    = user.UserName
                , Status        = SharingInviteStatus.Accepted
            };
        }

        return invites;
    }

    public async Task<CalendarSharedBy> GetSharedByAsync()
    {
        if (rowsAccess.Any(x => !x.Field<bool>("Owner")))
        {
            return CalendarSharedBy.NotShared;
        }

        string ownerId = rowsAccess.First(x => x.Field<bool>("Owner")).Field<string>("UserId");
        if (ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase))
        {
            return CalendarSharedBy.SharedByOwner;
        }
        else
        {
            return CalendarSharedBy.Shared;
        }
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId") == Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
      <code lang="VB"><![CDATA[' Note:
'  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
'  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.
Public Class CalendarFolder
    Inherits DavHierarchyItem
    Implements ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync

    Public Shared Async Function LoadByIdAsync(context As DavContext, calendarFolderId As Guid) As Task(Of ICalendarFolderAsync)
        ' Load only calendar that the use has access to. 
        ' Also load complete ACL for this calendar.
        Dim sql As String = "SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)"
        Return(Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@CalendarFolderId", calendarFolderId
                              )).FirstOrDefault()
    End Function

    Public Shared Async Function LoadAllAsync(context As DavContext) As Task(Of IEnumerable(Of ICalendarFolderAsync))
        ' Load only calendars that the use has access to. 
        ' Also load complete ACL for each calendar, but only if user has access to that calendar.
        Dim sql As String = "SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)"
        Return Await LoadAsync(context, sql, "@UserId", context.UserId)
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of ICalendarFolderAsync))
        Dim calendarFolders As IList(Of ICalendarFolderAsync) = New List(Of ICalendarFolderAsync)()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim calendars As DataTable = New DataTable()
            calendars.Load(reader)
            Dim access As DataTable = New DataTable()
            access.Load(reader)
            For Each rowCalendarFolder As DataRow In calendars.Rows
                Dim calendarFolderId As Guid = rowCalendarFolder.Field(Of Guid)("CalendarFolderId")
                Dim filter As String = String.Format("CalendarFolderId = '{0}'", calendarFolderId)
                Dim rowsAccess As DataRow() = access.Select(filter)
                calendarFolders.Add(New CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess))
            Next
        End Using

        Return calendarFolders
    End Function

    Public Shared Async Function CreateCalendarFolderAsync(context As DavContext, name As String, description As String) As Task
        ' 1. Create calendar.
        ' 2. Grant owner privileges to the user on the created calendar.
        Dim sql As String = "INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )"
        Dim calendarFolderId As Guid = Guid.NewGuid()
        Await context.ExecuteNonQueryAsync(sql,
                                          "@CalendarFolderId", calendarFolderId,
                                          "@Name", name,
                                          "@Description", description,
                                          "@UserId", context.UserId,
                                          "@Owner", True, "@Read", True, "@Write", True)
    End Function

    Private ReadOnly calendarFolderId As Guid

    Private ReadOnly rowCalendarFolder As DataRow

    Private ReadOnly rowsAccess As DataRow()

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            Return If(rowCalendarFolder IsNot Nothing, rowCalendarFolder.Field(Of String)("Name"), Nothing)
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Return String.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId)
        End Get
    End Property

    Private Sub New(context As DavContext, calendarFolderId As Guid, calendar As DataRow, rowsAccess As DataRow())
        MyBase.New(context)
        Me.calendarFolderId = calendarFolderId
        Me.rowCalendarFolder = calendar
        Me.rowsAccess = rowsAccess
    End Sub

    Public Async Function MultiGetAsync(pathList As IEnumerable(Of String), propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICalendarFileAsync)) Implements ICalendarReportAsync.MultiGetAsync
        ' Get list of UIDs from path list.
        Dim uids As IEnumerable(Of String) = pathList.Select(Function(a) System.IO.Path.GetFileNameWithoutExtension(a))
        Return Await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All)
    End Function

    Public Async Function QueryAsync(rawQuery As String, propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICalendarFileAsync)) Implements ICalendarReportAsync.QueryAsync
        ' For the sake of simplicity we just call GetChildren returning all items. 
        ' Typically you will return only items that match the query.
        Return(Await GetChildrenAsync(propNames.ToList(), Nothing, Nothing, Nothing)).Page.Cast(Of ICalendarFileAsync)()
    End Function

    Public ReadOnly Property SupportedComponentTypes As IEnumerable(Of CalendarComponentType) Implements ICalendarFolderAsync.SupportedComponentTypes
        Get
            Return {CalendarComponentType.VEVENT,
                   CalendarComponentType.VTODO}
        End Get
    End Property

    Public ReadOnly Property CalendarDescription As String Implements ICalendarFolderAsync.CalendarDescription
        Get
            Return rowCalendarFolder.Field(Of String)("Description")
        End Get
    End Property

    Public ReadOnly Property MaxResourceSize As ULong Implements ICalendarFolderAsync.MaxResourceSize
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property MaxInstances As ULong Implements ICalendarFolderAsync.MaxInstances
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property MaxAttendeesPerInstance As ULong Implements ICalendarFolderAsync.MaxAttendeesPerInstance
        Get
            Return ULong.MaxValue
        End Get
    End Property

    Public ReadOnly Property UtcMinDateTime As DateTime Implements ICalendarFolderAsync.UtcMinDateTime
        Get
            Return DateTime.MinValue.ToUniversalTime()
        End Get
    End Property

    Public ReadOnly Property UtcMaxDateTime As DateTime Implements ICalendarFolderAsync.UtcMaxDateTime
        Get
            Return DateTime.MaxValue.ToUniversalTime()
        End Get
    End Property

    Public Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we enumerate all events and to-dos contained in this calendar.
        ' You can filter children items in this implementation and 
        ' return only items that you want to be available for this 
        ' particular user.
        ' Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        ' The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        ' report, in MultiGetAsync, that follow this request.
        ' Bynari submits PROPFIND without props - Engine will request getcontentlength
        Dim children As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
        Return New PageResults((Await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum)), Nothing)
    End Function

    Public Async Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        ' The actual event or to-do object is created in datatbase in CardFile.Write call.
        Return CalendarFile.CreateCalendarFile(Context, calendarFolderId)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Throw New DavException("Not allowed.", DavStatus.NOT_ALLOWED)
    End Function

    Public Overrides Async Function MoveToAsync(destFolder As IItemCollectionAsync, destName As String, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.MoveToAsync
        ' Here we support only calendars renaming. Check that user has permissions to write.
        Dim sql As String = "UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@CalendarFolderId", calendarFolderId,
                                             "@Name", destName) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        ' Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        Dim sql As String = "DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@CalendarFolderId", calendarFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function GetPropertiesAsync(names As IList(Of PropertyName), allprop As Boolean) As Task(Of IEnumerable(Of PropertyValue)) Implements IHierarchyItemAsync.GetPropertiesAsync
        Dim propVals As IList(Of PropertyValue) = Await GetPropertyValuesAsync("SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                                                                              "@CalendarFolderId", calendarFolderId)
        If allprop Then
            Return propVals
        Else
            Dim requestedPropVals As IList(Of PropertyValue) = New List(Of PropertyValue)()
            For Each p As PropertyValue In propVals
                If names.Contains(p.QualifiedName) Then
                    requestedPropVals.Add(p)
                End If
            Next

            Return requestedPropVals
        End If
    End Function

    Public Overrides Async Function UpdatePropertiesAsync(setProps As IList(Of PropertyValue),
                                                         delProps As IList(Of PropertyName),
                                                         multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.UpdatePropertiesAsync
        For Each p As PropertyValue In setProps
            Await SetPropertyAsync(p)
        Next

        For Each p As PropertyName In delProps
            Await RemovePropertyAsync(p.Name, p.Namespace)
        Next
    End Function

    Private Async Function GetPropertyValuesAsync(command As String, ParamArray prms As Object()) As Task(Of IList(Of PropertyValue))
        Dim l As List(Of PropertyValue) = New List(Of PropertyValue)()
        Using reader As SqlDataReader = Await Context.ExecuteReaderAsync(command, prms)
            While Await reader.ReadAsync()
                Dim name As String = reader.GetString(reader.GetOrdinal("Name"))
                Dim ns As String = reader.GetString(reader.GetOrdinal("Namespace"))
                Dim value As String = reader.GetString(reader.GetOrdinal("PropVal"))
                l.Add(New PropertyValue(New PropertyName(name, ns), value))
            End While
        End Using

        Return l
    End Function

    Private Async Function SetPropertyAsync(prop As PropertyValue) As Task
        Dim selectCommand As String = "SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
        Dim count As Integer = Await Context.ExecuteScalarAsync(Of Integer)(selectCommand,
                                                                           "@CalendarFolderId", calendarFolderId,
                                                                           "@Name", prop.QualifiedName.Name,
                                                                           "@Namespace", prop.QualifiedName.Namespace)
        ' insert
        If count = 0 Then
            Dim insertCommand As String = "INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)"
            Await Context.ExecuteNonQueryAsync(insertCommand,
                                              "@PropVal", prop.Value,
                                              "@CalendarFolderId", calendarFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        Else
            ' update
            Dim command As String = "UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
            Await Context.ExecuteNonQueryAsync(command,
                                              "@PropVal", prop.Value,
                                              "@CalendarFolderId", calendarFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        End If
    End Function

    Private Async Function RemovePropertyAsync(name As String, ns As String) As Task
        Dim command As String = "DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace"
        Await Context.ExecuteNonQueryAsync(command,
                                          "@CalendarFolderId", calendarFolderId,
                                          "@Name", name,
                                          "@Namespace", ns)
    End Function

    Public ReadOnly Property AllowedSharingModes As IEnumerable(Of AppleAllowedSharingMode) Implements IAppleCalendarAsync.AllowedSharingModes
        Get
            Return {AppleAllowedSharingMode.CanBePublished,
                   AppleAllowedSharingMode.CanBeShared}
        End Get
    End Property

    Public Async Function UpdateSharingAsync(sharesToAddAndRemove As IList(Of AppleShare)) As Task Implements IAppleCalendarAsync.UpdateSharingAsync
        ' Drop all shares first regardless of operation order. When resending 
        ' invitations Apple Calendar drops and adds shares for the user in one \
        ' request.
        For Each share As AppleShare In sharesToAddAndRemove
            If share.Operation = AppleSharingOperation.Withdraw Then
                ' remove sharing here
                ' share.Address
                ' share.CommonName
                 End If
        Next

        ' Add new shares
        For Each share As AppleShare In sharesToAddAndRemove
            If share.Operation <> AppleSharingOperation.Withdraw Then
                ' enable sharing and send invitation here
                ' share.Address
                ' share.CommonName
                 End If
        Next
    End Function

    Public Async Function GetInviteAsync() As Task(Of IEnumerable(Of SharingInvite)) Implements IAppleCalendarAsync.GetInviteAsync
        Dim invites As IList(Of SharingInvite) = New List(Of SharingInvite)()
        For Each rowAccess As DataRow In rowsAccess
            If rowAccess.Field(Of Boolean)("Owner") Then Continue For
            Dim userId As String = rowAccess.Field(Of String)("UserId")
            Dim user As System.Web.Security.MembershipUser = System.Web.Security.Membership.GetUser(userId)
            Dim ace As SharingInvite = New SharingInvite With {.Address = String.Format("email:{0}", user.Email),
                                                         .Access = If(rowAccess.Field(Of Boolean)("Write"), SharingInviteAccess.ReadWrite, SharingInviteAccess.Read),
                                                         .CommonName = user.UserName,
                                                         .Status = SharingInviteStatus.Accepted
                                                         }
        Next

        Return invites
    End Function

    Public Async Function GetSharedByAsync() As Task(Of CalendarSharedBy) Implements IAppleCalendarAsync.GetSharedByAsync
        If rowsAccess.Any(Function(x) Not x.Field(Of Boolean)("Owner")) Then
            Return CalendarSharedBy.NotShared
        End If

        Dim ownerId As String = rowsAccess.First(Function(x) x.Field(Of Boolean)("Owner")).Field(Of String)("UserId")
        If ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase) Then
            Return CalendarSharedBy.SharedByOwner
        Else
            Return CalendarSharedBy.Shared
        End If
    End Function

    Public Function SetOwnerAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetOwnerAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetOwnerAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetOwnerAsync
        Dim rowOwner As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of Boolean)("Owner") = True)
        If rowOwner Is Nothing Then Return Nothing
        Return Await Acl.User.GetUserAsync(Context, rowOwner.Field(Of String)("UserId"))
    End Function

    Public Function SetGroupAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetGroupAsync
        Throw New DavException("Group cannot be set", DavStatus.FORBIDDEN)
    End Function

    Public Async Function GetGroupAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetGroupAsync
        Return Nothing
    End Function

    Public Async Function GetSupportedPrivilegeSetAsync() As Task(Of IEnumerable(Of SupportedPrivilege)) Implements IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync
        Return {New SupportedPrivilege With {.Privilege = Privilege.Read, .IsAbstract = False, .DescriptionLanguage = "en",
                                       .Description = "Allows or denies the user the ability to read content and properties of files/folders."},
               New SupportedPrivilege With {.Privilege = Privilege.Write, .IsAbstract = False, .DescriptionLanguage = "en",
                                                                                                                                                                                                                                                             .Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."}}
    End Function

    Public Async Function GetCurrentUserPrivilegeSetAsync() As Task(Of IEnumerable(Of Privilege)) Implements IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync
        Dim rowAccess As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of String)("UserId") = Context.UserId)
        If rowAccess Is Nothing Then Return Nothing
        Dim privileges As List(Of Privilege) = New List(Of Privilege)()
        If rowAccess.Field(Of Boolean)("Read") Then privileges.Add(Privilege.Read)
        If rowAccess.Field(Of Boolean)("Write") Then privileges.Add(Privilege.Write)
        Return privileges
    End Function

    Public Async Function GetAclAsync(propertyNames As IList(Of PropertyName)) As Task(Of IEnumerable(Of ReadAce)) Implements IAclHierarchyItemAsync.GetAclAsync
        Dim aceList As IList(Of ReadAce) = New List(Of ReadAce)()
        For Each rowAccess As DataRow In rowsAccess
            Dim ace As ReadAce = New ReadAce()
            ace.Principal = Await Acl.User.GetUserAsync(Context, rowAccess.Field(Of String)("UserId"))
            If rowAccess.Field(Of Boolean)("Read") Then ace.GrantPrivileges.Add(Privilege.Read)
            If rowAccess.Field(Of Boolean)("Write") Then ace.GrantPrivileges.Add(Privilege.Write)
            ace.IsProtected = rowAccess.Field(Of Boolean)("Owner")
            aceList.Add(ace)
        Next

        Return aceList
    End Function

    Public Function SetAclAsync(aces As IList(Of WriteAce)) As Task Implements IAclHierarchyItemAsync.SetAclAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetAclRestrictionsAsync() As Task(Of AclRestriction) Implements IAclHierarchyItemAsync.GetAclRestrictionsAsync
        Return New AclRestriction With {.NoInvert = True, .GrantOnly = True}
    End Function

    Public Async Function GetInheritedAclSetAsync() As Task(Of IEnumerable(Of IHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetInheritedAclSetAsync
        Return New IHierarchyItemAsync() {}
    End Function

    Public Async Function GetPrincipalCollectionSetAsync() As Task(Of IEnumerable(Of IPrincipalFolderAsync)) Implements IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync
        Return New IPrincipalFolderAsync() {New Acl.UsersFolder(Context)}
    End Function

    Public Async Function ResolveWellKnownPrincipalAsync(wellKnownPrincipal As WellKnownPrincipal) As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync
        Return Nothing
    End Function

    Public Function GetItemsByPropertyAsync(matchBy As MatchBy, props As IList(Of PropertyName)) As Task(Of IEnumerable(Of IAclHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetItemsByPropertyAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.SupportedComponentTypes">
            <summary>
            Gets a calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.        
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.CalendarDescription">
            <summary>
            Gets a human-readable description of the calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxResourceSize">
            <summary>
            Gets a numeric value indicating the maximum size of a
            resource in bytes that the server is willing to accept when a
            calendar object resource is stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.5
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxInstances">
            <summary>
            Gets a numeric value indicating the maximum number of
            recurrence instances that a calendar object resource stored in a
            calendar collection can generate.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.8
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxAttendeesPerInstance">
            <summary>
            Provides a numeric value indicating the maximum number of
            ATTENDEE properties in any instance of a calendar object resource
            stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.9
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.UtcMinDateTime">
            <summary>
            Gets a DATE-TIME value indicating the earliest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.6
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.UtcMaxDateTime">
            <summary>
            Gets a DATE-TIME value indicating the latest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.7
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarItem">
            <summary>
            Represents folder, file or principal on a CalDAV server. Enables <b>calendar-access</b> feature support discovery.
            </summary>
            <remarks>
            <param>This is the marker interface, it does not provide any methods or properties.</param>
            <param>
            Items that implement this interface report CalDAV support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>calendar-access</b> token.
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarPrincipalAsync">
            <summary>
            Represents principal on a server that supports CalDAV.
            </summary>
            <remarks>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces.  
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarReportAsync">
            <summary>
            Represents an item that can process <b>calendar-query</b> and <b>calendar-multiget</b> reports.
            </summary>
            <remarks>
            <param>
            Items that implement this interface advertise support for <b>calendar-query</b> and <b>calendar-multiget</b> 
            reports. 
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarReportAsync.MultiGetAsync(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that correspont to the specified list of item paths.
            </summary>
            <remarks>
            <param>
            This method is called by the Engine during <b>calendar-multiget</b> call.
            </param>
            <param>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or <b>null</b> if the item is not found.
            </param>
            </remarks>
            <param name="pathList">Calendar files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarReportAsync.QueryAsync(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that match specified filter. 
            </summary>
            <param name="rawQuery">
            Raw query sent by the client.
            </param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarSynchronizationAsync.SynchronizeAsync(System.String,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that changed since provided <b>syncToken</b>.
            </summary>
            <param name="syncToken">Synchronization token sent by the client.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleInboxFolderAsync">
            <summary>
            Represents scheduling inbox folder.
            </summary>
            <remarks>
            <param>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            <b>calendar-auto-schedule</b> support in response to the OPTIONS request in DAV header.
            </param>
            <param>Folders of this type contain copies of incoming scheduling messages.</param>
            <param>Scheduling inbox folder can not contain any other folders.</param>
            <param>More details could be found at http://tools.ietf.org/html/rfc6638#section-2.2</param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleOutboxFolderAsync">
            <summary>
            Represents scheduling outbox folder.
            </summary>
            <remarks>
            <param>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            "calendar-auto-schedule" support in response to the OPTIONS request.
            </param>
            <param>
            This type of folders are used as the target for busy time information requests, and to 
            manage privileges that apply to outgoing scheduling requests.
            </param>
            <param>
            Scheduling outbox folder can not contain any other folders. Folders of this type 
            should not be nested under  and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync"/> items at any depth.
            </param>
            <param>More details culd be found at http://tools.ietf.org/html/rfc6638#section-2.1</param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipalAsync">
            <summary>
            Represents principal on a CalDAV server with Scheduling Extensions support. Enables <b>calendar-auto-schedule</b> feature support discovery.
            </summary>
            <remarks>
            <param>
            Items that implement this interface report CalDAV Scheduling Extensions support in OPTIONS requests. 
            If this intervace is found on an item, the DAV header will include <b>calendar-auto-schedule</b> token.
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipalAsync.GetCalendarUserAddressSetAsync">
            <summary>
            Gets the list of calendar addresses, typically e-mails, for this principal resource.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipalAsync.GetScheduleOutboxUrlAsync">
            <summary>
            Gets the URL of the scheduling outbox collection owned by this principal.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipalAsync.GetScheduleInboxUrlAsync">
            <summary>
            Gets the URL of the scheduling inbox collection owned by this principal.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInvite">
            <summary>
            Represents information about invitation.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Status">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Access">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteAccess">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.Read">
            <summary>
            Indicates that the access level granted only allows sharees to read data in the shared calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.ReadWrite">
            <summary>
            Indicates that the access level granted allows sharees to read and write all data in the shared calendar, with the exception of components that would trigger scheduling.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteStatus">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Noresponse">
            <summary>
            Indicates that the sharee has never replied to the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Accepted">
            <summary>
            Indicates that the sharee has accepted the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Declined">
            <summary>
            Indicates that the sharee has declined the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Invalid">
            <summary>
            Indicates that the corresponding sharee is not a valid calendar user known to the server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating calendar server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.iTip.NamespaceDoc">
            <summary>
            This namespace provides interfaces and classes for managing iCalendar Transport-Independent Interoperability Protocol (iTIP).
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync">
            <summary>
            Assists in finding address books on a CardDAV server. Enables <b>addressbook-home-set</b> feature support discovery.
            </summary>
            <remarks>
            <param>
            This interface helps finding folders that contain address books. You will implement this interface on principal items, 
            as well as on any other items that you wish to report <b>addressbook-home-set</b> feature support and list folders that 
            contain address books owned by currently logged-in user. 
            </param>
            <param>
            This interface provides <see cref="M:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync.GetAddressbookHomeSetAsync" />) method that is called by the Engine 
            when client is discovering list of folders that contain address books.
            </param>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class Discovery : ICalendarDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetCalendarHomeSetAsync()
    {
        return new[] { new CalendarsRootFolder(Context) };
    }

    public bool CalendarHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
      <code lang="VB"><![CDATA[Public Class Discovery
    Implements ICalendarDiscoveryAsync

    Protected Context As DavContext

    Public Sub New(context As DavContext)
        Me.Context = context
    End Sub

    Public Async Function GetCalendarHomeSetAsync() As Task(Of IEnumerable(Of IItemCollectionAsync)) Implements ICalendarDiscoveryAsync.GetCalendarHomeSetAsync
        Return {New CalendarsRootFolder(Context)}
    End Function

    Public ReadOnly Property CalendarHomeSetEnabled As Boolean Implements ICalendarDiscoveryAsync.CalendarHomeSetEnabled
        Get
            Return True
        End Get
    End Property
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class Discovery : IAddressbookDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetAddressbookHomeSetAsync()
    {
        return new[] { new AddressbooksRootFolder(Context) };
    }

    public bool AddressbookHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
      <code lang="VB"><![CDATA[Public Class Discovery
    Implements IAddressbookDiscoveryAsync

    Protected Context As DavContext

    Public Sub New(context As DavContext)
        Me.Context = context
    End Sub

    Public Async Function GetAddressbookHomeSetAsync() As Task(Of IEnumerable(Of IItemCollectionAsync)) Implements IAddressbookDiscoveryAsync.GetAddressbookHomeSetAsync
        Return {New AddressbooksRootFolder(Context)}
    End Function

    Public ReadOnly Property AddressbookHomeSetEnabled As Boolean Implements IAddressbookDiscoveryAsync.AddressbookHomeSetEnabled
        Get
            Return True
        End Get
    End Property
End Class
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class AddressbooksRootFolder : LogicalFolder, IFolderAsync
{
    private static readonly string addressbooksRootFolderName = "addressbooks";

    public static string AddressbooksRootFolderPath = DavLocationFolder.DavLocationFolderPath + addressbooksRootFolderName + '/';

    public AddressbooksRootFolder(DavContext context)
        : base(context, AddressbooksRootFolderPath)
    {
    }

    public override async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {
        // Here we list addressbooks from back-end storage. 
        // You can filter addressbooks if requied and return only addressbooks that user has access to.
        return new PageResults((await AddressbookFolder.LoadAllAsync(Context)).OrderBy(x => x.Name), null);
    }

    public Task<IFileAsync> CreateFileAsync(string name)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task CreateFolderAsync(string name)
    {
        await AddressbookFolder.CreateAddressbookFolderAsync(Context, name, "");
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class AddressbooksRootFolder
    Inherits LogicalFolder
    Implements IFolderAsync

    Private Shared ReadOnly addressbooksRootFolderName As String = "addressbooks"

    Public Shared AddressbooksRootFolderPath As String = DavLocationFolder.DavLocationFolderPath & addressbooksRootFolderName & "/"c

    Public Sub New(context As DavContext)
        MyBase.New(context, AddressbooksRootFolderPath)
    End Sub

    Public Overrides Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we list addressbooks from back-end storage. 
        ' You can filter addressbooks if requied and return only addressbooks that user has access to.
        Return New PageResults((Await AddressbookFolder.LoadAllAsync(Context)).OrderBy(Function(x) x.Name), Nothing)
    End Function

    Public Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Await AddressbookFolder.CreateAddressbookFolderAsync(Context, name, "")
    End Function
End Class
Namespace
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class AddressbookFolder : DavHierarchyItem, IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<IAddressbookFolderAsync> LoadByIdAsync(DavContext context, Guid addressbookFolderId)
    {
        // Load only address book that the use has access to. 
        // Also load complete ACL for this address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only address books that the use has access to. 
        // Also load complete ACL for each address book, but only if user has access to that address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<IAddressbookFolderAsync> addressbookFolders = new List<IAddressbookFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))            
        {
            DataTable addressbooks = new DataTable();
            addressbooks.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowAddressbookFolder in addressbooks.Rows)
            {
                Guid addressbookFolderId = rowAddressbookFolder.Field<Guid>("AddressbookFolderId");

                string filter = string.Format("AddressbookFolderId = '{0}'", addressbookFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                addressbookFolders.Add(new AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess));
            }
        }

        return addressbookFolders;
    }

    internal static async Task CreateAddressbookFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create address book.
        // 2. Grant owner privileges to the user on the created address book(s).
        string sql = @"INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid addressbookFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@AddressbookFolderId", addressbookFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid addressbookFolderId;

    private readonly DataRow rowAddressbookFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowAddressbookFolder != null ? rowAddressbookFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId);
        }
    }

    private AddressbookFolder(DavContext context, Guid addressbookFolderId, DataRow addressbook, DataRow[] rowsAccess)
        : base(context)
    {
        this.addressbookFolderId    = addressbookFolderId;
        this.rowAddressbookFolder   = addressbook;
        this.rowsAccess             = rowsAccess;
    }

    public async Task<IEnumerable<ICardFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of file names from path list.
        IEnumerable<string> fileNames = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICardFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList(), null, null, null)).Page.Cast<ICardFileAsync>();
    }

    public string AddressbookDescription 
    {
        get { return rowAddressbookFolder.Field<string>("Description"); }
    }

    public async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {
        // Here we enumerate all business cards contained in this address book.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync() method call, that follows this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return new PageResults((await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum)), null);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual business card file is created in datatbase in CardFile.Write call.
        string fileName = System.IO.Path.GetFileNameWithoutExtension(name);
        return CardFile.CreateCardFile(Context, addressbookFolderId, fileName);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only addressbooks renaming. Check that user has permissions to write.
        string sql = @"UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql, 
              "@Name"               , destName
            , "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete address book and all vCards associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                "@AddressbookFolderId", addressbookFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();

        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))            
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , prop.QualifiedName.Name,
            "@Namespace"            , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , name,
            "@Namespace"            , ns);
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId")== Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class AddressbookFolder
    Inherits DavHierarchyItem
    Implements IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync

    Public Shared Async Function LoadByIdAsync(context As DavContext, addressbookFolderId As Guid) As Task(Of IAddressbookFolderAsync)
        ' Load only address book that the use has access to. 
        ' Also load complete ACL for this address book.
        Dim sql As String = "SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        Return(Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@AddressbookFolderId", addressbookFolderId
                              )).FirstOrDefault()
    End Function

    Public Shared Async Function LoadAllAsync(context As DavContext) As Task(Of IEnumerable(Of IAddressbookFolderAsync))
        ' Load only address books that the use has access to. 
        ' Also load complete ACL for each address book, but only if user has access to that address book.
        Dim sql As String = "SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        Return Await LoadAsync(context, sql, "@UserId", context.UserId)
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of IAddressbookFolderAsync))
        Dim addressbookFolders As IList(Of IAddressbookFolderAsync) = New List(Of IAddressbookFolderAsync)()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim addressbooks As DataTable = New DataTable()
            addressbooks.Load(reader)
            Dim access As DataTable = New DataTable()
            access.Load(reader)
            For Each rowAddressbookFolder As DataRow In addressbooks.Rows
                Dim addressbookFolderId As Guid = rowAddressbookFolder.Field(Of Guid)("AddressbookFolderId")
                Dim filter As String = String.Format("AddressbookFolderId = '{0}'", addressbookFolderId)
                Dim rowsAccess As DataRow() = access.Select(filter)
                addressbookFolders.Add(New AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess))
            Next
        End Using

        Return addressbookFolders
    End Function

    Friend Shared Async Function CreateAddressbookFolderAsync(context As DavContext, name As String, description As String) As Task
        ' 1. Create address book.
        ' 2. Grant owner privileges to the user on the created address book(s).
        Dim sql As String = "INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )"
        Dim addressbookFolderId As Guid = Guid.NewGuid()
        Await context.ExecuteNonQueryAsync(sql,
                                          "@AddressbookFolderId", addressbookFolderId,
                                          "@Name", name,
                                          "@Description", description,
                                          "@UserId", context.UserId,
                                          "@Owner", True, "@Read", True, "@Write", True)
    End Function

    Private ReadOnly addressbookFolderId As Guid

    Private ReadOnly rowAddressbookFolder As DataRow

    Private ReadOnly rowsAccess As DataRow()

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            Return If(rowAddressbookFolder IsNot Nothing, rowAddressbookFolder.Field(Of String)("Name"), Nothing)
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Return String.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId)
        End Get
    End Property

    Private Sub New(context As DavContext, addressbookFolderId As Guid, addressbook As DataRow, rowsAccess As DataRow())
        MyBase.New(context)
        Me.addressbookFolderId = addressbookFolderId
        Me.rowAddressbookFolder = addressbook
        Me.rowsAccess = rowsAccess
    End Sub

    Public Async Function MultiGetAsync(pathList As IEnumerable(Of String), propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICardFileAsync)) Implements IAddressbookReportAsync.MultiGetAsync
        ' Get list of file names from path list.
        Dim fileNames As IEnumerable(Of String) = pathList.Select(Function(a) System.IO.Path.GetFileNameWithoutExtension(a))
        Return Await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All)
    End Function

    Public Async Function QueryAsync(rawQuery As String, propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICardFileAsync)) Implements IAddressbookReportAsync.QueryAsync
        ' For the sake of simplicity we just call GetChildren returning all items. 
        ' Typically you will return only items that match the query.
        Return(Await GetChildrenAsync(propNames.ToList(), Nothing, Nothing, Nothing)).Page.Cast(Of ICardFileAsync)()
    End Function

    Public ReadOnly Property AddressbookDescription As String Implements IAddressbookFolderAsync.AddressbookDescription
        Get
            Return rowAddressbookFolder.Field(Of String)("Description")
        End Get
    End Property

    Public Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we enumerate all business cards contained in this address book.
        ' You can filter children items in this implementation and 
        ' return only items that you want to be available for this 
        ' particular user.
        ' Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        ' The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        ' report, in MultiGetAsync() method call, that follows this request.
        ' Bynari submits PROPFIND without props - Engine will request getcontentlength
        Dim children As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
        Return New PageResults((Await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum)), Nothing)
    End Function

    Public Async Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        ' The actual business card file is created in datatbase in CardFile.Write call.
        Dim fileName As String = System.IO.Path.GetFileNameWithoutExtension(name)
        Return CardFile.CreateCardFile(Context, addressbookFolderId, fileName)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Throw New DavException("Not allowed.", DavStatus.NOT_ALLOWED)
    End Function

    Public Overrides Async Function MoveToAsync(destFolder As IItemCollectionAsync, destName As String, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.MoveToAsync
        ' Here we support only addressbooks renaming. Check that user has permissions to write.
        Dim sql As String = "UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql, 
                                             "@Name", destName,
                                             "@UserId", Context.UserId,
                                             "@AddressbookFolderId", addressbookFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        ' Delete address book and all vCards associated with it. Check that user has permissions to delete.
        Dim sql As String = "DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@AddressbookFolderId", addressbookFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function GetPropertiesAsync(names As IList(Of PropertyName), allprop As Boolean) As Task(Of IEnumerable(Of PropertyValue)) Implements IHierarchyItemAsync.GetPropertiesAsync
        Dim propVals As IList(Of PropertyValue) = Await GetPropertyValuesAsync("SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                                                                              "@AddressbookFolderId", addressbookFolderId)
        If allprop Then
            Return propVals
        Else
            Dim requestedPropVals As IList(Of PropertyValue) = New List(Of PropertyValue)()
            For Each p As PropertyValue In propVals
                If names.Contains(p.QualifiedName) Then
                    requestedPropVals.Add(p)
                End If
            Next

            Return requestedPropVals
        End If
    End Function

    Public Overrides Async Function UpdatePropertiesAsync(setProps As IList(Of PropertyValue),
                                                         delProps As IList(Of PropertyName),
                                                         multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.UpdatePropertiesAsync
        For Each p As PropertyValue In setProps
            Await SetPropertyAsync(p)
        Next

        For Each p As PropertyName In delProps
            Await RemovePropertyAsync(p.Name, p.Namespace)
        Next
    End Function

    Private Async Function GetPropertyValuesAsync(command As String, ParamArray prms As Object()) As Task(Of IList(Of PropertyValue))
        Dim l As List(Of PropertyValue) = New List(Of PropertyValue)()
        Using reader As SqlDataReader = Await Context.ExecuteReaderAsync(command, prms)
            While reader.Read()
                Dim name As String = reader.GetString(reader.GetOrdinal("Name"))
                Dim ns As String = reader.GetString(reader.GetOrdinal("Namespace"))
                Dim value As String = reader.GetString(reader.GetOrdinal("PropVal"))
                l.Add(New PropertyValue(New PropertyName(name, ns), value))
            End While
        End Using

        Return l
    End Function

    Private Async Function SetPropertyAsync(prop As PropertyValue) As Task
        Dim selectCommand As String = "SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
        Dim count As Integer = Await Context.ExecuteScalarAsync(Of Integer)(selectCommand,
                                                                           "@AddressbookFolderId", addressbookFolderId,
                                                                           "@Name", prop.QualifiedName.Name,
                                                                           "@Namespace", prop.QualifiedName.Namespace)
        ' insert
        If count = 0 Then
            Dim insertCommand As String = "INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)"
            Await Context.ExecuteNonQueryAsync(insertCommand,
                                              "@PropVal", prop.Value,
                                              "@AddressbookFolderId", addressbookFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        Else
            ' update
            Dim command As String = "UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
            Await Context.ExecuteNonQueryAsync(command,
                                              "@PropVal", prop.Value,
                                              "@AddressbookFolderId", addressbookFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        End If
    End Function

    Private Async Function RemovePropertyAsync(name As String, ns As String) As Task
        Dim command As String = "DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace"
        Await Context.ExecuteNonQueryAsync(command,
                                          "@AddressbookFolderId", addressbookFolderId,
                                          "@Name", name,
                                          "@Namespace", ns)
    End Function

    Public Function SetOwnerAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetOwnerAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetOwnerAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetOwnerAsync
        Dim rowOwner As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of Boolean)("Owner") = True)
        If rowOwner Is Nothing Then Return Nothing
        Return Await Acl.User.GetUserAsync(Context, rowOwner.Field(Of String)("UserId"))
    End Function

    Public Function SetGroupAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetGroupAsync
        Throw New DavException("Group cannot be set", DavStatus.FORBIDDEN)
    End Function

    Public Async Function GetGroupAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetGroupAsync
        Return Nothing
    End Function

    Public Async Function GetSupportedPrivilegeSetAsync() As Task(Of IEnumerable(Of SupportedPrivilege)) Implements IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync
        Return {New SupportedPrivilege With {.Privilege = Privilege.Read, .IsAbstract = False, .DescriptionLanguage = "en",
                                       .Description = "Allows or denies the user the ability to read content and properties of files/folders."},
               New SupportedPrivilege With {.Privilege = Privilege.Write, .IsAbstract = False, .DescriptionLanguage = "en",
                                                                                                                                                                                                                                                             .Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."}}
    End Function

    Public Async Function GetCurrentUserPrivilegeSetAsync() As Task(Of IEnumerable(Of Privilege)) Implements IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync
        Dim rowAccess As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of String)("UserId") = Context.UserId)
        If rowAccess Is Nothing Then Return Nothing
        Dim privileges As List(Of Privilege) = New List(Of Privilege)()
        If rowAccess.Field(Of Boolean)("Read") Then privileges.Add(Privilege.Read)
        If rowAccess.Field(Of Boolean)("Write") Then privileges.Add(Privilege.Write)
        Return privileges
    End Function

    Public Async Function GetAclAsync(propertyNames As IList(Of PropertyName)) As Task(Of IEnumerable(Of ReadAce)) Implements IAclHierarchyItemAsync.GetAclAsync
        Dim aceList As IList(Of ReadAce) = New List(Of ReadAce)()
        For Each rowAccess As DataRow In rowsAccess
            Dim ace As ReadAce = New ReadAce()
            ace.Principal = Await Acl.User.GetUserAsync(Context, rowAccess.Field(Of String)("UserId"))
            If rowAccess.Field(Of Boolean)("Read") Then ace.GrantPrivileges.Add(Privilege.Read)
            If rowAccess.Field(Of Boolean)("Write") Then ace.GrantPrivileges.Add(Privilege.Write)
            ace.IsProtected = rowAccess.Field(Of Boolean)("Owner")
            aceList.Add(ace)
        Next

        Return aceList
    End Function

    Public Function SetAclAsync(aces As IList(Of WriteAce)) As Task Implements IAclHierarchyItemAsync.SetAclAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetAclRestrictionsAsync() As Task(Of AclRestriction) Implements IAclHierarchyItemAsync.GetAclRestrictionsAsync
        Return New AclRestriction With {.NoInvert = True, .GrantOnly = True}
    End Function

    Public Async Function GetInheritedAclSetAsync() As Task(Of IEnumerable(Of IHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetInheritedAclSetAsync
        Return New IHierarchyItemAsync() {}
    End Function

    Public Async Function GetPrincipalCollectionSetAsync() As Task(Of IEnumerable(Of IPrincipalFolderAsync)) Implements IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync
        Return New IPrincipalFolderAsync() {New Acl.UsersFolder(Context)}
    End Function

    Public Async Function ResolveWellKnownPrincipalAsync(wellKnownPrincipal As WellKnownPrincipal) As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync
        Return Nothing
    End Function

    Public Function GetItemsByPropertyAsync(matchBy As MatchBy, props As IList(Of PropertyName)) As Task(Of IEnumerable(Of IAclHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetItemsByPropertyAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync.AddressbookHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>addressbook-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <param>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>addressbook-home-set</b> feature for specific client. 
            </param>
            <param>
            iOS and OS X does require <b>addressbook-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CardDAV client. iOS starts immediate synchronization of all address books found on the server 
            via home-set request. Typically you will always enable heome-set for iOS and OS X CardDAV clients, but may disable it for other clients.
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync.GetAddressbookHomeSetAsync">
            <summary>
            Returns list of folder items that contain address books owned by this principal.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <param>
            Note that this property returns list of folders that contain address book folders, NOT the address book folders themselves.
            </param>
            <param>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync">
            <summary>
            Represents address book on a CardDAV server.
            </summary>
            <remarks>
            <param>
            Items of this type represent folder that contain business card files.
            </param>
            <param>
            An address book folder can contain business card files (items that implement <see cref="T:ITHit.WebDAV.Server.CardDav.ICardFileAsync" />) 
            and folders that are NOT <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync" /> folders. 
            "Nesting" of address book folders within other address book folders at any depth is NOT allowed.
            </param>
            <param>http://tools.ietf.org/html/rfc6352#section-5.2</param>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class AddressbookFolder : DavHierarchyItem, IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<IAddressbookFolderAsync> LoadByIdAsync(DavContext context, Guid addressbookFolderId)
    {
        // Load only address book that the use has access to. 
        // Also load complete ACL for this address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only address books that the use has access to. 
        // Also load complete ACL for each address book, but only if user has access to that address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<IAddressbookFolderAsync> addressbookFolders = new List<IAddressbookFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))            
        {
            DataTable addressbooks = new DataTable();
            addressbooks.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowAddressbookFolder in addressbooks.Rows)
            {
                Guid addressbookFolderId = rowAddressbookFolder.Field<Guid>("AddressbookFolderId");

                string filter = string.Format("AddressbookFolderId = '{0}'", addressbookFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                addressbookFolders.Add(new AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess));
            }
        }

        return addressbookFolders;
    }

    internal static async Task CreateAddressbookFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create address book.
        // 2. Grant owner privileges to the user on the created address book(s).
        string sql = @"INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid addressbookFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@AddressbookFolderId", addressbookFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid addressbookFolderId;

    private readonly DataRow rowAddressbookFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowAddressbookFolder != null ? rowAddressbookFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId);
        }
    }

    private AddressbookFolder(DavContext context, Guid addressbookFolderId, DataRow addressbook, DataRow[] rowsAccess)
        : base(context)
    {
        this.addressbookFolderId    = addressbookFolderId;
        this.rowAddressbookFolder   = addressbook;
        this.rowsAccess             = rowsAccess;
    }

    public async Task<IEnumerable<ICardFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of file names from path list.
        IEnumerable<string> fileNames = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICardFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList(), null, null, null)).Page.Cast<ICardFileAsync>();
    }

    public string AddressbookDescription 
    {
        get { return rowAddressbookFolder.Field<string>("Description"); }
    }

    public async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
    {
        // Here we enumerate all business cards contained in this address book.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync() method call, that follows this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return new PageResults((await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum)), null);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual business card file is created in datatbase in CardFile.Write call.
        string fileName = System.IO.Path.GetFileNameWithoutExtension(name);
        return CardFile.CreateCardFile(Context, addressbookFolderId, fileName);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only addressbooks renaming. Check that user has permissions to write.
        string sql = @"UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql, 
              "@Name"               , destName
            , "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete address book and all vCards associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                "@AddressbookFolderId", addressbookFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();

        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))            
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , prop.QualifiedName.Name,
            "@Namespace"            , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , name,
            "@Namespace"            , ns);
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId")== Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class AddressbookFolder
    Inherits DavHierarchyItem
    Implements IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync

    Public Shared Async Function LoadByIdAsync(context As DavContext, addressbookFolderId As Guid) As Task(Of IAddressbookFolderAsync)
        ' Load only address book that the use has access to. 
        ' Also load complete ACL for this address book.
        Dim sql As String = "SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        Return(Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@AddressbookFolderId", addressbookFolderId
                              )).FirstOrDefault()
    End Function

    Public Shared Async Function LoadAllAsync(context As DavContext) As Task(Of IEnumerable(Of IAddressbookFolderAsync))
        ' Load only address books that the use has access to. 
        ' Also load complete ACL for each address book, but only if user has access to that address book.
        Dim sql As String = "SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        Return Await LoadAsync(context, sql, "@UserId", context.UserId)
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of IAddressbookFolderAsync))
        Dim addressbookFolders As IList(Of IAddressbookFolderAsync) = New List(Of IAddressbookFolderAsync)()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim addressbooks As DataTable = New DataTable()
            addressbooks.Load(reader)
            Dim access As DataTable = New DataTable()
            access.Load(reader)
            For Each rowAddressbookFolder As DataRow In addressbooks.Rows
                Dim addressbookFolderId As Guid = rowAddressbookFolder.Field(Of Guid)("AddressbookFolderId")
                Dim filter As String = String.Format("AddressbookFolderId = '{0}'", addressbookFolderId)
                Dim rowsAccess As DataRow() = access.Select(filter)
                addressbookFolders.Add(New AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess))
            Next
        End Using

        Return addressbookFolders
    End Function

    Friend Shared Async Function CreateAddressbookFolderAsync(context As DavContext, name As String, description As String) As Task
        ' 1. Create address book.
        ' 2. Grant owner privileges to the user on the created address book(s).
        Dim sql As String = "INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )"
        Dim addressbookFolderId As Guid = Guid.NewGuid()
        Await context.ExecuteNonQueryAsync(sql,
                                          "@AddressbookFolderId", addressbookFolderId,
                                          "@Name", name,
                                          "@Description", description,
                                          "@UserId", context.UserId,
                                          "@Owner", True, "@Read", True, "@Write", True)
    End Function

    Private ReadOnly addressbookFolderId As Guid

    Private ReadOnly rowAddressbookFolder As DataRow

    Private ReadOnly rowsAccess As DataRow()

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            Return If(rowAddressbookFolder IsNot Nothing, rowAddressbookFolder.Field(Of String)("Name"), Nothing)
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Return String.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId)
        End Get
    End Property

    Private Sub New(context As DavContext, addressbookFolderId As Guid, addressbook As DataRow, rowsAccess As DataRow())
        MyBase.New(context)
        Me.addressbookFolderId = addressbookFolderId
        Me.rowAddressbookFolder = addressbook
        Me.rowsAccess = rowsAccess
    End Sub

    Public Async Function MultiGetAsync(pathList As IEnumerable(Of String), propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICardFileAsync)) Implements IAddressbookReportAsync.MultiGetAsync
        ' Get list of file names from path list.
        Dim fileNames As IEnumerable(Of String) = pathList.Select(Function(a) System.IO.Path.GetFileNameWithoutExtension(a))
        Return Await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All)
    End Function

    Public Async Function QueryAsync(rawQuery As String, propNames As IEnumerable(Of PropertyName)) As Task(Of IEnumerable(Of ICardFileAsync)) Implements IAddressbookReportAsync.QueryAsync
        ' For the sake of simplicity we just call GetChildren returning all items. 
        ' Typically you will return only items that match the query.
        Return(Await GetChildrenAsync(propNames.ToList(), Nothing, Nothing, Nothing)).Page.Cast(Of ICardFileAsync)()
    End Function

    Public ReadOnly Property AddressbookDescription As String Implements IAddressbookFolderAsync.AddressbookDescription
        Get
            Return rowAddressbookFolder.Field(Of String)("Description")
        End Get
    End Property

    Public Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
        ' Here we enumerate all business cards contained in this address book.
        ' You can filter children items in this implementation and 
        ' return only items that you want to be available for this 
        ' particular user.
        ' Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        ' The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        ' report, in MultiGetAsync() method call, that follows this request.
        ' Bynari submits PROPFIND without props - Engine will request getcontentlength
        Dim children As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
        Return New PageResults((Await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum)), Nothing)
    End Function

    Public Async Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
        ' The actual business card file is created in datatbase in CardFile.Write call.
        Dim fileName As String = System.IO.Path.GetFileNameWithoutExtension(name)
        Return CardFile.CreateCardFile(Context, addressbookFolderId, fileName)
    End Function

    Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
        Throw New DavException("Not allowed.", DavStatus.NOT_ALLOWED)
    End Function

    Public Overrides Async Function MoveToAsync(destFolder As IItemCollectionAsync, destName As String, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.MoveToAsync
        ' Here we support only addressbooks renaming. Check that user has permissions to write.
        Dim sql As String = "UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql, 
                                             "@Name", destName,
                                             "@UserId", Context.UserId,
                                             "@AddressbookFolderId", addressbookFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        ' Delete address book and all vCards associated with it. Check that user has permissions to delete.
        Dim sql As String = "DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql,
                                             "@UserId", Context.UserId,
                                             "@AddressbookFolderId", addressbookFolderId) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Overrides Async Function GetPropertiesAsync(names As IList(Of PropertyName), allprop As Boolean) As Task(Of IEnumerable(Of PropertyValue)) Implements IHierarchyItemAsync.GetPropertiesAsync
        Dim propVals As IList(Of PropertyValue) = Await GetPropertyValuesAsync("SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                                                                              "@AddressbookFolderId", addressbookFolderId)
        If allprop Then
            Return propVals
        Else
            Dim requestedPropVals As IList(Of PropertyValue) = New List(Of PropertyValue)()
            For Each p As PropertyValue In propVals
                If names.Contains(p.QualifiedName) Then
                    requestedPropVals.Add(p)
                End If
            Next

            Return requestedPropVals
        End If
    End Function

    Public Overrides Async Function UpdatePropertiesAsync(setProps As IList(Of PropertyValue),
                                                         delProps As IList(Of PropertyName),
                                                         multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.UpdatePropertiesAsync
        For Each p As PropertyValue In setProps
            Await SetPropertyAsync(p)
        Next

        For Each p As PropertyName In delProps
            Await RemovePropertyAsync(p.Name, p.Namespace)
        Next
    End Function

    Private Async Function GetPropertyValuesAsync(command As String, ParamArray prms As Object()) As Task(Of IList(Of PropertyValue))
        Dim l As List(Of PropertyValue) = New List(Of PropertyValue)()
        Using reader As SqlDataReader = Await Context.ExecuteReaderAsync(command, prms)
            While reader.Read()
                Dim name As String = reader.GetString(reader.GetOrdinal("Name"))
                Dim ns As String = reader.GetString(reader.GetOrdinal("Namespace"))
                Dim value As String = reader.GetString(reader.GetOrdinal("PropVal"))
                l.Add(New PropertyValue(New PropertyName(name, ns), value))
            End While
        End Using

        Return l
    End Function

    Private Async Function SetPropertyAsync(prop As PropertyValue) As Task
        Dim selectCommand As String = "SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
        Dim count As Integer = Await Context.ExecuteScalarAsync(Of Integer)(selectCommand,
                                                                           "@AddressbookFolderId", addressbookFolderId,
                                                                           "@Name", prop.QualifiedName.Name,
                                                                           "@Namespace", prop.QualifiedName.Namespace)
        ' insert
        If count = 0 Then
            Dim insertCommand As String = "INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)"
            Await Context.ExecuteNonQueryAsync(insertCommand,
                                              "@PropVal", prop.Value,
                                              "@AddressbookFolderId", addressbookFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        Else
            ' update
            Dim command As String = "UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace"
            Await Context.ExecuteNonQueryAsync(command,
                                              "@PropVal", prop.Value,
                                              "@AddressbookFolderId", addressbookFolderId,
                                              "@Name", prop.QualifiedName.Name,
                                              "@Namespace", prop.QualifiedName.Namespace)
        End If
    End Function

    Private Async Function RemovePropertyAsync(name As String, ns As String) As Task
        Dim command As String = "DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace"
        Await Context.ExecuteNonQueryAsync(command,
                                          "@AddressbookFolderId", addressbookFolderId,
                                          "@Name", name,
                                          "@Namespace", ns)
    End Function

    Public Function SetOwnerAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetOwnerAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetOwnerAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetOwnerAsync
        Dim rowOwner As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of Boolean)("Owner") = True)
        If rowOwner Is Nothing Then Return Nothing
        Return Await Acl.User.GetUserAsync(Context, rowOwner.Field(Of String)("UserId"))
    End Function

    Public Function SetGroupAsync(value As IPrincipalAsync) As Task Implements IAclHierarchyItemAsync.SetGroupAsync
        Throw New DavException("Group cannot be set", DavStatus.FORBIDDEN)
    End Function

    Public Async Function GetGroupAsync() As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.GetGroupAsync
        Return Nothing
    End Function

    Public Async Function GetSupportedPrivilegeSetAsync() As Task(Of IEnumerable(Of SupportedPrivilege)) Implements IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync
        Return {New SupportedPrivilege With {.Privilege = Privilege.Read, .IsAbstract = False, .DescriptionLanguage = "en",
                                       .Description = "Allows or denies the user the ability to read content and properties of files/folders."},
               New SupportedPrivilege With {.Privilege = Privilege.Write, .IsAbstract = False, .DescriptionLanguage = "en",
                                                                                                                                                                                                                                                             .Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."}}
    End Function

    Public Async Function GetCurrentUserPrivilegeSetAsync() As Task(Of IEnumerable(Of Privilege)) Implements IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync
        Dim rowAccess As DataRow = rowsAccess.FirstOrDefault(Function(x) x.Field(Of String)("UserId") = Context.UserId)
        If rowAccess Is Nothing Then Return Nothing
        Dim privileges As List(Of Privilege) = New List(Of Privilege)()
        If rowAccess.Field(Of Boolean)("Read") Then privileges.Add(Privilege.Read)
        If rowAccess.Field(Of Boolean)("Write") Then privileges.Add(Privilege.Write)
        Return privileges
    End Function

    Public Async Function GetAclAsync(propertyNames As IList(Of PropertyName)) As Task(Of IEnumerable(Of ReadAce)) Implements IAclHierarchyItemAsync.GetAclAsync
        Dim aceList As IList(Of ReadAce) = New List(Of ReadAce)()
        For Each rowAccess As DataRow In rowsAccess
            Dim ace As ReadAce = New ReadAce()
            ace.Principal = Await Acl.User.GetUserAsync(Context, rowAccess.Field(Of String)("UserId"))
            If rowAccess.Field(Of Boolean)("Read") Then ace.GrantPrivileges.Add(Privilege.Read)
            If rowAccess.Field(Of Boolean)("Write") Then ace.GrantPrivileges.Add(Privilege.Write)
            ace.IsProtected = rowAccess.Field(Of Boolean)("Owner")
            aceList.Add(ace)
        Next

        Return aceList
    End Function

    Public Function SetAclAsync(aces As IList(Of WriteAce)) As Task Implements IAclHierarchyItemAsync.SetAclAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function

    Public Async Function GetAclRestrictionsAsync() As Task(Of AclRestriction) Implements IAclHierarchyItemAsync.GetAclRestrictionsAsync
        Return New AclRestriction With {.NoInvert = True, .GrantOnly = True}
    End Function

    Public Async Function GetInheritedAclSetAsync() As Task(Of IEnumerable(Of IHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetInheritedAclSetAsync
        Return New IHierarchyItemAsync() {}
    End Function

    Public Async Function GetPrincipalCollectionSetAsync() As Task(Of IEnumerable(Of IPrincipalFolderAsync)) Implements IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync
        Return New IPrincipalFolderAsync() {New Acl.UsersFolder(Context)}
    End Function

    Public Async Function ResolveWellKnownPrincipalAsync(wellKnownPrincipal As WellKnownPrincipal) As Task(Of IPrincipalAsync) Implements IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync
        Return Nothing
    End Function

    Public Function GetItemsByPropertyAsync(matchBy As MatchBy, props As IList(Of PropertyName)) As Task(Of IEnumerable(Of IAclHierarchyItemAsync)) Implements IAclHierarchyItemAsync.GetItemsByPropertyAsync
        Throw New DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED)
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync.AddressbookDescription">
            <summary>
            Gets a human-readable description of the address book.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem">
            <summary>
            Represents folder, file or principal on a CardDAV server. Enables <b>addressbook</b> feature support discovery.
            </summary>
            <remarks>
            <param>This is the marker interface, it does not provide any methods or properties.</param>
            <param>
            Items that implement this interface report CardDAV support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>addressbook</b> token.
            </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookPrincipalAsync">
            <summary>
            Represents principal on a server that supports CardDAV.
            </summary>
            <remarks>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync"/> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem"/> interfaces.  
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookReportAsync">
            <summary>
            Represents an item that can process <b>addressbook-query</b> and <b>addressbook-multiget</b> reports.
            </summary>
            <remarks>
            <param>
            Items that implement this interface advertise support for <b>addressbook-query</b> and <b>addressbook-multiget</b> 
            reports. 
            </param>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookReportAsync.MultiGetAsync(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of business card files that correspont to the specified list of item paths.
            </summary>
            <remarks>
            <param>
            This method is called by the Engine during <b>addressbook-multiget</b> call.
            </param>
            <param>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or <b>null</b> if the item is not found.
            </param>
            </remarks>
            <param name="pathList">Business card files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of business card files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookReportAsync.QueryAsync(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of business card files that match specified filter. 
            </summary>
            <remarks>
            <param>
            This method is called by the Engine during <b>addressbook-query</b> call.
            </param>
            </remarks>
            <param name="rawQuery">
            Raw query sent by the client.
            </param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of  business card files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.ICardFileAsync">
            <summary>
            Represents business card in address book on a CardDAV server.
            </summary>
            <remarks>
            <param>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync" /> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem" /> interfaces.  
            Items of this type will return content returned from 
            <see cref="!:IContentAsync.ReadAsync" /> method in <b>address-data</b> 
            CardDAV property.
            </param>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class CardFile : DavHierarchyItem, ICardFileAsync
{
    public static string Extension = ".vcf";

    public static async Task<IEnumerable<ICardFileAsync>> LoadByAddressbookFolderIdAsync(DavContext context, Guid addressbookFolderId, PropsToLoad propsToLoad)
    {
        // propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CardDAV clients
        // [Summary] is typically not required in GetChildren call, 
        // they are extracted for demo purposes only, to be displayed in Ajax File Browser.

        // propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.

        if (propsToLoad != PropsToLoad.Minimum)
            throw new NotImplementedException("LoadByAddressbookFolderIdAsync is implemented only with PropsToLoad.Minimum.");

        string sql = @"SELECT * FROM [card_CardFile] 
                       WHERE [AddressbookFolderId] = @AddressbookFolderId
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        //sql = string.Format(sql, GetScPropsToLoad(propsToLoad));
        
        return await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId);
    }

    public static async Task<IEnumerable<ICardFileAsync>> LoadByFileNamesAsync(DavContext context, IEnumerable<string> fileNames, PropsToLoad propsToLoad)
    {
        // Get IN clause part with list of file UIDs for SELECT.
        string selectIn = string.Join(", ", fileNames.Select(a => string.Format("'{0}'", a)).ToArray());

        string sql = @"SELECT * FROM [card_CardFile] 
                       WHERE [FileName] IN ({0})
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        if(propsToLoad==PropsToLoad.All)
        {
            sql += @";SELECT * FROM [card_Email]             WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Address]           WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_InstantMessenger]  WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Telephone]         WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Url]               WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_CustomProperty]    WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0})) AND [ClientAppName] = @ClientAppName";
        }

        sql = string.Format(sql, selectIn);

        return await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@ClientAppName", AppleCardInteroperability.GetClientAppName(context.Request.UserAgent));
    }

    private static async Task<IEnumerable<ICardFileAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICardFileAsync> items = new List<ICardFileAsync>();

        Stopwatch stopWatch = Stopwatch.StartNew();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))            
        {
            DataTable cards = new DataTable();
            cards.Load(reader);

            DataTable emails = new DataTable();
            if (!reader.IsClosed)
                emails.Load(reader);

            DataTable addresses = new DataTable();
            if (!reader.IsClosed)
                addresses.Load(reader);

            DataTable instantMessengers = new DataTable();
            if (!reader.IsClosed)
                instantMessengers.Load(reader);

            DataTable telephones = new DataTable();
            if (!reader.IsClosed)
                telephones.Load(reader);

            DataTable urls = new DataTable();
            if (!reader.IsClosed)
                urls.Load(reader);

            DataTable cardCustomProperties = new DataTable();
            if (!reader.IsClosed)
                cardCustomProperties.Load(reader);

            stopWatch.Stop();
            context.Engine.Logger.LogDebug(string.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds));


            foreach (DataRow rowCardFile in cards.Rows)
            {
                DataRow[] rowsEmails                = new DataRow[0];
                DataRow[] rowsAddresses             = new DataRow[0];
                DataRow[] rowsInstantMessengers     = new DataRow[0];
                DataRow[] rowsTelephones            = new DataRow[0];
                DataRow[] rowsUrls                  = new DataRow[0];
                DataRow[] rowsCustomProperties      = new DataRow[0];

                string uid = rowCardFile.Field<string>("UID");

                if (emails.Columns["UID"] != null)
                {
                    string filter = string.Format("UID = '{0}'", uid);

                    rowsEmails              = emails.Select(filter);
                    rowsAddresses           = addresses.Select(filter);
                    rowsInstantMessengers   = instantMessengers.Select(filter);
                    rowsTelephones          = telephones.Select(filter);
                    rowsUrls                = urls.Select(filter);
                    rowsCustomProperties = cardCustomProperties.Select(filter);
                }

                string fileName = rowCardFile.Field<string>("FileName");

                items.Add(new CardFile(context, fileName, rowCardFile, rowsEmails, rowsAddresses, rowsInstantMessengers, rowsTelephones, rowsUrls, rowsCustomProperties));
            }
        }

        return items;
    }

    public static CardFile CreateCardFile(DavContext context, Guid addressbookFolderId, string fileName)
    {
        CardFile cardFile = new CardFile(context, fileName, null, null, null, null, null, null, null);
        cardFile.addressbookFolderId = addressbookFolderId;
        return cardFile;
    }

    private readonly string fileName = null;

    private readonly DataRow rowCardFile = null;

    private readonly DataRow[] rowsEmails = null;

    private readonly DataRow[] rowsAddresses = null;

    private readonly DataRow[] rowsInstantMessengers = null;

    private readonly DataRow[] rowsTelephones = null;

    private readonly DataRow[] rowsUrls = null;

    private readonly DataRow[] rowsCustomProperties = null;

    private bool isNew
    {
        get { return addressbookFolderId != Guid.Empty; }
    }

    private int paramIndex = 0;

    private Guid addressbookFolderId = Guid.Empty;

    public override string Name
    {
        get
        {
            return rowCardFile.Field<string>("FormattedName");
        }
    }

    public override string Path
    {
        get
        {
            Guid addressbookFolderId = rowCardFile.Field<Guid>("AddressbookFolderId");
            string fileName = rowCardFile.Field<string>("FileName");
            return string.Format("{0}{1}/{2}{3}", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId, fileName, Extension);
        }
    }

    public string Etag
    {
        get
        {
            byte[] bETag = rowCardFile.Field<byte[]>("ETag");
            return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString(); // convert timestamp value to number
        }
    }

    public override DateTime Created
    {
        get { return rowCardFile.Field<DateTime>("CreatedUtc"); }
    }

    public override DateTime Modified
    {
        get { return rowCardFile.Field<DateTime>("ModifiedUtc"); }
    }

    public long ContentLength
    {
        get { return -1; }
    }

    public string ContentType
    {
     get { return "text/vcard"; }
    }

    private CardFile(DavContext context, string fileName,
        DataRow rowCardFile, DataRow[] rowsEmails, DataRow[] rowsAddresses, DataRow[] rowsInstantMessengers,
        DataRow[] rowsTelephones, DataRow[] rowsUrls, DataRow[] rowsCustomProperties)
        : base(context)
    {
        this.fileName               = fileName;
        this.rowCardFile            = rowCardFile;
        this.rowsEmails             = rowsEmails;
        this.rowsAddresses          = rowsAddresses;
        this.rowsInstantMessengers  = rowsInstantMessengers;
        this.rowsTelephones         = rowsTelephones;
        this.rowsUrls               = rowsUrls;
        this.rowsCustomProperties   = rowsCustomProperties;
    }

    public async Task<bool> WriteAsync(Stream stream, string contentType, long startIndex, long totalFileSize)
    {
        //Set timeout to maximum value to be able to upload large card files.
        System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
        string vCard;
        using (StreamReader reader = new StreamReader(stream))
        {
            vCard = await reader.ReadToEndAsync();
        }

        // Typically the stream contains a single vCard.
        IEnumerable<IComponent> cards = new vFormatter().Deserialize(vCard);
        ICard2 card = cards.First() as ICard2;

        // Card file UID which is equal to file name (??).
        // The type is used to uniquely identify the object that the vCard represents. The "uuid" URN namespace defined in 
        // [RFC4122] is particularly well-suited to this task, but other URI schemes MAY be used.
        string uid = card.Uid?.Text ?? "UID:urn:uuid:" + Guid.NewGuid().ToString();

        // Check if this CardDAV client application requires properties conversion.
        if (AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent))
        {
            AppleCardInteroperability.Normalize(card);
        }

        // The client app name is stored in DB to update and extract only custom props created by the client making a request.
        string clientAppName = AppleCardInteroperability.GetClientAppName(Context.Request.UserAgent);

        // Save data to [card_CardFile] table.
        await WriteCardFileAsync(Context, card, addressbookFolderId, isNew, uid, clientAppName);

        // Save emails.
        await WriteEmailsAsync(Context, card.Emails, uid, clientAppName);

        // Save addresses.
        await WriteAddressesAsync(Context, card.Addresses, uid, clientAppName);

        // Save telephones.
        await WriteTelephonesAsync(Context, card.Telephones, uid, clientAppName);

        // Save URLs
        await WriteUrlsAsync(Context, card.Urls, uid, clientAppName);

        // Save instant messengers. vCard 3.0+ only
        ICard3 card3 = card as ICard3;
        if (card3 != null)
        {
            await WriteInstantMessengersAsync(Context, card3.InstantMessengers, uid, clientAppName);
        }

        return true;
    }

    private async Task WriteCardFileAsync(DavContext context, ICard2 card, Guid addressbookFolderId, bool isNew, string uid, string clientAppName)
    {
        string sql;
        if (isNew)
        {
            sql =
                @"IF EXISTS (SELECT 1 FROM [card_Access] WHERE [AddressbookFolderId]=@AddressbookFolderId AND [UserId]=@UserId AND [Write]=1)
                  INSERT INTO [card_CardFile] (
                      [UID]
                    , [AddressbookFolderId]
                 , [FileName]
                 , [Version]
                 , [Product]
                 , [FormattedName]
                 , [FamilyName]
                 , [GivenName]
                 , [AdditionalNames]
                 , [HonorificPrefix]
                 , [HonorificSuffix]
                 , [Kind]
                 , [Nickname]
                 , [Photo]
                 , [PhotoMediaType]
                 , [Logo]
                 , [LogoMediaType]
                 , [Sound]
                 , [SoundMediaType]
                 , [Birthday]
                 , [Anniversary]
                 , [Gender]
                 , [RevisionUtc]
                 , [SortString]
                 , [Language]
                 , [TimeZone]
                 , [Geo]
                 , [Title]
                 , [Role]
                 , [OrgName]
                 , [OrgUnit]
                 , [Categories]
                 , [Note]
                 , [Classification]
                ) VALUES (
                      @UID
                    , @AddressbookFolderId
                    , @FileName
                    , @Version
                    , @Product
                 , @FormattedName
                 , @FamilyName
                 , @GivenName
                 , @AdditionalNames
                 , @HonorificPrefix
                 , @HonorificSuffix
                 , @Kind
                 , @Nickname
                 , @Photo
                 , @PhotoMediaType
                 , @Logo
                 , @LogoMediaType
                 , @Sound
                 , @SoundMediaType
                 , @Birthday
                 , @Anniversary
                 , @Gender
                 , @RevisionUtc
                 , @SortString
                 , @Language
                 , @TimeZone
                 , @Geo
                 , @Title
                 , @Role
                 , @OrgName
                 , @OrgUnit
                 , @Categories
                 , @Note
                 , @Classification
                )";
        }
        else
        {
            // We can only update record in [card_CardFile] table.
            // There is no way to update [card_Email], [card_Address], [card_InstantMessenger], [card_Telephone] and [card_Url]
            // tables for existing card, we must delete all records for this UID and recreate.

            // We can keep custom props in [card_CustomProperty] table if they were created by a different CardDAV client.

            // [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql =
                @"IF EXISTS (SELECT 1 FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1))
                  BEGIN
                      UPDATE [card_CardFile] SET 
                          [ModifiedUtc]     = @ModifiedUtc
                     , [Version]         = @Version
                     , [Product]         = @Product
                     , [FormattedName]   = @FormattedName
                     , [FamilyName]      = @FamilyName
                     , [GivenName]       = @GivenName
                     , [AdditionalNames] = @AdditionalNames
                     , [HonorificPrefix] = @HonorificPrefix
                     , [HonorificSuffix] = @HonorificSuffix
                     , [Kind]            = @Kind
                     , [Nickname]        = @Nickname
                     , [Photo]           = @Photo
                     , [PhotoMediaType]  = @PhotoMediaType
                     , [Logo]            = @Logo
                     , [LogoMediaType]   = @LogoMediaType
                     , [Sound]           = @Sound
                     , [SoundMediaType]  = @SoundMediaType
                     , [Birthday]        = @Birthday
                     , [Anniversary]     = @Anniversary
                     , [Gender]          = @Gender
                     , [RevisionUtc]     = @RevisionUtc
                     , [SortString]      = @SortString
                     , [Language]        = @Language
                     , [TimeZone]        = @TimeZone
                     , [Geo]             = @Geo
                     , [Title]           = @Title
                     , [Role]            = @Role
                     , [OrgName]         = @OrgName
                     , [OrgUnit]         = @OrgUnit
                     , [Categories]      = @Categories
                     , [Note]            = @Note
                     , [Classification]  = @Classification
                      WHERE 
                        [UID] = @UID
                
                      ; DELETE FROM [card_Email]              WHERE [UID] = @UID
                      ; DELETE FROM [card_Address]            WHERE [UID] = @UID
                      ; DELETE FROM [card_InstantMessenger]   WHERE [UID] = @UID
                      ; DELETE FROM [card_Telephone]          WHERE [UID] = @UID
                      ; DELETE FROM [card_Url]                WHERE [UID] = @UID
                      ; DELETE FROM [card_CustomProperty]     WHERE [UID] = @UID AND (([ClientAppName] = @ClientAppName) OR ([ParentId] != [UID]) OR ([ClientAppName] IS NULL))
                  END";

        }
        // [ClientAppName] = @ClientAppName -> delete all custom props created by this client.
        // [ParentId] != [UID]              -> delete all custom params from multiple props: EMAIL, ADR, TEL, IMPP. Keep custom params for any single props in [card_Card].
        // [ClientAppName] IS NULL          -> delete all custom props created by some unknown CardDAV client.

                                                                                                    
        if (await context.ExecuteNonQueryAsync(sql,
              "@UID"            , uid                                                                   // UID
            , "UserId"          , context.UserId
            , "@AddressbookFolderId", addressbookFolderId                                               // used only when inserting
            , "@FileName"       , fileName                                                              // In case of CardDAV a file name is sypically a GUID, but it is different from UID.
            , "@ModifiedUtc"    , DateTime.UtcNow
            , "@Version"        , card.Version.Text                                                     // VERSION
            , "@Product"        , card.ProductId?.Text                                                  // PRODID
            , "@FormattedName"  , card.FormattedNames.PreferedOrFirstProperty.Text                      // FN                           Here we assume only 1 prop for the sake of simplicity.
            , "@FamilyName"     , card.Name.FamilyName                                                  // N
            , "@GivenName"      , card.Name.GivenName                                                   // N
            , "@AdditionalNames", card.Name.AdditionalNamesList                                         // N
            , "@HonorificPrefix", card.Name.HonorificPrefix                                             // N
            , "@HonorificSuffix", card.Name.HonorificSuffix                                             // N
            , "@Kind"           , (card as ICard4)?.Kind?.Text                                          // KIND         (vCard 4.0)
            , "@Nickname"       , (card as ICard3)?.NickNames.PreferedOrFirstProperty?.Values.First()   // NICKNAME     (vCard 3.0+)    Here we assume only 1 prop with 1 value for the sake of simplicity.
            , CreateVarBinaryParam("@Photo", card.Photos.PreferedOrFirstProperty?.Base64Data)           // PHOTO                        Here we assume only 1 prop for the sake of simplicity.
            , "@PhotoMediaType" , card.Photos.PreferedOrFirstProperty?.MediaType                        // PHOTO TYPE param
            , CreateVarBinaryParam("@Logo",  card.Logos.PreferedOrFirstProperty?.Base64Data)            // LOGO                         Here we assume only 1 prop for the sake of simplicity.
            , "@LogoMediaType"  , card.Logos.PreferedOrFirstProperty?.MediaType                         // LOGO  TYPE param
            , CreateVarBinaryParam("@Sound", card.Sounds.PreferedOrFirstProperty?.Base64Data)           // SOUND                        Here we assume only 1 prop for the sake of simplicity.
            , "@SoundMediaType" , card.Sounds.PreferedOrFirstProperty?.MediaType                        // SOUND TYPE param
            , new SqlParameter("@Birthday"   , card.BirthDate?.Value?.DateVal ?? DBNull.Value as object)                { SqlDbType = SqlDbType.DateTime2 }   // BDAY
            , new SqlParameter("@Anniversary", (card as ICard4)?.Anniversary?.Value?.DateVal ?? DBNull.Value as object) { SqlDbType = SqlDbType.DateTime2 }   // ANNIVERSARY  (vCard 4.0)
            , "@Gender"         , (card as ICard4)?.Gender?.Sex                                         // GENDER       (vCard 4.0)
            , "@RevisionUtc"    , card.Revision?.Value.DateVal                                          // REV
            , "@SortString"     , card.SortString?.Text                                                 // SORT-STRING
            , "@Language"       , (card as ICard4)?.ContactLanguages.PreferedOrFirstProperty?.Text      // LANG         (vCard 4.0)     Here we assume only 1 prop for the sake of simplicity.
            , "@TimeZone"       , card.TimeZones.PreferedOrFirstProperty?.Text                          // TZ
            , "@Geo"            , null                                                                  // GEO
            , "@Title"          , card.Titles.PreferedOrFirstProperty?.Text                             // TITLE
            , "@Role"           , card.Roles.PreferedOrFirstProperty?.Text                              // ROLE
            , "@OrgName"        , card.Organizations.PreferedOrFirstProperty?.Name                      // ORG                          Here we assume only 1 prop for the sake of simplicity.
            , "@OrgUnit"        , card.Organizations.PreferedOrFirstProperty?.Units?.First()            // ORG                          Here we assume only 1 prop with 1 unit value for the sake of simplicity.
            , "@Categories"     , ListToString<string>((card as ICard3)?.Categories.Select(x => ListToString<string>(x.Values, ",")), ";") // CATEGORIES  (vCard 3.0+)
            , "@Note"           , card.Notes.PreferedOrFirstProperty?.Text                              // NOTE                         Here we assume only 1 prop for the sake of simplicity.
            , "@Classification" , (card as ICard3)?.Classes.PreferedOrFirstProperty?.Text               // CLASS                        Here we assume only 1 prop for the sake of simplicity.
            , "@ClientAppName"  , clientAppName                                                         // Used to keep custom props created by this CardDAV client when updated by other CardDAV clients.
            ) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }

        // Save custom properties and parameters of this component to [card_CustomProperty] table.
        string customPropsSqlInsert;
        List<object> customPropsParamsInsert;
        if (PrepareSqlCustomPropertiesOfComponentAsync(card, uid, uid, clientAppName, out customPropsSqlInsert, out customPropsParamsInsert))
        {
            await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray());
        }
    }

    private static string ListToString<T>(IEnumerable<T> arr, string separator = ",")
    {
        if ((arr == null) || !arr.Any())
            return null;
        return string.Join<T>(separator, arr);
    }

    private static SqlParameter CreateVarBinaryParam(string parameterName, string base64)
    {
        SqlParameter param = new SqlParameter(parameterName, SqlDbType.VarBinary);
        if (string.IsNullOrEmpty(base64))
        {
            // To insert NULL to VARBINARY column, SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            param.Size      = -1;
            param.Value     = DBNull.Value;
        }
        else
        {
            byte[] content  = Convert.FromBase64String(base64);
            param.Size      = content.Length;
            param.Value     = content;
        }
        return param;
    }

    private async Task WriteEmailsAsync(DavContext context, ITextPropertyList<IEmail2> emails, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Email] (
                  [EmailId]
                , [UID]
                , [Type]
                , [Email]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IEmail2 email in emails)
        {
            valuesSql.Add(string.Format(@"(
                  @EmailId{0}
                , @UID
                , @Type{0}
                , @Email{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid emailId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@EmailId"            +i, emailId
              //, "@UID"
                , "@Type"               +i, ListToString<EmailType>(email.Types)    // EMAIL TYPE param
                , "@Email"              +i, email.Text                              // EMAIL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(email)                 // EMAIL PREF param
                , "@SortIndex"          +i, email.RawProperty.SortIndex             // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("EMAIL", email.RawProperty, emailId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAddressesAsync(DavContext context, ICardPropertyList<IAddress2> addresses, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Address] (
                  [AddressId]
                , [UID]
                , [Type]
                , [PoBox]
                , [AppartmentNumber]
                , [Street]
                , [Locality]
                , [Region]
                , [PostalCode]
                , [Country]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IAddress2 address in addresses)
        {
            valuesSql.Add(string.Format(@"(
                  @AddressId{0}
                , @UID
                , @Type{0}
                , @PoBox{0}
                , @AppartmentNumber{0}
                , @Street{0}
                , @Locality{0}
                , @Region{0}
                , @PostalCode{0}
                , @Country{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid addressId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@AddressId"            +i, addressId
              //, "@UID"
                , "@Type"               +i, ListToString<AddressType>(address.Types)    // ADR TYPE param
gma warning disable 0618
                , "@PoBox"              +i, address.PoBox.FirstOrDefault()
                , "@AppartmentNumber"   +i, address.AppartmentNumber.FirstOrDefault()
gma warning restore 0618
                , "@Street"             +i, address.Street.FirstOrDefault()
                , "@Locality"           +i, address.Locality.FirstOrDefault()
                , "@Region"             +i, address.Region.FirstOrDefault()
                , "@PostalCode"         +i, address.PostalCode.FirstOrDefault()
                , "@Country"            +i, address.Country.FirstOrDefault()
                , "@PreferenceLevel"    +i, GetPrefParameter(address)                   // ADR PREF param
                , "@SortIndex"          +i, address.RawProperty.SortIndex               // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ADR", address.RawProperty, addressId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteInstantMessengersAsync(DavContext context, ITextPropertyList<IInstantMessenger3> instantMessengers, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_InstantMessenger] (
                  [InstantMessengerId]
                , [UID]
                , [Type]
                , [InstantMessenger]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IInstantMessenger3 instantMessenger in instantMessengers)
        {
            valuesSql.Add(string.Format(@"(
                  @InstantMessengerId{0}
                , @UID
                , @Type{0}
                , @InstantMessenger{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid instantMessengerId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@InstantMessengerId" +i, instantMessengerId
              //, "@UID"
                , "@Type"               +i, ListToString<MessengerType>(instantMessenger.Types) // IMPP TYPE param
                , "@InstantMessenger"   +i, instantMessenger.Text                               // IMPP VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(instantMessenger)                  // IMPP PREF param
                , "@SortIndex"          +i, instantMessenger.RawProperty.SortIndex              // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("IMPP", instantMessenger.RawProperty, instantMessengerId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteTelephonesAsync(DavContext context, ITextPropertyList<ITelephone2> telephones, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Telephone] (
                  [TelephoneId]
                , [UID]
                , [Type]
                , [Telephone]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (ITelephone2 telephone in telephones)
        {
            valuesSql.Add(string.Format(@"(
                  @TelephoneId{0}
                , @UID
                , @Type{0}
                , @Telephone{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid telephoneId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@TelephoneId"        +i, telephoneId
              //, "@UID"
                , "@Type"               +i, ListToString<TelephoneType>(telephone.Types)// TEL TYPE param
                , "@Telephone"          +i, telephone.Text                              // TEL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(telephone)                 // TEL PREF param
                , "@SortIndex"          +i, telephone.RawProperty.SortIndex             // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("TEL", telephone.RawProperty, telephoneId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteUrlsAsync(DavContext context, ICardPropertyList<ICardUriProperty2> urls, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Url] (
                  [UrlId]
                , [UID]
                , [Type]
                , [Url]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (ICardUriProperty2 url in urls)
        {
            valuesSql.Add(string.Format(@"(
                  @UrlId{0}
                , @UID
                , @Type{0}
                , @Url{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid urlId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@UrlId"              +i, urlId
              //, "@UID"
                , "@Type"               +i, ListToString<ExtendibleEnum>(url.Types) // TEL TYPE param 
                , "@Url"                +i, url.Text                                // URL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(url)                   // URL PREF param
                , "@SortIndex"          +i, url.RawProperty.SortIndex               // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("URL", url.RawProperty, urlId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private static byte? GetPrefParameter(ICardMultiProperty prop)
    {
        ICardMultiProperty4 prop4 = prop as ICardMultiProperty4;
        if(prop4 == null)
        {
            return prop.IsPrefered ? (byte?)1 : null;
        }

        return (byte?)prop4.PreferenceLevel;
    }

    private bool PrepareSqlParamsWriteCustomProperty(string propName, IRawProperty prop, string parentId, string uid, string clientAppName, out string sql, out List<object> parameters)
    {
        sql =
            @"INSERT INTO [card_CustomProperty] (
                  [ParentId]
                , [UID]
                , [ClientAppName]
                , [PropertyName]
                , [ParameterName]
                , [Value]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        parameters = new List<object>();

        int origParamsCount = parameters.Count();

        // Custom properties are one of the following:
        //  - props that start with "X-". This is a standard-based approach to creating custom props.
        //  - props that has "." in its name. Typically "item1.X-PROP". Such props are created by iOS and OS X.
        bool isCustomProp =
            propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase)
            || propName.Contains(".");


        string paramName = null;

        // Save custom prop value.
        if (isCustomProp)
        {
            string val = prop.RawValue;
            valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex));

            parameters.AddRange(new object[] {
                              "@ParentId"       + paramIndex, parentId
                            , "@UID"            + paramIndex, uid              // Added for performance optimization purposes.
                            , "@ClientAppName"  + paramIndex, clientAppName    // Client app name that created this custom property.
                            , "@PropertyName"   + paramIndex, propName
                            , "@ParameterName"  + paramIndex, paramName        // null is inserted to mark prop value.
                            , "@Value"          + paramIndex, val
                            , "@SortIndexParam" + paramIndex, prop.SortIndex   // Property position in vCard.
                            });
            paramIndex++;
        }

        // Save parameters and their values.
        foreach (Parameter param in prop.Parameters)
        {
            paramName = param.Name;

            // For standard properties we save only custom params (that start with 'X-'). All standard params go to their fields in DB.
            // For custom properies we save all params.
            if (!isCustomProp && !paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase))
                continue;

            foreach (string value in param.Values)
            {
                string val = value;

                valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex));

                parameters.AddRange(new object[] {
                              "@ParentId"       + paramIndex, parentId
                            , "@UID"            + paramIndex, uid          // added for performance optimization purposes
                            , "@ClientAppName"  + paramIndex, clientAppName// Client app name that created this custom parameter.
                            , "@PropertyName"   + paramIndex, propName
                            , "@ParameterName"  + paramIndex, paramName
                            , "@Value"          + paramIndex, val
                            , "@SortIndexParam" + paramIndex, null         // Property position in vCard. Null is inserted for parameter values.
                            });
                paramIndex++;
            }
        }

        if (origParamsCount < parameters.Count())
        {
            sql = string.Format(sql, string.Join(", ", valuesSql.ToArray()));
            return true;
        }
        return false;
    }

    private bool PrepareSqlCustomPropertiesOfComponentAsync(IComponent component, string parentId, string uid, string clientAppName, out string sql, out List<object> parameters)
    {
        sql = "";
        parameters = new List<object>();

        // We save only single custom props here, multiple props are saved in other methods.
        string[] multiProps = new string[] { "EMAIL", "ADR", "IMPP", "TEL", "URL" };

        // Properties in IComponent.Properties are grouped by name.
        foreach (KeyValuePair<string, IList<IRawProperty>> pair in component.Properties)
        {
            if (multiProps.Contains(pair.Key.ToUpper()) || (pair.Value.Count != 1))
                continue;

            string sqlInsert;
            List<object> parametersInsert;
            if (PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, clientAppName, out sqlInsert, out parametersInsert))
            {
                sql += "; " + sqlInsert;
                parameters.AddRange(parametersInsert);
            }
        }

        return !string.IsNullOrEmpty(sql);
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        string sql = @"DELETE FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if(await Context.ExecuteNonQueryAsync(sql, 
              "@UserId"   , Context.UserId
            , "@FileName" , fileName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public async Task ReadAsync(Stream output, long startIndex, long count)
    {
        string vCardVersion = rowCardFile.Field<string>("Version");
        ICard2 card = CardFactory.CreateCard(vCardVersion);

        ReadCard(card);

        ReadEmails(card.Emails, rowsEmails);
        ReadAddresses(card.Addresses, rowsAddresses);
        ReadTelephones(card.Telephones, rowsTelephones);
        ReadUrls(card.Urls, rowsUrls);

        // IMPP is vCard 3.0 & 4.0 prop
        ICard3 card3 = card as ICard3;
        if (card3 != null)
        {
            ReadMessengers(card3.InstantMessengers, rowsInstantMessengers);
        }

        // Check if this CardDAV client application requires properties conversion.
        if (AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent))
        {
            // In case of iOS & OS X the props below must be converted to the following format:
            // item2.TEL:(222)222 - 2222
            // item2.X-ABLabel:Emergency
            AppleCardInteroperability.Denormalize(card);
        }

        new vFormatter().Serialize(output, card);
    }

    private void ReadCard(ICard2 card)
    {
        string uid = rowCardFile.Field<string>("UID");

        //UID
        card.Uid = card.CreateTextProp(uid);


        // PRODID
        card.ProductId = card.CreateTextProp("-//IT Hit//Collab Lib//EN");

        // FN
        card.FormattedNames.Add(rowCardFile.Field<string>("FormattedName"));

        // N
        card.Name = card.CreateNameProp(
            rowCardFile.Field<string>("FamilyName"),
            rowCardFile.Field<string>("GivenName"),
            rowCardFile.Field<string>("AdditionalNames"),
            rowCardFile.Field<string>("HonorificPrefix"),
            rowCardFile.Field<string>("HonorificSuffix"));

        // PHOTO
        if (!rowCardFile.IsNull("Photo"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Photo")), rowCardFile.Field<string>("PhotoMediaType"), false);
        }

        // LOGO
        if (!rowCardFile.IsNull("Logo"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Logo")), rowCardFile.Field<string>("LogoMediaType"), false);
        }

        // SOUND
        if (!rowCardFile.IsNull("Sound"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Sound")), rowCardFile.Field<string>("SoundMediaType"), false);
        }

        // BDAY
        DateTime? birthday = rowCardFile.Field<DateTime?>("Birthday");
        if (birthday != null)
        {
            card.BirthDate = card.CreateDateProp(birthday.Value, DateComponents.Date);
        }

        // REV
        DateTime? revision = rowCardFile.Field<DateTime?>("RevisionUtc");
        if (revision != null)
        {
            card.Revision = card.CreateDateProp(revision.Value);
        }

        // SORT-STRING
        string sortString = rowCardFile.Field<string>("SortString");
        if (!string.IsNullOrEmpty(sortString))
        {
            ITextProperty2 propSortString = card.CreateProperty<ITextProperty2>();
            propSortString.Text = sortString;
            card.SortString = propSortString;
        }

        // TZ
        string timeZone = rowCardFile.Field<string>("TimeZone");
        if (!string.IsNullOrEmpty(timeZone))
        {
            card.TimeZones.Add(timeZone);
        }

        // GEO

        // TITLE
        string title = rowCardFile.Field<string>("Title");
        if (!string.IsNullOrEmpty(title))
        {
            card.Titles.Add(title);
        }

        // ROLE
        string role = rowCardFile.Field<string>("Role");
        if (!string.IsNullOrEmpty(role))
        {
            card.Roles.Add(role);
        }

        // ORG
        string orgName = rowCardFile.Field<string>("OrgName");
        string orgUnit = rowCardFile.Field<string>("OrgUnit");
        if (!string.IsNullOrEmpty(orgName) || !string.IsNullOrEmpty(orgUnit))
        {
            IOrganization2 propOrg = card.Organizations.CreateProperty();
            propOrg.Name = orgName;
            propOrg.Units = new[] { orgUnit };
            card.Organizations.Add(propOrg);
        }

        // NOTE
        string note = rowCardFile.Field<string>("Note");
        if (!string.IsNullOrEmpty(note))
        {
            card.Notes.Add(note);
        }

        // vCard v3.0 & v4.0 props
        if (card is ICard3)
        {
            ICard3 card3 = card as ICard3;

            // NICKNAME
            string nickname = rowCardFile.Field<string>("Nickname");
            if (!string.IsNullOrEmpty(nickname))
            {
                INickname3 propNickname = card3.NickNames.CreateProperty();
                propNickname.Values = new[] { nickname };
                card3.NickNames.Add(propNickname);
            }

            // CATEGORIES
            string categories = rowCardFile.Field<string>("Categories");
            if (!string.IsNullOrEmpty(categories))
            {
                string[] aCategories = categories.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (string categoryList in aCategories)
                {
                    ICategories3 catProp = card3.Categories.CreateProperty();
                    catProp.Values = categoryList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    card3.Categories.Add(catProp);
                }
            }

            // CLASS
            string classification = rowCardFile.Field<string>("Classification");
            if (!string.IsNullOrEmpty(classification))
            {
                card3.Classes.Add(classification);
            }
        }

        // vCard v4.0 props
        if (card is ICard4)
        {
            ICard4 card4 = card as ICard4;

            // KIND
            string kind = rowCardFile.Field<string>("Kind");
            if (kind != null)
            {
                IKind4 propKind = card4.CreateProperty<IKind4>();
                propKind.Text = kind;
                card4.Kind = propKind;
            }

            // ANNIVERSARY
            DateTime? anniversary = rowCardFile.Field<DateTime?>("Anniversary");
            if (anniversary != null)
            {
                IAnniversary4 propAnniversary = card4.CreateProperty<IAnniversary4>();
                propAnniversary.Value = new Date(anniversary.Value, DateComponents.Month | DateComponents.Date);
                card4.Anniversary = propAnniversary;
            }
            
            
            // GENDER
            string gender = rowCardFile.Field<string>("Gender");
            if (!string.IsNullOrEmpty(gender))
            {
                IGender4 propGender = card4.CreateProperty<IGender4>();
                propGender.Text = gender;
                card4.Gender = propGender;
            }
            
            // LANG
            string language = rowCardFile.Field<string>("Language");
            if (!string.IsNullOrEmpty(language))
            {
                card4.ContactLanguages.Add(language);
            }
        }


        // Get custom properties and custom parameters
        IEnumerable<DataRow> rowsCardCustomProperties = rowsCustomProperties.Where(x => x.Field<string>("ParentId") == uid);
        ReadCustomProperties(card, rowsCardCustomProperties);
    }


    private void ReadEmails(ITextPropertyList<IEmail2> emails, IEnumerable<DataRow> rowsEmails)
    {
        foreach (DataRow rowEmail in rowsEmails)
        {
            IEmail2 email = emails.CreateProperty();
            email.Text  = rowEmail.Field<string>("Email");                              // EMAIL value
            email.Types = ParseType<EmailType>(rowEmail.Field<string>("Type"));         // TYPE param
            SetPrefParameter(email, rowEmail.Field<byte?>("PreferenceLevel"));          // PREF param
            email.RawProperty.SortIndex = rowEmail.Field<int>("SortIndex");             // Property position in vCard.
            AddParamValues(rowEmail.Field<Guid>("EmailId"), email.RawProperty);         // Add custom parameters from [card_CustomProperty] table.
            emails.Add(email);
        }
    }

    private void ReadAddresses(ICardPropertyList<IAddress2> addresses, IEnumerable<DataRow> rowsAddresses)
    {
        foreach (DataRow rowAddress in rowsAddresses)
        {
            IAddress2 address = addresses.CreateProperty();
            address.SetAddress(
                new[] { rowAddress.Field<string>("PoBox") },
                new[] { rowAddress.Field<string>("AppartmentNumber")},
                new[] { rowAddress.Field<string>("Street")},
                new[] { rowAddress.Field<string>("Locality")},
                new[] { rowAddress.Field<string>("Region")},
                new[] { rowAddress.Field<string>("PostalCode")},
                new[] { rowAddress.Field<string>("Country")},
                ParseType<AddressType>(rowAddress.Field<string>("Type")));              // ADR value and TYPE param                
            SetPrefParameter(address, rowAddress.Field<byte?>("PreferenceLevel"));      // PREF param
            address.RawProperty.SortIndex = rowAddress.Field<int>("SortIndex");         // Property position in vCard.
            AddParamValues(rowAddress.Field<Guid>("AddressId"), address.RawProperty);   // Add custom parameters from [card_CustomProperty] table.
            addresses.Add(address);
        }
    }

    private void ReadMessengers(ITextPropertyList<IInstantMessenger3> messengers, IEnumerable<DataRow> rowsMessengers)
    {
        foreach (DataRow rowMessenger in rowsMessengers)
        {
            IInstantMessenger3 messenger = messengers.CreateProperty();
            messenger.Text  = rowMessenger.Field<string>("InstantMessenger");                       // IMPP value
            messenger.Types = ParseType<MessengerType>(rowMessenger.Field<string>("Type"));         // TYPE param
            SetPrefParameter(messenger, rowMessenger.Field<byte?>("PreferenceLevel"));              // PREF param
            messenger.RawProperty.SortIndex = rowMessenger.Field<int>("SortIndex");                 // Property position in vCard.
            AddParamValues(rowMessenger.Field<Guid>("InstantMessengerId"), messenger.RawProperty);  // Add custom parameters from [card_CustomProperty] table.
            messengers.Add(messenger);
        }
    }

    private void ReadTelephones(ITextPropertyList<ITelephone2> telephones, IEnumerable<DataRow> rowsTelephones)
    {
        foreach (DataRow rowTelephone in rowsTelephones)
        {
            ITelephone2 telephone = telephones.CreateProperty();
            telephone.Text  = rowTelephone.Field<string>("Telephone");                      // TEL value
            telephone.Types = ParseType<TelephoneType>(rowTelephone.Field<string>("Type")); // TYPE param
            SetPrefParameter(telephone, rowTelephone.Field<byte?>("PreferenceLevel"));      // PREF param
            telephone.RawProperty.SortIndex = rowTelephone.Field<int>("SortIndex");         // Property position in vCard.
            AddParamValues(rowTelephone.Field<Guid>("TelephoneId"), telephone.RawProperty); // Add custom parameters from [card_CustomProperty] table.
            telephones.Add(telephone);
        }
    }

    private void ReadUrls(ICardPropertyList<ICardUriProperty2> urls, IEnumerable<DataRow> rowsUrls)
    {
        foreach (DataRow rowUrl in rowsUrls)
        {
            ICardUriProperty2 url = urls.CreateProperty();
            url.Text  = rowUrl.Field<string>("Url");                                    // URL value
            url.Types = ParseType<ExtendibleEnum>(rowUrl.Field<string>("Type"));        // TYPE param
            SetPrefParameter(url, rowUrl.Field<byte?>("PreferenceLevel"));              // PREF param
            url.RawProperty.SortIndex = rowUrl.Field<int>("SortIndex");                 // Property position in vCard.
            AddParamValues(rowUrl.Field<Guid>("UrlId"), url.RawProperty);               // Add custom parameters from [card_CustomProperty] table.
            urls.Add(url);
        }
    }

    private static void SetPrefParameter(ICardMultiProperty prop, byte? preferenceLevel)
    {
        if (preferenceLevel != null)
        {
            ICardMultiProperty4 prop4 = prop as ICardMultiProperty4;
            if (prop4 == null)
            {
                // vCard 2.1 & 3.0
                prop.IsPrefered = true;
            }
            else
            {
                // vCard 4.0
                prop4.PreferenceLevel = preferenceLevel.Value;
            }
        }
    }

    private static T[] ParseType<T>(string typesList) where T : ExtendibleEnum, new()
    {
        if (!string.IsNullOrEmpty(typesList))
        {
            string[] aStrTypes = typesList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            return aStrTypes.Select(x => StringToEnum<T>(x)).ToArray();
        }

        return new T[] { };
    }

    private static void ReadCustomProperties(IComponent component, IEnumerable<DataRow> rowsCustomProperies)
    {
        foreach (DataRow rowCustomProperty in rowsCustomProperies)
        {
            string propertyName = rowCustomProperty.Field<string>("PropertyName");

            IRawProperty prop;
            if (!component.Properties.ContainsKey(propertyName))
            {
                prop = component.CreateRawProperty();
                component.AddProperty(propertyName, prop);
            }
            else
            {
                prop = component.Properties[propertyName].FirstOrDefault();
            }

            string paramName = rowCustomProperty.Field<string>("ParameterName");
            string value = rowCustomProperty.Field<string>("Value");
            if (paramName == null)
            {
                // If ParameterName is null the Value contains property value
                prop.RawValue = value;
                prop.SortIndex = rowCustomProperty.Field<int>("SortIndex"); // Property position in vCard.
            }
            else
            {
                prop.Parameters.Add(new Parameter(paramName, value));
            }
        }
    }

    private void AddParamValues(Guid propertyId, IRawProperty prop)
    {
        IEnumerable<DataRow> rowsCustomParams = rowsCustomProperties.Where(x => x.Field<string>("ParentId") == propertyId.ToString());
        foreach (DataRow rowCustomParam in rowsCustomParams)
        {
            string paramName = rowCustomParam.Field<string>("ParameterName");
            string paramValue = rowCustomParam.Field<string>("Value");
            prop.Parameters.Add(new Parameter(paramName, paramValue));
        }
    }

    private static T StringToEnum<T>(string value) where T : ExtendibleEnum, new()
    {
        if (value == null)
            return null;

        T res;
        if (!ExtendibleEnum.TryFromString<T>(value, out res))
        {
            // If no matching value is found create new ExtendibleEnum or type T 
            // with specified string value and default numeric value (-1).
            res = new T();
            res.Name = value;
        }

        return res;
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class CardFile
    Inherits DavHierarchyItem
    Implements ICardFileAsync

    Public Shared Extension As String = ".vcf"

    Public Shared Async Function LoadByAddressbookFolderIdAsync(context As DavContext, addressbookFolderId As Guid, propsToLoad As PropsToLoad) As Task(Of IEnumerable(Of ICardFileAsync))
        ' propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CardDAV clients
        ' [Summary] is typically not required in GetChildren call, 
        ' they are extracted for demo purposes only, to be displayed in Ajax File Browser.
        ' propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.
        If propsToLoad <> PropsToLoad.Minimum Then Throw New NotImplementedException("LoadByAddressbookFolderIdAsync is implemented only with PropsToLoad.Minimum.")
        Dim sql As String = "SELECT * FROM [card_CardFile] 
                       WHERE [AddressbookFolderId] = @AddressbookFolderId
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        'sql = string.Format(sql, GetScPropsToLoad(propsToLoad));
        Return Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@AddressbookFolderId", addressbookFolderId)
    End Function

    Public Shared Async Function LoadByFileNamesAsync(context As DavContext, fileNames As IEnumerable(Of String), propsToLoad As PropsToLoad) As Task(Of IEnumerable(Of ICardFileAsync))
        ' Get IN clause part with list of file UIDs for SELECT.
        Dim selectIn As String = String.Join(", ", fileNames.Select(Function(a) String.Format("'{0}'", a)).ToArray())
        Dim sql As String = "SELECT * FROM [card_CardFile] 
                       WHERE [FileName] IN ({0})
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)"
        If propsToLoad = PropsToLoad.All Then
            sql += ";SELECT * FROM [card_Email]             WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Address]           WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_InstantMessenger]  WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Telephone]         WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Url]               WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_CustomProperty]    WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0})) AND [ClientAppName] = @ClientAppName"
        End If

        sql = String.Format(sql, selectIn)
        Return Await LoadAsync(context, sql,
                              "@UserId", context.UserId,
                              "@ClientAppName", AppleCardInteroperability.GetClientAppName(context.Request.UserAgent))
    End Function

    Private Shared Async Function LoadAsync(context As DavContext, sql As String, ParamArray prms As Object()) As Task(Of IEnumerable(Of ICardFileAsync))
        Dim items As IList(Of ICardFileAsync) = New List(Of ICardFileAsync)()
        Dim stopWatch As Stopwatch = Stopwatch.StartNew()
        Using reader As SqlDataReader = Await context.ExecuteReaderAsync(sql, prms)
            Dim cards As DataTable = New DataTable()
            cards.Load(reader)
            Dim emails As DataTable = New DataTable()
            If Not reader.IsClosed Then emails.Load(reader)
            Dim addresses As DataTable = New DataTable()
            If Not reader.IsClosed Then addresses.Load(reader)
            Dim instantMessengers As DataTable = New DataTable()
            If Not reader.IsClosed Then instantMessengers.Load(reader)
            Dim telephones As DataTable = New DataTable()
            If Not reader.IsClosed Then telephones.Load(reader)
            Dim urls As DataTable = New DataTable()
            If Not reader.IsClosed Then urls.Load(reader)
            Dim cardCustomProperties As DataTable = New DataTable()
            If Not reader.IsClosed Then cardCustomProperties.Load(reader)
            stopWatch.Stop()
            context.Engine.Logger.LogDebug(String.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds))
            For Each rowCardFile As DataRow In cards.Rows
                Dim rowsEmails As DataRow() = New DataRow(-1) {}
                Dim rowsAddresses As DataRow() = New DataRow(-1) {}
                Dim rowsInstantMessengers As DataRow() = New DataRow(-1) {}
                Dim rowsTelephones As DataRow() = New DataRow(-1) {}
                Dim rowsUrls As DataRow() = New DataRow(-1) {}
                Dim rowsCustomProperties As DataRow() = New DataRow(-1) {}
                Dim uid As String = rowCardFile.Field(Of String)("UID")
                If emails.Columns("UID") IsNot Nothing Then
                    Dim filter As String = String.Format("UID = '{0}'", uid)
                    rowsEmails = emails.Select(filter)
                    rowsAddresses = addresses.Select(filter)
                    rowsInstantMessengers = instantMessengers.Select(filter)
                    rowsTelephones = telephones.Select(filter)
                    rowsUrls = urls.Select(filter)
                    rowsCustomProperties = cardCustomProperties.Select(filter)
                End If

                Dim fileName As String = rowCardFile.Field(Of String)("FileName")
                items.Add(New CardFile(context, fileName, rowCardFile, rowsEmails, rowsAddresses, rowsInstantMessengers, rowsTelephones, rowsUrls, rowsCustomProperties))
            Next
        End Using

        Return items
    End Function

    Public Shared Function CreateCardFile(context As DavContext, addressbookFolderId As Guid, fileName As String) As CardFile
        Dim cardFile As CardFile = New CardFile(context, fileName, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing)
        cardFile.addressbookFolderId = addressbookFolderId
        Return cardFile
    End Function

    Private ReadOnly fileName As String = Nothing

    Private ReadOnly rowCardFile As DataRow = Nothing

    Private ReadOnly rowsEmails As DataRow() = Nothing

    Private ReadOnly rowsAddresses As DataRow() = Nothing

    Private ReadOnly rowsInstantMessengers As DataRow() = Nothing

    Private ReadOnly rowsTelephones As DataRow() = Nothing

    Private ReadOnly rowsUrls As DataRow() = Nothing

    Private ReadOnly rowsCustomProperties As DataRow() = Nothing

    Private ReadOnly Property isNew As Boolean
        Get
            Return addressbookFolderId <> Guid.Empty
        End Get
    End Property

    Private paramIndex As Integer = 0

    Private addressbookFolderId As Guid = Guid.Empty

    Public Overrides ReadOnly Property Name As String Implements IHierarchyItemBaseAsync.Name
        Get
            Return rowCardFile.Field(Of String)("FormattedName")
        End Get
    End Property

    Public Overrides ReadOnly Property Path As String Implements IHierarchyItemBaseAsync.Path
        Get
            Dim addressbookFolderId As Guid = rowCardFile.Field(Of Guid)("AddressbookFolderId")
            Dim fileName As String = rowCardFile.Field(Of String)("FileName")
            Return String.Format("{0}{1}/{2}{3}", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId, fileName, Extension)
        End Get
    End Property

    Public ReadOnly Property Etag As String Implements IContentAsync.Etag
        Get
            Dim bETag As Byte() = rowCardFile.Field(Of Byte())("ETag")
            Return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString()
        End Get
    End Property

    Public Overrides ReadOnly Property Created As DateTime Implements IHierarchyItemBaseAsync.Created
        Get
            Return rowCardFile.Field(Of DateTime)("CreatedUtc")
        End Get
    End Property

    Public Overrides ReadOnly Property Modified As DateTime Implements IHierarchyItemBaseAsync.Modified
        Get
            Return rowCardFile.Field(Of DateTime)("ModifiedUtc")
        End Get
    End Property

    Public ReadOnly Property ContentLength As Long Implements IContentAsync.ContentLength
        Get
            Return -1
        End Get
    End Property

    Public ReadOnly Property ContentType As String Implements IContentAsync.ContentType
        Get
            Return "text/vcard"
        End Get
    End Property

    Private Sub New(context As DavContext, fileName As String,
                   rowCardFile As DataRow, rowsEmails As DataRow(), rowsAddresses As DataRow(), rowsInstantMessengers As DataRow(),
                   rowsTelephones As DataRow(), rowsUrls As DataRow(), rowsCustomProperties As DataRow())
        MyBase.New(context)
        Me.fileName = fileName
        Me.rowCardFile = rowCardFile
        Me.rowsEmails = rowsEmails
        Me.rowsAddresses = rowsAddresses
        Me.rowsInstantMessengers = rowsInstantMessengers
        Me.rowsTelephones = rowsTelephones
        Me.rowsUrls = rowsUrls
        Me.rowsCustomProperties = rowsCustomProperties
    End Sub

    Public Async Function WriteAsync(stream As Stream, contentType As String, startIndex As Long, totalFileSize As Long) As Task(Of Boolean) Implements IContentAsync.WriteAsync
        'Set timeout to maximum value to be able to upload large card files.
        System.Web.HttpContext.Current.Server.ScriptTimeout = Integer.MaxValue
        Dim vCard As String
        Using reader As StreamReader = New StreamReader(stream)
            vCard = Await reader.ReadToEndAsync()
        End Using

        ' Typically the stream contains a single vCard.
        Dim cards As IEnumerable(Of IComponent) = New vFormatter().Deserialize(vCard)
        Dim card As ICard2 = TryCast(cards.First(), ICard2)
        ' Card file UID which is equal to file name (??).
        ' The type is used to uniquely identify the object that the vCard represents. The "uuid" URN namespace defined in 
        ' [RFC4122] is particularly well-suited to this task, but other URI schemes MAY be used.
        Dim uid As String = If(card.Uid?.Text, "UID:urn:uuid:" & Guid.NewGuid().ToString())
        ' Check if this CardDAV client application requires properties conversion.
        If AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent) Then
            AppleCardInteroperability.Normalize(card)
        End If

        ' The client app name is stored in DB to update and extract only custom props created by the client making a request.
        Dim clientAppName As String = AppleCardInteroperability.GetClientAppName(Context.Request.UserAgent)
        ' Save data to [card_CardFile] table.
        Await WriteCardFileAsync(Context, card, addressbookFolderId, isNew, uid, clientAppName)
        ' Save emails.
        Await WriteEmailsAsync(Context, card.Emails, uid, clientAppName)
        ' Save addresses.
        Await WriteAddressesAsync(Context, card.Addresses, uid, clientAppName)
        ' Save telephones.
        Await WriteTelephonesAsync(Context, card.Telephones, uid, clientAppName)
        ' Save URLs
        Await WriteUrlsAsync(Context, card.Urls, uid, clientAppName)
        ' Save instant messengers. vCard 3.0+ only
        Dim card3 As ICard3 = TryCast(card, ICard3)
        If card3 IsNot Nothing Then
            Await WriteInstantMessengersAsync(Context, card3.InstantMessengers, uid, clientAppName)
        End If

        Return True
    End Function

    Private Async Function WriteCardFileAsync(context As DavContext, card As ICard2, addressbookFolderId As Guid, isNew As Boolean, uid As String, clientAppName As String) As Task
        Dim sql As String
        If isNew Then
            sql = "IF EXISTS (SELECT 1 FROM [card_Access] WHERE [AddressbookFolderId]=@AddressbookFolderId AND [UserId]=@UserId AND [Write]=1)
                  INSERT INTO [card_CardFile] (
                      [UID]
                    , [AddressbookFolderId]
                 , [FileName]
                 , [Version]
                 , [Product]
                 , [FormattedName]
                 , [FamilyName]
                 , [GivenName]
                 , [AdditionalNames]
                 , [HonorificPrefix]
                 , [HonorificSuffix]
                 , [Kind]
                 , [Nickname]
                 , [Photo]
                 , [PhotoMediaType]
                 , [Logo]
                 , [LogoMediaType]
                 , [Sound]
                 , [SoundMediaType]
                 , [Birthday]
                 , [Anniversary]
                 , [Gender]
                 , [RevisionUtc]
                 , [SortString]
                 , [Language]
                 , [TimeZone]
                 , [Geo]
                 , [Title]
                 , [Role]
                 , [OrgName]
                 , [OrgUnit]
                 , [Categories]
                 , [Note]
                 , [Classification]
                ) VALUES (
                      @UID
                    , @AddressbookFolderId
                    , @FileName
                    , @Version
                    , @Product
                 , @FormattedName
                 , @FamilyName
                 , @GivenName
                 , @AdditionalNames
                 , @HonorificPrefix
                 , @HonorificSuffix
                 , @Kind
                 , @Nickname
                 , @Photo
                 , @PhotoMediaType
                 , @Logo
                 , @LogoMediaType
                 , @Sound
                 , @SoundMediaType
                 , @Birthday
                 , @Anniversary
                 , @Gender
                 , @RevisionUtc
                 , @SortString
                 , @Language
                 , @TimeZone
                 , @Geo
                 , @Title
                 , @Role
                 , @OrgName
                 , @OrgUnit
                 , @Categories
                 , @Note
                 , @Classification
                )"
        Else
            ' We can only update record in [card_CardFile] table.
            ' There is no way to update [card_Email], [card_Address], [card_InstantMessenger], [card_Telephone] and [card_Url]
            ' tables for existing card, we must delete all records for this UID and recreate.
            ' We can keep custom props in [card_CustomProperty] table if they were created by a different CardDAV client.
            ' [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql = "IF EXISTS (SELECT 1 FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1))
                  BEGIN
                      UPDATE [card_CardFile] SET 
                          [ModifiedUtc]     = @ModifiedUtc
                     , [Version]         = @Version
                     , [Product]         = @Product
                     , [FormattedName]   = @FormattedName
                     , [FamilyName]      = @FamilyName
                     , [GivenName]       = @GivenName
                     , [AdditionalNames] = @AdditionalNames
                     , [HonorificPrefix] = @HonorificPrefix
                     , [HonorificSuffix] = @HonorificSuffix
                     , [Kind]            = @Kind
                     , [Nickname]        = @Nickname
                     , [Photo]           = @Photo
                     , [PhotoMediaType]  = @PhotoMediaType
                     , [Logo]            = @Logo
                     , [LogoMediaType]   = @LogoMediaType
                     , [Sound]           = @Sound
                     , [SoundMediaType]  = @SoundMediaType
                     , [Birthday]        = @Birthday
                     , [Anniversary]     = @Anniversary
                     , [Gender]          = @Gender
                     , [RevisionUtc]     = @RevisionUtc
                     , [SortString]      = @SortString
                     , [Language]        = @Language
                     , [TimeZone]        = @TimeZone
                     , [Geo]             = @Geo
                     , [Title]           = @Title
                     , [Role]            = @Role
                     , [OrgName]         = @OrgName
                     , [OrgUnit]         = @OrgUnit
                     , [Categories]      = @Categories
                     , [Note]            = @Note
                     , [Classification]  = @Classification
                      WHERE 
                        [UID] = @UID
                
                      ; DELETE FROM [card_Email]              WHERE [UID] = @UID
                      ; DELETE FROM [card_Address]            WHERE [UID] = @UID
                      ; DELETE FROM [card_InstantMessenger]   WHERE [UID] = @UID
                      ; DELETE FROM [card_Telephone]          WHERE [UID] = @UID
                      ; DELETE FROM [card_Url]                WHERE [UID] = @UID
                      ; DELETE FROM [card_CustomProperty]     WHERE [UID] = @UID AND (([ClientAppName] = @ClientAppName) OR ([ParentId] != [UID]) OR ([ClientAppName] IS NULL))
                  END"
        End If

        ' [ClientAppName] = @ClientAppName -> delete all custom props created by this client.
        ' [ParentId] != [UID]              -> delete all custom params from multiple props: EMAIL, ADR, TEL, IMPP. Keep custom params for any single props in [card_Card].
        ' [ClientAppName] IS NULL          -> delete all custom props created by some unknown CardDAV client.
        If Await context.ExecuteNonQueryAsync(sql,
                                             "@UID", uid,                                                                   ' UID
                                             "UserId", context.UserId,
                                             "@AddressbookFolderId", addressbookFolderId,                                               ' used only when inserting
                                             "@FileName", fileName,                                                              ' In case of CardDAV a file name is sypically a GUID, but it is different from UID.
                                             "@ModifiedUtc", DateTime.UtcNow,
                                             "@Version", card.Version.Text,                                                     ' VERSION
                                             "@Product", card.ProductId?.Text,                                                  ' PRODID
                                             "@FormattedName", card.FormattedNames.PreferedOrFirstProperty.Text,                      ' FN                           Here we assume only 1 prop for the sake of simplicity.
                                             "@FamilyName", card.Name.FamilyName,                                                  ' N
                                             "@GivenName", card.Name.GivenName,                                                   ' N
                                             "@AdditionalNames", card.Name.AdditionalNamesList,                                         ' N
                                             "@HonorificPrefix", card.Name.HonorificPrefix,                                             ' N
                                             "@HonorificSuffix", card.Name.HonorificSuffix,                                             ' N
                                             "@Kind", TryCast(card, ICard4)?.Kind?.Text,                                          ' KIND         (vCard 4.0)
                                             "@Nickname", TryCast(card, ICard3)?.NickNames.PreferedOrFirstProperty?.Values.First(),   ' NICKNAME     (vCard 3.0+)    Here we assume only 1 prop with 1 value for the sake of simplicity.
                                             CreateVarBinaryParam("@Photo", card.Photos.PreferedOrFirstProperty?.Base64Data),           ' PHOTO                        Here we assume only 1 prop for the sake of simplicity.
                                             "@PhotoMediaType", card.Photos.PreferedOrFirstProperty?.MediaType,                        ' PHOTO TYPE param
                                             CreateVarBinaryParam("@Logo", card.Logos.PreferedOrFirstProperty?.Base64Data),            ' LOGO                         Here we assume only 1 prop for the sake of simplicity.
                                             "@LogoMediaType", card.Logos.PreferedOrFirstProperty?.MediaType,                         ' LOGO  TYPE param
                                             CreateVarBinaryParam("@Sound", card.Sounds.PreferedOrFirstProperty?.Base64Data),           ' SOUND                        Here we assume only 1 prop for the sake of simplicity.
                                             "@SoundMediaType", card.Sounds.PreferedOrFirstProperty?.MediaType,                        ' SOUND TYPE param
                                             New SqlParameter("@Birthday", If(card.BirthDate?.Value?.DateVal, TryCast(DBNull.Value, Object))) With {.SqlDbType = SqlDbType.DateTime2}, New SqlParameter("@Anniversary", If(TryCast(card, ICard4)?.Anniversary?.Value?.DateVal, TryCast(DBNull.Value, Object))) With {.SqlDbType = SqlDbType.DateTime2}, "@Gender", TryCast(card, ICard4)?.Gender?.Sex,                                         ' GENDER       (vCard 4.0)
                                             "@RevisionUtc", card.Revision?.Value.DateVal,                                          ' REV
                                             "@SortString", card.SortString?.Text,                                                 ' SORT-STRING
                                             "@Language", TryCast(card, ICard4)?.ContactLanguages.PreferedOrFirstProperty?.Text,      ' LANG         (vCard 4.0)     Here we assume only 1 prop for the sake of simplicity.
                                             "@TimeZone", card.TimeZones.PreferedOrFirstProperty?.Text,                          ' TZ
                                             "@Geo", Nothing, "@Title", card.Titles.PreferedOrFirstProperty?.Text,                             ' TITLE
                                             "@Role", card.Roles.PreferedOrFirstProperty?.Text,                              ' ROLE
                                             "@OrgName", card.Organizations.PreferedOrFirstProperty?.Name,                      ' ORG                          Here we assume only 1 prop for the sake of simplicity.
                                             "@OrgUnit", card.Organizations.PreferedOrFirstProperty?.Units?.First(),            ' ORG                          Here we assume only 1 prop with 1 unit value for the sake of simplicity.
                                             "@Categories", ListToString(Of String)(TryCast(card, ICard3)?.Categories.Select(Function(x) ListToString(Of String)(x.Values, ",")), ";"), ' CATEGORIES  (vCard 3.0+)
                                             "@Note", card.Notes.PreferedOrFirstProperty?.Text,                              ' NOTE                         Here we assume only 1 prop for the sake of simplicity.
                                             "@Classification", TryCast(card, ICard3)?.Classes.PreferedOrFirstProperty?.Text,               ' CLASS                        Here we assume only 1 prop for the sake of simplicity.
                                             "@ClientAppName", clientAppName                                                         ' Used to keep custom props created by this CardDAV client when updated by other CardDAV clients.
                                             ) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If

        ' Save custom properties and parameters of this component to [card_CustomProperty] table.
        Dim customPropsSqlInsert As String
        Dim customPropsParamsInsert As List(Of Object)
        If PrepareSqlCustomPropertiesOfComponentAsync(card, uid, uid, clientAppName, customPropsSqlInsert, customPropsParamsInsert) Then
            Await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray())
        End If
    End Function

    Private Shared Function ListToString(Of T)(arr As IEnumerable(Of T), Optional separator As String = ",") As String
        If(arr Is Nothing) OrElse Not arr.Any() Then Return Nothing
        Return String.Join(Of T)(separator, arr)
    End Function

    Private Shared Function CreateVarBinaryParam(parameterName As String, base64 As String) As SqlParameter
        Dim param As SqlParameter = New SqlParameter(parameterName, SqlDbType.VarBinary)
        If String.IsNullOrEmpty(base64) Then
            ' To insert NULL to VARBINARY column, SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            param.Size = -1
            param.Value = DBNull.Value
        Else
            Dim content As Byte() = Convert.FromBase64String(base64)
            param.Size = content.Length
            param.Value = content
        End If

        Return param
    End Function

    Private Async Function WriteEmailsAsync(context As DavContext, emails As ITextPropertyList(Of IEmail2), uid As String, clientAppName As String) As Task
        Dim sql As String = "INSERT INTO [card_Email] (
                  [EmailId]
                , [UID]
                , [Type]
                , [Email]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each email As IEmail2 In emails
            valuesSql.Add(String.Format("(
                  @EmailId{0}
                , @UID
                , @Type{0}
                , @Email{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i))
            Dim emailId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@EmailId" & i, emailId,
                                             "@Type" & i, ListToString(Of EmailType)(email.Types),    ' EMAIL TYPE param
                                             "@Email" & i, email.Text,                              ' EMAIL VALUE
                                             "@PreferenceLevel" & i, GetPrefParameter(email),                 ' EMAIL PREF param
                                             "@SortIndex" & i, email.RawProperty.SortIndex             ' Property position in vCard.
                                             })
            ' Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("EMAIL", email.RawProperty, emailId.ToString(), uid, clientAppName, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteAddressesAsync(context As DavContext, addresses As ICardPropertyList(Of IAddress2), uid As String, clientAppName As String) As Task
        Dim sql As String = "INSERT INTO [card_Address] (
                  [AddressId]
                , [UID]
                , [Type]
                , [PoBox]
                , [AppartmentNumber]
                , [Street]
                , [Locality]
                , [Region]
                , [PostalCode]
                , [Country]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each address As IAddress2 In addresses
            valuesSql.Add(String.Format("(
                  @AddressId{0}
                , @UID
                , @Type{0}
                , @PoBox{0}
                , @AppartmentNumber{0}
                , @Street{0}
                , @Locality{0}
                , @Region{0}
                , @PostalCode{0}
                , @Country{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i))
            Dim addressId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@AddressId" & i, addressId,
                                             "@Type" & i, ListToString(Of AddressType)(address.Types),    ' ADR TYPE param
                                             "@PoBox" & i, address.PoBox.FirstOrDefault(),
                                             "@AppartmentNumber" & i, address.AppartmentNumber.FirstOrDefault(),
                                             "@Street" & i, address.Street.FirstOrDefault(),
                                             "@Locality" & i, address.Locality.FirstOrDefault(),
                                             "@Region" & i, address.Region.FirstOrDefault(),
                                             "@PostalCode" & i, address.PostalCode.FirstOrDefault(),
                                             "@Country" & i, address.Country.FirstOrDefault(),
                                             "@PreferenceLevel" & i, GetPrefParameter(address),                   ' ADR PREF param
                                             "@SortIndex" & i, address.RawProperty.SortIndex               ' Property position in vCard.
                                             })
            ' Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("ADR", address.RawProperty, addressId.ToString(), uid, clientAppName, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteInstantMessengersAsync(context As DavContext, instantMessengers As ITextPropertyList(Of IInstantMessenger3), uid As String, clientAppName As String) As Task
        Dim sql As String = "INSERT INTO [card_InstantMessenger] (
                  [InstantMessengerId]
                , [UID]
                , [Type]
                , [InstantMessenger]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each instantMessenger As IInstantMessenger3 In instantMessengers
            valuesSql.Add(String.Format("(
                  @InstantMessengerId{0}
                , @UID
                , @Type{0}
                , @InstantMessenger{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i))
            Dim instantMessengerId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@InstantMessengerId" & i, instantMessengerId,
                                             "@Type" & i, ListToString(Of MessengerType)(instantMessenger.Types), ' IMPP TYPE param
                                             "@InstantMessenger" & i, instantMessenger.Text,                               ' IMPP VALUE
                                             "@PreferenceLevel" & i, GetPrefParameter(instantMessenger),                  ' IMPP PREF param
                                             "@SortIndex" & i, instantMessenger.RawProperty.SortIndex              ' Property position in vCard.
                                             })
            ' Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("IMPP", instantMessenger.RawProperty, instantMessengerId.ToString(), uid, clientAppName, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteTelephonesAsync(context As DavContext, telephones As ITextPropertyList(Of ITelephone2), uid As String, clientAppName As String) As Task
        Dim sql As String = "INSERT INTO [card_Telephone] (
                  [TelephoneId]
                , [UID]
                , [Type]
                , [Telephone]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each telephone As ITelephone2 In telephones
            valuesSql.Add(String.Format("(
                  @TelephoneId{0}
                , @UID
                , @Type{0}
                , @Telephone{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i))
            Dim telephoneId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@TelephoneId" & i, telephoneId,
                                             "@Type" & i, ListToString(Of TelephoneType)(telephone.Types),' TEL TYPE param
                                             "@Telephone" & i, telephone.Text,                              ' TEL VALUE
                                             "@PreferenceLevel" & i, GetPrefParameter(telephone),                 ' TEL PREF param
                                             "@SortIndex" & i, telephone.RawProperty.SortIndex             ' Property position in vCard.
                                             })
            ' Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("TEL", telephone.RawProperty, telephoneId.ToString(), uid, clientAppName, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Async Function WriteUrlsAsync(context As DavContext, urls As ICardPropertyList(Of ICardUriProperty2), uid As String, clientAppName As String) As Task
        Dim sql As String = "INSERT INTO [card_Url] (
                  [UrlId]
                , [UID]
                , [Type]
                , [Url]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        Dim parameters As List(Of Object) = New List(Of Object)(New Object() {"@UID", uid
                                                                             })
        Dim i As Integer = 0
        For Each url As ICardUriProperty2 In urls
            valuesSql.Add(String.Format("(
                  @UrlId{0}
                , @UID
                , @Type{0}
                , @Url{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i))
            Dim urlId As Guid = Guid.NewGuid()
            parameters.AddRange(New Object() {"@UrlId" & i, urlId,
                                             "@Type" & i, ListToString(Of ExtendibleEnum)(url.Types), ' TEL TYPE param 
                                             "@Url" & i, url.Text,                                ' URL VALUE
                                             "@PreferenceLevel" & i, GetPrefParameter(url),                   ' URL PREF param
                                             "@SortIndex" & i, url.RawProperty.SortIndex               ' Property position in vCard.
                                             })
            ' Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            Dim customPropSqlInsert As String
            Dim customPropParametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty("URL", url.RawProperty, urlId.ToString(), uid, clientAppName, customPropSqlInsert, customPropParametersInsert) Then
                sql += "; " & customPropSqlInsert
                parameters.AddRange(customPropParametersInsert)
            End If

            i += 1
        Next

        If i > 0 Then
            Await context.ExecuteNonQueryAsync(String.Format(sql, String.Join(", ", valuesSql.ToArray())), parameters.ToArray())
        End If
    End Function

    Private Shared Function GetPrefParameter(prop As ICardMultiProperty) As Byte?
        Dim prop4 As ICardMultiProperty4 = TryCast(prop, ICardMultiProperty4)
        If prop4 Is Nothing Then
            Return If(prop.IsPrefered, CType(1, Byte?), Nothing)
        End If

        Return CType(prop4.PreferenceLevel, Byte?)
    End Function

    Private Function PrepareSqlParamsWriteCustomProperty(propName As String, prop As IRawProperty, parentId As String, uid As String, clientAppName As String, ByRef sql As String, ByRef parameters As List(Of Object)) As Boolean
        sql = "INSERT INTO [card_CustomProperty] (
                  [ParentId]
                , [UID]
                , [ClientAppName]
                , [PropertyName]
                , [ParameterName]
                , [Value]
                , [SortIndex]
            ) VALUES {0}"
        Dim valuesSql As List(Of String) = New List(Of String)()
        parameters = New List(Of Object)()
        Dim origParamsCount As Integer = parameters.Count()
        ' Custom properties are one of the following:
        '  - props that start with "X-". This is a standard-based approach to creating custom props.
        '  - props that has "." in its name. Typically "item1.X-PROP". Such props are created by iOS and OS X.
        Dim isCustomProp As Boolean = propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase) OrElse propName.Contains(".")
        Dim paramName As String = Nothing
        ' Save custom prop value.
        If isCustomProp Then
            Dim val As String = prop.RawValue
            valuesSql.Add(String.Format("(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex))
            parameters.AddRange(New Object() {"@ParentId" & paramIndex, parentId,
                                             "@UID" & paramIndex, uid,              ' Added for performance optimization purposes.
                                             "@ClientAppName" & paramIndex, clientAppName,    ' Client app name that created this custom property.
                                             "@PropertyName" & paramIndex, propName,
                                             "@ParameterName" & paramIndex, paramName,        ' null is inserted to mark prop value.
                                             "@Value" & paramIndex, val,
                                             "@SortIndexParam" & paramIndex, prop.SortIndex   ' Property position in vCard.
                                             })
            paramIndex += 1
        End If

        ' Save parameters and their values.
        For Each param As Parameter In prop.Parameters
            paramName = param.Name
            ' For standard properties we save only custom params (that start with 'X-'). All standard params go to their fields in DB.
            ' For custom properies we save all params.
            If Not isCustomProp AndAlso Not paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase) Then Continue For
            For Each value As String In param.Values
                Dim val As String = value
                valuesSql.Add(String.Format("(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex))
                parameters.AddRange(New Object() {"@ParentId" & paramIndex, parentId,
                                                 "@UID" & paramIndex, uid,          ' added for performance optimization purposes
                                                 "@ClientAppName" & paramIndex, clientAppName,' Client app name that created this custom parameter.
                                                 "@PropertyName" & paramIndex, propName,
                                                 "@ParameterName" & paramIndex, paramName,
                                                 "@Value" & paramIndex, val,
                                                 "@SortIndexParam" & paramIndex, Nothing})
                paramIndex += 1
            Next
        Next

        If origParamsCount < parameters.Count() Then
            sql = String.Format(sql, String.Join(", ", valuesSql.ToArray()))
            Return True
        End If

        Return False
    End Function

    Private Function PrepareSqlCustomPropertiesOfComponentAsync(component As IComponent, parentId As String, uid As String, clientAppName As String, ByRef sql As String, ByRef parameters As List(Of Object)) As Boolean
        sql = ""
        parameters = New List(Of Object)()
        ' We save only single custom props here, multiple props are saved in other methods.
        Dim multiProps As String() = New String() {"EMAIL", "ADR", "IMPP", "TEL", "URL"}
        ' Properties in IComponent.Properties are grouped by name.
        For Each pair As KeyValuePair(Of String, IList(Of IRawProperty)) In component.Properties
            If multiProps.Contains(pair.Key.ToUpper()) OrElse (pair.Value.Count <> 1) Then Continue For
            Dim sqlInsert As String
            Dim parametersInsert As List(Of Object)
            If PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, clientAppName, sqlInsert, parametersInsert) Then
                sql += "; " & sqlInsert
                parameters.AddRange(parametersInsert)
            End If
        Next

        Return Not String.IsNullOrEmpty(sql)
    End Function

    Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
        Dim sql As String = "DELETE FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)"
        If Await Context.ExecuteNonQueryAsync(sql, 
                                             "@UserId", Context.UserId,
                                             "@FileName", fileName) < 1 Then
            Throw New DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN)
        End If
    End Function

    Public Async Function ReadAsync(output As Stream, startIndex As Long, count As Long) As Task Implements IContentAsync.ReadAsync
        Dim vCardVersion As String = rowCardFile.Field(Of String)("Version")
        Dim card As ICard2 = CardFactory.CreateCard(vCardVersion)
        ReadCard(card)
        ReadEmails(card.Emails, rowsEmails)
        ReadAddresses(card.Addresses, rowsAddresses)
        ReadTelephones(card.Telephones, rowsTelephones)
        ReadUrls(card.Urls, rowsUrls)
        ' IMPP is vCard 3.0 & 4.0 prop
        Dim card3 As ICard3 = TryCast(card, ICard3)
        If card3 IsNot Nothing Then
            ReadMessengers(card3.InstantMessengers, rowsInstantMessengers)
        End If

        ' Check if this CardDAV client application requires properties conversion.
        If AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent) Then
            ' In case of iOS & OS X the props below must be converted to the following format:
            ' item2.TEL:(222)222 - 2222
            ' item2.X-ABLabel:Emergency
            AppleCardInteroperability.Denormalize(card)
        End If

        Call New vFormatter().Serialize(output, card)
    End Function

    Private Sub ReadCard(card As ICard2)
        Dim uid As String = rowCardFile.Field(Of String)("UID")
        'UID
        card.Uid = card.CreateTextProp(uid)
        ' PRODID
        card.ProductId = card.CreateTextProp("-//IT Hit//Collab Lib//EN")
        ' FN
        card.FormattedNames.Add(rowCardFile.Field(Of String)("FormattedName"))
        ' N
        card.Name = card.CreateNameProp(rowCardFile.Field(Of String)("FamilyName"),
                                       rowCardFile.Field(Of String)("GivenName"),
                                       rowCardFile.Field(Of String)("AdditionalNames"),
                                       rowCardFile.Field(Of String)("HonorificPrefix"),
                                       rowCardFile.Field(Of String)("HonorificSuffix"))
        ' PHOTO
        If Not rowCardFile.IsNull("Photo") Then
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field(Of Byte())("Photo")), rowCardFile.Field(Of String)("PhotoMediaType"), False)
        End If

        ' LOGO
        If Not rowCardFile.IsNull("Logo") Then
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field(Of Byte())("Logo")), rowCardFile.Field(Of String)("LogoMediaType"), False)
        End If

        ' SOUND
        If Not rowCardFile.IsNull("Sound") Then
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field(Of Byte())("Sound")), rowCardFile.Field(Of String)("SoundMediaType"), False)
        End If

        ' BDAY
        Dim birthday As DateTime? = rowCardFile.Field(Of DateTime?)("Birthday")
        If birthday IsNot Nothing Then
            card.BirthDate = card.CreateDateProp(birthday.Value, DateComponents.[Date])
        End If

        ' REV
        Dim revision As DateTime? = rowCardFile.Field(Of DateTime?)("RevisionUtc")
        If revision IsNot Nothing Then
            card.Revision = card.CreateDateProp(revision.Value)
        End If

        ' SORT-STRING
        Dim sortString As String = rowCardFile.Field(Of String)("SortString")
        If Not String.IsNullOrEmpty(sortString) Then
            Dim propSortString As ITextProperty2 = card.CreateProperty(Of ITextProperty2)()
            propSortString.Text = sortString
            card.SortString = propSortString
        End If

        ' TZ
        Dim timeZone As String = rowCardFile.Field(Of String)("TimeZone")
        If Not String.IsNullOrEmpty(timeZone) Then
            card.TimeZones.Add(timeZone)
        End If

        ' GEO
        ' TITLE
        Dim title As String = rowCardFile.Field(Of String)("Title")
        If Not String.IsNullOrEmpty(title) Then
            card.Titles.Add(title)
        End If

        ' ROLE
        Dim role As String = rowCardFile.Field(Of String)("Role")
        If Not String.IsNullOrEmpty(role) Then
            card.Roles.Add(role)
        End If

        ' ORG
        Dim orgName As String = rowCardFile.Field(Of String)("OrgName")
        Dim orgUnit As String = rowCardFile.Field(Of String)("OrgUnit")
        If Not String.IsNullOrEmpty(orgName) OrElse Not String.IsNullOrEmpty(orgUnit) Then
            Dim propOrg As IOrganization2 = card.Organizations.CreateProperty()
            propOrg.Name = orgName
            propOrg.Units = {orgUnit}
            card.Organizations.Add(propOrg)
        End If

        ' NOTE
        Dim note As String = rowCardFile.Field(Of String)("Note")
        If Not String.IsNullOrEmpty(note) Then
            card.Notes.Add(note)
        End If

        ' vCard v3.0 & v4.0 props
        If TypeOf card Is ICard3 Then
            Dim card3 As ICard3 = TryCast(card, ICard3)
            ' NICKNAME
            Dim nickname As String = rowCardFile.Field(Of String)("Nickname")
            If Not String.IsNullOrEmpty(nickname) Then
                Dim propNickname As INickname3 = card3.NickNames.CreateProperty()
                propNickname.Values = {nickname}
                card3.NickNames.Add(propNickname)
            End If

            ' CATEGORIES
            Dim categories As String = rowCardFile.Field(Of String)("Categories")
            If Not String.IsNullOrEmpty(categories) Then
                Dim aCategories As String() = categories.Split({";"c}, StringSplitOptions.RemoveEmptyEntries)
                For Each categoryList As String In aCategories
                    Dim catProp As ICategories3 = card3.Categories.CreateProperty()
                    catProp.Values = categoryList.Split({","c}, StringSplitOptions.RemoveEmptyEntries)
                    card3.Categories.Add(catProp)
                Next
            End If

            ' CLASS
            Dim classification As String = rowCardFile.Field(Of String)("Classification")
            If Not String.IsNullOrEmpty(classification) Then
                card3.Classes.Add(classification)
            End If
        End If

        ' vCard v4.0 props
        If TypeOf card Is ICard4 Then
            Dim card4 As ICard4 = TryCast(card, ICard4)
            ' KIND
            Dim kind As String = rowCardFile.Field(Of String)("Kind")
            If kind IsNot Nothing Then
                Dim propKind As IKind4 = card4.CreateProperty(Of IKind4)()
                propKind.Text = kind
                card4.Kind = propKind
            End If

            ' ANNIVERSARY
            Dim anniversary As DateTime? = rowCardFile.Field(Of DateTime?)("Anniversary")
            If anniversary IsNot Nothing Then
                Dim propAnniversary As IAnniversary4 = card4.CreateProperty(Of IAnniversary4)()
                propAnniversary.Value = New [Date](anniversary.Value, DateComponents.Month Or DateComponents.[Date])
                card4.Anniversary = propAnniversary
            End If

            ' GENDER
            Dim gender As String = rowCardFile.Field(Of String)("Gender")
            If Not String.IsNullOrEmpty(gender) Then
                Dim propGender As IGender4 = card4.CreateProperty(Of IGender4)()
                propGender.Text = gender
                card4.Gender = propGender
            End If

            ' LANG
            Dim language As String = rowCardFile.Field(Of String)("Language")
            If Not String.IsNullOrEmpty(language) Then
                card4.ContactLanguages.Add(language)
            End If
        End If

        ' Get custom properties and custom parameters
        Dim rowsCardCustomProperties As IEnumerable(Of DataRow) = rowsCustomProperties.Where(Function(x) x.Field(Of String)("ParentId") = uid)
        ReadCustomProperties(card, rowsCardCustomProperties)
    End Sub

    Private Sub ReadEmails(emails As ITextPropertyList(Of IEmail2), rowsEmails As IEnumerable(Of DataRow))
        For Each rowEmail As DataRow In rowsEmails
            Dim email As IEmail2 = emails.CreateProperty()
            email.Text = rowEmail.Field(Of String)("Email")
            email.Types = ParseType(Of EmailType)(rowEmail.Field(Of String)("Type"))
            SetPrefParameter(email, rowEmail.Field(Of Byte?)("PreferenceLevel"))
            email.RawProperty.SortIndex = rowEmail.Field(Of Integer)("SortIndex")
            AddParamValues(rowEmail.Field(Of Guid)("EmailId"), email.RawProperty)
            emails.Add(email)
        Next
    End Sub

    Private Sub ReadAddresses(addresses As ICardPropertyList(Of IAddress2), rowsAddresses As IEnumerable(Of DataRow))
        For Each rowAddress As DataRow In rowsAddresses
            Dim address As IAddress2 = addresses.CreateProperty()
            address.SetAddress({rowAddress.Field(Of String)("PoBox")},
                              {rowAddress.Field(Of String)("AppartmentNumber")},
                              {rowAddress.Field(Of String)("Street")},
                              {rowAddress.Field(Of String)("Locality")},
                              {rowAddress.Field(Of String)("Region")},
                              {rowAddress.Field(Of String)("PostalCode")},
                              {rowAddress.Field(Of String)("Country")},
                              ParseType(Of AddressType)(rowAddress.Field(Of String)("Type")))
            SetPrefParameter(address, rowAddress.Field(Of Byte?)("PreferenceLevel"))
            address.RawProperty.SortIndex = rowAddress.Field(Of Integer)("SortIndex")
            AddParamValues(rowAddress.Field(Of Guid)("AddressId"), address.RawProperty)
            addresses.Add(address)
        Next
    End Sub

    Private Sub ReadMessengers(messengers As ITextPropertyList(Of IInstantMessenger3), rowsMessengers As IEnumerable(Of DataRow))
        For Each rowMessenger As DataRow In rowsMessengers
            Dim messenger As IInstantMessenger3 = messengers.CreateProperty()
            messenger.Text = rowMessenger.Field(Of String)("InstantMessenger")
            messenger.Types = ParseType(Of MessengerType)(rowMessenger.Field(Of String)("Type"))
            SetPrefParameter(messenger, rowMessenger.Field(Of Byte?)("PreferenceLevel"))
            messenger.RawProperty.SortIndex = rowMessenger.Field(Of Integer)("SortIndex")
            AddParamValues(rowMessenger.Field(Of Guid)("InstantMessengerId"), messenger.RawProperty)
            messengers.Add(messenger)
        Next
    End Sub

    Private Sub ReadTelephones(telephones As ITextPropertyList(Of ITelephone2), rowsTelephones As IEnumerable(Of DataRow))
        For Each rowTelephone As DataRow In rowsTelephones
            Dim telephone As ITelephone2 = telephones.CreateProperty()
            telephone.Text = rowTelephone.Field(Of String)("Telephone")
            telephone.Types = ParseType(Of TelephoneType)(rowTelephone.Field(Of String)("Type"))
            SetPrefParameter(telephone, rowTelephone.Field(Of Byte?)("PreferenceLevel"))
            telephone.RawProperty.SortIndex = rowTelephone.Field(Of Integer)("SortIndex")
            AddParamValues(rowTelephone.Field(Of Guid)("TelephoneId"), telephone.RawProperty)
            telephones.Add(telephone)
        Next
    End Sub

    Private Sub ReadUrls(urls As ICardPropertyList(Of ICardUriProperty2), rowsUrls As IEnumerable(Of DataRow))
        For Each rowUrl As DataRow In rowsUrls
            Dim url As ICardUriProperty2 = urls.CreateProperty()
            url.Text = rowUrl.Field(Of String)("Url")
            url.Types = ParseType(Of ExtendibleEnum)(rowUrl.Field(Of String)("Type"))
            SetPrefParameter(url, rowUrl.Field(Of Byte?)("PreferenceLevel"))
            url.RawProperty.SortIndex = rowUrl.Field(Of Integer)("SortIndex")
            AddParamValues(rowUrl.Field(Of Guid)("UrlId"), url.RawProperty)
            urls.Add(url)
        Next
    End Sub

    Private Shared Sub SetPrefParameter(prop As ICardMultiProperty, preferenceLevel As Byte?)
        If preferenceLevel IsNot Nothing Then
            Dim prop4 As ICardMultiProperty4 = TryCast(prop, ICardMultiProperty4)
            If prop4 Is Nothing Then
                ' vCard 2.1 & 3.0
                prop.IsPrefered = True
            Else
                ' vCard 4.0
                prop4.PreferenceLevel = preferenceLevel.Value
            End If
        End If
    End Sub

    Private Shared Function ParseType(Of T As {ExtendibleEnum, New})(typesList As String) As T()
        If Not String.IsNullOrEmpty(typesList) Then
            Dim aStrTypes As String() = typesList.Split({","c}, StringSplitOptions.RemoveEmptyEntries)
            Return aStrTypes.Select(Function(x) StringToEnum(Of T)(x)).ToArray()
        End If

        Return New T() {}
    End Function

    Private Shared Sub ReadCustomProperties(component As IComponent, rowsCustomProperies As IEnumerable(Of DataRow))
        For Each rowCustomProperty As DataRow In rowsCustomProperies
            Dim propertyName As String = rowCustomProperty.Field(Of String)("PropertyName")
            Dim prop As IRawProperty
            If Not component.Properties.ContainsKey(propertyName) Then
                prop = component.CreateRawProperty()
                component.AddProperty(propertyName, prop)
            Else
                prop = component.Properties(propertyName).FirstOrDefault()
            End If

            Dim paramName As String = rowCustomProperty.Field(Of String)("ParameterName")
            Dim value As String = rowCustomProperty.Field(Of String)("Value")
            If paramName Is Nothing Then
                ' If ParameterName is null the Value contains property value
                prop.RawValue = value
                prop.SortIndex = rowCustomProperty.Field(Of Integer)("SortIndex")
            Else
                prop.Parameters.Add(New Parameter(paramName, value))
            End If
        Next
    End Sub

    Private Sub AddParamValues(propertyId As Guid, prop As IRawProperty)
        Dim rowsCustomParams As IEnumerable(Of DataRow) = rowsCustomProperties.Where(Function(x) x.Field(Of String)("ParentId") = propertyId.ToString())
        For Each rowCustomParam As DataRow In rowsCustomParams
            Dim paramName As String = rowCustomParam.Field(Of String)("ParameterName")
            Dim paramValue As String = rowCustomParam.Field(Of String)("Value")
            prop.Parameters.Add(New Parameter(paramName, paramValue))
        Next
    End Sub

    Private Shared Function StringToEnum(Of T As {ExtendibleEnum, New})(value As String) As T
        If value Is Nothing Then Return Nothing
        Dim res As T
        If Not ExtendibleEnum.TryFromString(Of T)(value, res) Then
            ' If no matching value is found create new ExtendibleEnum or type T 
            ' with specified string value and default numeric value (-1).
            res = New T()
            res.Name = value
        End If

        Return res
    End Function
End Class
Namespace
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating CardDAV server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFileAsync">
            <summary>
            Represents a file in the WebDAV repository.
            </summary>
            <remarks>
            This interface represents a file in a repository. This is a marker interface derived from <see cref="T:ITHit.Server.IContentAsync"/> 
            and <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/>, it does not add any additional properties or methods.    
            <see cref="P:ITHit.Server.IContentAsync.ContentType"/> property must return the MIME type of the file.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFolderAsync">
            <summary>
            Represents a folder in the WebDAV repository.
            </summary>
            <remarks>
            Defines properties and methods that WebDAV server folder items must implement.
            In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/> and <see cref="T:ITHit.WebDAV.Server.IItemCollectionAsync"/> interfaces, this interface also provides
            methods for creating folders and files.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolderAsync.CreateFileAsync(System.String)">
            <summary>
            Creates new WebDAV file with the specified name in this folder.
            </summary>
            <returns>
            New file instance created in this call. 
            </returns>
            <param name="name">Name of the file to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>You must create a file in your repository during this call. After calling this method Engine calls
            <see cref="!:IContentAsync.WriteAsync" />.</remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<IFileAsync> CreateFileAsync(string name)
{
    await RequireHasTokenAsync();
    string fileName = System.IO.Path.Combine(fileSystemInfo.FullName, name);

    using (FileStream stream = new FileStream(fileName, FileMode.CreateNew))
    {
    }
    await context.socketService.NotifyCreatedAsync(System.IO.Path.Combine(Path, name));

    return (IFileAsync)await context.GetHierarchyItemAsync(Path + EncodeUtil.EncodeUrlPart(name));
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function CreateFileAsync(name As String) As Task(Of IFileAsync) Implements IFolderAsync.CreateFileAsync
    Await RequireHasTokenAsync()
    Dim fileName As String = System.IO.Path.Combine(fileSystemInfo.FullName, name)
    Using stream As FileStream = New FileStream(fileName, FileMode.CreateNew)
         End Using

    Await context.socketService.NotifyCreatedAsync(System.IO.Path.Combine(Path, name))
    Return CType(Await context.GetHierarchyItemAsync(Path & EncodeUtil.EncodeUrlPart(name)), IFileAsync)
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolderAsync.CreateFolderAsync(System.String)">
            <summary>
            Creates new WebDAV folder with the specified name in this folder.
            </summary>
            <returns>
            .
            </returns>
            <param name="name">Name of the folder to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[virtual public async Task CreateFolderAsync(string name)
{
    await RequireHasTokenAsync();

    bool isRoot = dirInfo.Parent == null;
    DirectoryInfo di = isRoot ? new DirectoryInfo(@"\\?\" + context.RepositoryPath.TrimEnd(System.IO.Path.DirectorySeparatorChar)) : dirInfo;
    di.CreateSubdirectory(name);
    await context.socketService.NotifyCreatedAsync(System.IO.Path.Combine(Path, name));
}
]]></code>
      <code lang="VB"><![CDATA[Overridable Public Async Function CreateFolderAsync(name As String) As Task Implements IFolderAsync.CreateFolderAsync
    Await RequireHasTokenAsync()
    Dim isRoot As Boolean = dirInfo.Parent Is Nothing
    Dim di As DirectoryInfo = If(isRoot, New DirectoryInfo("\\?\" & context.RepositoryPath.TrimEnd(System.IO.Path.DirectorySeparatorChar)), dirInfo)
    di.CreateSubdirectory(name)
    Await context.socketService.NotifyCreatedAsync(System.IO.Path.Combine(Path, name))
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating basic Class1 compliant WebDav server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.DavRequestExtensions">
            <summary>
            Provides request extension methods specific to WebDAV. Such as access to of WebDAV lock-tokens sent by a client application. 
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.DavRequestExtensions.GetClientLockTokens(ITHit.Server.RequestAsync)">
            <summary>
            Gets a list of lock tokens submitted by the client.
            </summary>
            <value>
            List of lock tokens submitted by the client.
            </value>
            <param name="request">Request to which this extension method is applied.</param>
            <remarks>
            This method provides access to the list of lock tokens 
            submitted by the client. These lock tokens were generated during the call to your 
            <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.LockAsync(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)"/> method implementation, associated with the item and returned to client. 
            When WebDAV client is modifying any server item it 
            sends back to server the list of lock tokens. In your WebDAV server Class 2 
            implementation before modifying any locked items you must check if WebDAV 
            client provided necessary lock token.
            </remarks>
            <returns>
            A list of lock-tokens sent by the WebDAV client.
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.DavRequestExtensions.TrimToken(System.String)">
            <exclude/>
            <summary>
            Removes opaquelocktoken: string from lock token
            </summary>
            <param name="tokenValue">Lock token value</param>
            <returns>New token</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.ILockAsync">
            <summary>
            Defines the properties and methods that WebDAV Class 2 compliant server hierarchy items must implement.
            </summary>
            <remarks>
            <para>
            This interface provides the means for locking the hierarchy item, updating lock timeout and accessing the 
            list of applied locks. To create WebDAV Class 2 compliant server you must implement this interface on 
            your file and folder items.
            </para>
            <para>
            When this interface is implemented on an item the server reports Class 2 compliance, returning DAV: 1, 2, 3 
            header in response to the OPTIONS request. Note that while most WebDAV clients never lock folder items, 
            you must still add this interface on folders, as soon as WebDAV clients submit OPTIONS request against folder 
            items when discovering server compliance.
            </para>
            <para>
            When a WebDAV client requires to protect an item from concurrent updates, it locks the item (usually file), 
            submitting lock request to server. The server generates the new lock-token, marks the item as locked and returns 
            the new lock-token to the client. The WebDAV client application keeps the lock-token and when it requires to 
            perform any updates, it supplies the lock-token with the request. When the server receives the update request, 
            it verifies that the lock token belongs to the item that is being updated and performs modifications.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.GetActiveLocksAsync">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEnumerable`1" /> with all locks for this item.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <param>
            This property must return all locks for the item including deep locks on any of the parent folders.
            </param>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<IEnumerable<LockInfo>> GetActiveLocksAsync()
{
    List<DateLockInfo> locks = await GetLocksAsync();
    if (locks == null)
    {
        return new List<LockInfo>();
    }

    IEnumerable<LockInfo> lockInfoList = locks.Select(l => new LockInfo
    {
        IsDeep = l.IsDeep,
        Level = l.Level,
        Owner = l.ClientOwner,
        LockRoot = l.LockRoot,
        TimeOut = l.Expiration == DateTime.MaxValue ?
                    TimeSpan.MaxValue :
                    l.Expiration - DateTime.UtcNow,
        Token = l.LockToken
    }).ToList();

    return lockInfoList;
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetActiveLocksAsync() As Task(Of IEnumerable(Of LockInfo)) Implements ILockAsync.GetActiveLocksAsync
    Dim locks As List(Of DateLockInfo) = Await GetLocksAsync()
    If locks Is Nothing Then
        Return New List(Of LockInfo)()
    End If

    Dim lockInfoList As IEnumerable(Of LockInfo) = locks.Select(Function(l) New LockInfo With {.IsDeep = l.IsDeep,
                                                                                         .Level = l.Level,
                                                                                         .Owner = l.ClientOwner,
                                                                                         .LockRoot = l.LockRoot,
                                                                                         .TimeOut = If(l.Expiration = DateTime.MaxValue, TimeSpan.MaxValue, l.Expiration - DateTime.UtcNow),
                                                                                         .Token = l.LockToken
                                                                                         }).ToList()
    Return lockInfoList
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.LockAsync(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Locks this item.
            </summary>
            <param name="level">Whether lock is shared or exclusive. If an exclusive lock is set other users are not 
            be able to set any locks. If a shared lock is set other users are able to set shared lock on the item.</param>
            <param name="isDeep">Specifies if the lock applied only to this item or to the entire subtree.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue" /> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client. Some clients may not provide any timeout. The <b>null</b> is passed in this case.</param>
            <param name="owner">Owner of the lock as specified by client.</param> 
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.LockResult" /> that contains lock-token and timeout that was actually set.
            </returns>
            <remarks>
            This method is called when item is being locked by WebDAV client. In your implementation you must do the following:
            <list type="number">
            <item><description>Generate the new lock-token, usually GUID.</description></item>
            <item><description>Save information about the lock in a storage.</description></item>
            <item><description>Associate the lock with the item in the repository.</description></item>
            <item><description>Return the lock-token to the Engine.</description></item>
            </list>
            Optionally in in this method you can modify the lock timeout requested by client. For example instead of infinity 
            lock you can set lock for some limited time. You must return both lock-token and lock timeout via <see cref="T:ITHit.WebDAV.Server.Class2.LockResult" /> 
            return value, the engine than sends the lock-token and timeout values back to WebDAV client.
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<LockResult> LockAsync(LockLevel level, bool isDeep, TimeSpan? requestedTimeOut, string owner)
{
    await RequireUnlockedAsync(level == LockLevel.Shared);
    string token = Guid.NewGuid().ToString();

    // If timeout is absent or infinit timeout requested,
    // grant 5 minute lock.
    TimeSpan timeOut = TimeSpan.FromMinutes(5);

    if (requestedTimeOut.HasValue && requestedTimeOut < TimeSpan.MaxValue)
    {
        timeOut = requestedTimeOut.Value;
    }

    DateLockInfo lockInfo = new DateLockInfo
    {
        Expiration = DateTime.UtcNow + timeOut,
        IsDeep = false,
        Level = level,
        LockRoot = Path,
        LockToken = token,
        ClientOwner = owner,
        TimeOut = timeOut
    };

    await SaveLockAsync(lockInfo);
    await context.socketService.NotifyLockedAsync(Path);

    return new LockResult(lockInfo.LockToken, lockInfo.TimeOut);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function LockAsync(level As LockLevel, isDeep As Boolean, requestedTimeOut As TimeSpan?, owner As String) As Task(Of LockResult) Implements ILockAsync.LockAsync
    Await RequireUnlockedAsync(level = LockLevel.Shared)
    Dim token As String = Guid.NewGuid().ToString()
    ' If timeout is absent or infinit timeout requested,
    ' grant 5 minute lock.
    Dim timeOut As TimeSpan = TimeSpan.FromMinutes(5)
    If requestedTimeOut.HasValue AndAlso requestedTimeOut < TimeSpan.MaxValue Then
        timeOut = requestedTimeOut.Value
    End If

    Dim lockInfo As DateLockInfo = New DateLockInfo With {.Expiration = DateTime.UtcNow + timeOut,
                                                    .IsDeep = False,
                                                    .Level = level,
                                                    .LockRoot = Path,
                                                    .LockToken = token,
                                                    .ClientOwner = owner,
                                                    .TimeOut = timeOut
                                                    }
    Await SaveLockAsync(lockInfo)
    Await context.socketService.NotifyLockedAsync(Path)
    Return New LockResult(lockInfo.LockToken, lockInfo.TimeOut)
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.RefreshLockAsync(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Updates lock timeout information on this item.
            </summary>
            <param name="token">Lock token.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue" /> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.RefreshLockResult" /> that contains information about the lock including timeout that was actually set.
            </returns>
            <remarks>This method is called when WebDAV client wants to modify (usually prolong) timeout for the previously 
            set lock. In this method implementation you can update the lock timeout. Note that you can ignore the requested 
            timout and set timeout that is different from the one requested by client.</remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<RefreshLockResult> RefreshLockAsync(string token, TimeSpan? requestedTimeOut)
{
    if (string.IsNullOrEmpty(token))
    {
        throw new DavException("Lock can not be found.", DavStatus.BAD_REQUEST);
    }

    List<DateLockInfo> locks = await GetLocksAsync(getAllWithExpired: true);
    DateLockInfo lockInfo = locks.SingleOrDefault(x => x.LockToken == token);

    if (lockInfo == null || lockInfo.Expiration <= DateTime.UtcNow)
    {
        throw new DavException("Lock can not be found.", DavStatus.CONFLICT);
    }
    else
    {
        lockInfo.TimeOut = TimeSpan.FromMinutes(5);

        if (requestedTimeOut.HasValue && requestedTimeOut < TimeSpan.MaxValue)
        {
            lockInfo.TimeOut = requestedTimeOut.Value;
        }


        lockInfo.Expiration = DateTime.UtcNow + lockInfo.TimeOut;

        await SaveLockAsync(lockInfo);
    }
    await context.socketService.NotifyLockedAsync(Path);

    return new RefreshLockResult(lockInfo.Level, lockInfo.IsDeep, lockInfo.TimeOut, lockInfo.ClientOwner);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function RefreshLockAsync(token As String, requestedTimeOut As TimeSpan?) As Task(Of RefreshLockResult) Implements ILockAsync.RefreshLockAsync
    If String.IsNullOrEmpty(token) Then
        Throw New DavException("Lock can not be found.", DavStatus.BAD_REQUEST)
    End If

    Dim locks As List(Of DateLockInfo) = Await GetLocksAsync(getAllWithExpired:=True)
    Dim lockInfo As DateLockInfo = locks.SingleOrDefault(Function(x) x.LockToken = token)
    If lockInfo Is Nothing OrElse lockInfo.Expiration <= DateTime.UtcNow Then
        Throw New DavException("Lock can not be found.", DavStatus.CONFLICT)
    Else
        lockInfo.TimeOut = TimeSpan.FromMinutes(5)
        If requestedTimeOut.HasValue AndAlso requestedTimeOut < TimeSpan.MaxValue Then
            lockInfo.TimeOut = requestedTimeOut.Value
        End If

        lockInfo.Expiration = DateTime.UtcNow + lockInfo.TimeOut
        Await SaveLockAsync(lockInfo)
    End If

    Await context.socketService.NotifyLockedAsync(Path)
    Return New RefreshLockResult(lockInfo.Level, lockInfo.IsDeep, lockInfo.TimeOut, lockInfo.ClientOwner)
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)">
            <summary>
            Removes lock with the specified token from this item.
            </summary>
            <returns>
            .
            </returns>
            <param name="lockToken">Lock with this token should be removed from the item.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            If this lock included more than one hierarchy item, the lock is removed from all items included in the lock.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task UnlockAsync(string lockToken)
{
    if (string.IsNullOrEmpty(lockToken))
    {
        throw new DavException("Lock can not be found.", DavStatus.BAD_REQUEST);
    }

    List<DateLockInfo> locks = await GetLocksAsync(getAllWithExpired: true);
    DateLockInfo lockInfo = locks.SingleOrDefault(x => x.LockToken == lockToken);

    await RemoveExpiredLocksAsync(lockToken);

    if (lockInfo == null || lockInfo.Expiration <= DateTime.UtcNow)
    {
        throw new DavException("The lock could not be found.", DavStatus.CONFLICT);
    }
    await context.socketService.NotifyUnLockedAsync(Path);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function UnlockAsync(lockToken As String) As Task Implements ILockAsync.UnlockAsync
    If String.IsNullOrEmpty(lockToken) Then
        Throw New DavException("Lock can not be found.", DavStatus.BAD_REQUEST)
    End If

    Dim locks As List(Of DateLockInfo) = Await GetLocksAsync(getAllWithExpired:=True)
    Dim lockInfo As DateLockInfo = locks.SingleOrDefault(Function(x) x.LockToken = lockToken)
    Await RemoveExpiredLocksAsync(lockToken)
    If lockInfo Is Nothing OrElse lockInfo.Expiration <= DateTime.UtcNow Then
        Throw New DavException("The lock could not be found.", DavStatus.CONFLICT)
    End If

    Await context.socketService.NotifyUnLockedAsync(Path)
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockedException">
            <summary>
            This exception shall be thrown in cases when item is locked and client didn't provide lock token or if the item is already locked.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>
            <param name="item">Instance of <see cref="T:ITHit.Server.IHierarchyItemBaseAsync"/>.</param>
            <param name="renderContent">Whether contents shall be written to output.</param> 
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockInfo">
            <summary>
            Serves for exchanging locking information with WebDAV engine.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.String,System.Nullable{System.TimeSpan},System.String,System.String)">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
            <param name="level">Shared or exclusive.</param>
            <param name="isDeep">Whether the lock is deep.</param>
            <param name="token">Lock token.</param>
            <param name="timeOut">Lock timeout.</param>
            <param name="owner">Lock owner.</param>
            <param name="lockRoot">Parent item on which this lock is specified explicitely.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Token">
            <summary>
            The lock token associated with a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Level">
            <summary>
            Indicates whether a lock is shared or exclusive.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.TimeOut">
            <summary>
            Lock expiration time.
            </summary>
            <remarks>
            Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> means infinity
            lock that never expires. The <b>null</b> value means that timeout was not provided by a client.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Owner">
            <summary>
            Provides information about the principal taking out a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.LockRoot">
            <summary>
            Parent item on which this lock is specified explicitely.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockLevel">
            <summary>
            Level of lock.
            </summary>
            <remarks>
            If a user sets an exclusive lock, other users will not be able to set any locks. If a user sets shared lock 
            other users will be able to set only shared lock on the item. There could be only 1 exclusive lock set on an 
            item or it can have 1 or more shared locks.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Shared">
            <summary>
            Shared lock.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Exclusive">
            <summary>
            Exclusive lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockResult">
            <summary>
            Result of <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.LockAsync(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)"/> operation. 
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockResult.#ctor(System.String,System.TimeSpan)">
            <summary>
            Initializes a new instance of the LockResult class.
            </summary>
            <param name="token">Lock token associated with a lock.</param>
            <param name="timeOut">Timeout value. <c>TimeSpan.MaxValue</c> means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.Token">
            <summary>
            Gets/sets lock token associated with the lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.TimeOut">
            <summary>
            Gets/Sets timeout value;
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.RefreshLockResult">
            <summary>
            Result of <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.RefreshLockAsync(System.String,System.Nullable{System.TimeSpan})"/> operation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.RefreshLockResult.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.TimeSpan,System.String)">
            <summary>
            Initializes a new instance of the RefreshLockResult class.
            </summary>
            <param name="isDeep">Indicates whether a lock is enforceable on the subtree.</param>
            <param name="level">Determines whether lock is shared.</param>
            <param name="owner">Principal taking out a lock.</param>
            <param name="timeOut">Timeout value. TimeSpan.MaxValue means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Level">
            <summary>
            Determines whether lock is isShared.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.TimeOut">
            <summary>
            Gets/sets timeout.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Owner">
            <summary>
            Gets/sets information about the principal taking out a lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating Class2 compliant WebDav server (with locking support).
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEngineAsync">
            <summary>
            Represents WebDAV engine. Processes WebDAV request and generates WebDAV response.
            </summary>
            <remarks>
            <para>The engine parses XML send by WebDAV client, processes requests making calls to your implementations of 
            WebDAV interfaces (<see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync" />, <see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync" />, <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync" />, etc 
            and generates XML response.
            </para>
            <para>
            In each HTTP request, you will create a separate instance of your class derived 
            from <see cref="T:ITHit.Server.ContextAsync`1" /> class and pass it to the <see cref="M:ITHit.WebDAV.Server.DavEngineAsync.RunAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})" /> method. Via the context, the engine 
            receives all necessary information about the hosting environment.
            </para>     
            <para>
            You must set <see cref="P:ITHit.Server.EngineAsync`1.License" /> property before you can use the engine.
            </para>
            <para>
            All updates invoked within one request execution shall be inside a single transaction.
            Transaction can be committed or rollbacked in <see cref="M:ITHit.Server.ContextAsync`1.BeforeResponseAsync" /> method, which
            is called right before starting sending a response to the client.
            After this method is called, no methods of interfaces which update state will be called by the engine. However, methods
            which read state can be called.
            </para>
            </remarks>
            <threadsafety>Method <see cref="M:ITHit.Server.EngineAsync`1.RunAsync(ITHit.Server.ContextAsync{`0})" /> is threadsafe. All other members are NOT threadsafe.
            You can create a single instance of this class, initialize it once and use to serve all requests 
            from different threads.</threadsafety>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private readonly string license = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
    private static readonly string googleServiceAccountID = ConfigurationManager.AppSettings["GoogleServiceAccountID"];

    private static readonly string googleServicePrivateKey = ConfigurationManager.AppSettings["GoogleServicePrivateKey"];

    private static readonly string googleNotificationsRelativeUrl = ConfigurationManager.AppSettings["GoogleNotificationsRelativeUrl"];

    private readonly string gSuiteLicense = File.Exists(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") ? File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") : string.Empty;

    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public override bool IsReusable
    {
        get { return true; }
    }
  

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngineAsync webDavEngine = getOrInitializeWebDavEngine(context);

        context.Response.BufferOutput = false;
        DavContext ntfsDavContext = new DavContext(context);
        GSuiteEngineAsync gSuiteEngine = getOrInitializeGSuiteEngine(context);
        await webDavEngine.RunAsync(ntfsDavContext);
        if (gSuiteEngine != null)
        {
            await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(ntfsDavContext));
        }
    }

    private DavEngineAsync initializeWebDavEngine(HttpContext context)
    {

        ILogger logger = WebDAVServer.FileSystemStorage.AspNet.Logger.Instance;
        DavEngineAsync webDavEngine = new DavEngineAsync
        {
            Logger = logger

            // Use idented responses if debug logging is enabled.
            , OutputXmlFormatting = true
        };

        webDavEngine.License = license;
        string contentRootPath = HttpContext.Current.Request.MapPath("/");

        // Set custom handler to process GET and HEAD requests to folders and display 
        // info about how to connect to server. We are using the same custom handler 
        // class (but different instances) here to process both GET and HEAD because 
        // these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        // request is not processed.
        MyCustomGetHandler handlerGet  = new MyCustomGetHandler(contentRootPath);
        MyCustomGetHandler handlerHead = new MyCustomGetHandler(contentRootPath);
        handlerGet.OriginalHandler  = webDavEngine.RegisterMethodHandler("GET",  handlerGet);
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead);

        return webDavEngine;
    }

    private DavEngineAsync getOrInitializeWebDavEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeWebDavEngine(context);
        }

        return (DavEngineAsync)context.Application[ENGINE_KEY];
    }
    private GSuiteEngineAsync getOrInitializeGSuiteEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$GSuiteEngine$";
        if (string.IsNullOrEmpty(googleServiceAccountID) || string.IsNullOrEmpty(googleServicePrivateKey))
        {
            return null;
        }

        if (context.Application[ENGINE_KEY] == null)
        {
            var gSuiteEngine = new GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl)
            {
                License = gSuiteLicense, 
                Logger = WebDAVServer.FileSystemStorage.AspNet.Logger.Instance
            };

            context.Application[ENGINE_KEY] = gSuiteEngine;
        }

        return (GSuiteEngineAsync)context.Application[ENGINE_KEY];
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class DavHandler
    Inherits HttpTaskAsyncHandler

    Private ReadOnly license As String = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "License.lic")

    Private Shared ReadOnly googleServiceAccountID As String = ConfigurationManager.AppSettings("GoogleServiceAccountID")

    Private Shared ReadOnly googleServicePrivateKey As String = ConfigurationManager.AppSettings("GoogleServicePrivateKey")

    Private Shared ReadOnly googleNotificationsRelativeUrl As String = ConfigurationManager.AppSettings("GoogleNotificationsRelativeUrl")

    Private ReadOnly gSuiteLicense As String = If(File.Exists(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), String.Empty)

    Private Shared ReadOnly debugLoggingEnabled As Boolean = "true".Equals(ConfigurationManager.AppSettings("DebugLoggingEnabled"),
                                                                          StringComparison.InvariantCultureIgnoreCase)

    Public Overrides ReadOnly Property IsReusable As Boolean
        Get
            Return True
        End Get
    End Property

    Public Overrides Async Function ProcessRequestAsync(context As HttpContext) As Task
        Dim webDavEngine As DavEngineAsync = getOrInitializeWebDavEngine(context)
        context.Response.BufferOutput = False
        Dim ntfsDavContext As DavContext = New DavContext(context)
        Dim gSuiteEngine As GSuiteEngineAsync = getOrInitializeGSuiteEngine(context)
        Await webDavEngine.RunAsync(ntfsDavContext)
        If gSuiteEngine IsNot Nothing Then
            Await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(ntfsDavContext))
        End If
    End Function

    Private Function initializeWebDavEngine(context As HttpContext) As DavEngineAsync
        Dim logger As ILogger = WebDAVServer.FileSystemStorage.AspNet.Logger.Instance
        Dim webDavEngine As DavEngineAsync = New DavEngineAsync With {.Logger = logger,
                                                                .OutputXmlFormatting = True}
        webDavEngine.License = license
        Dim contentRootPath As String = HttpContext.Current.Request.MapPath("/")
        ' Set custom handler to process GET and HEAD requests to folders and display 
        ' info about how to connect to server. We are using the same custom handler 
        ' class (but different instances) here to process both GET and HEAD because 
        ' these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        ' request is not processed.
        Dim handlerGet As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        Dim handlerHead As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        handlerGet.OriginalHandler = webDavEngine.RegisterMethodHandler("GET", handlerGet)
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead)
        Return webDavEngine
    End Function

    Private Function getOrInitializeWebDavEngine(context As HttpContext) As DavEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$DavEngine$"
        If context.Application(ENGINE_KEY) Is Nothing Then
            context.Application(ENGINE_KEY) = initializeWebDavEngine(context)
        End If

        Return CType(context.Application(ENGINE_KEY), DavEngineAsync)
    End Function

    Private Function getOrInitializeGSuiteEngine(context As HttpContext) As GSuiteEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$GSuiteEngine$"
        If String.IsNullOrEmpty(googleServiceAccountID) OrElse String.IsNullOrEmpty(googleServicePrivateKey) Then
            Return Nothing
        End If

        If context.Application(ENGINE_KEY) Is Nothing Then
            Dim gSuiteEngine = New GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl) With {.License = gSuiteLicense, 
                                                                                                                                      .Logger = WebDAVServer.FileSystemStorage.AspNet.Logger.Instance
                                                                                                                                      }
            context.Application(ENGINE_KEY) = gSuiteEngine
        End If

        Return CType(context.Application(ENGINE_KEY), GSuiteEngineAsync)
    End Function
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private readonly string license = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
    private static readonly string googleServiceAccountID = ConfigurationManager.AppSettings["GoogleServiceAccountID"];

    private static readonly string googleServicePrivateKey = ConfigurationManager.AppSettings["GoogleServicePrivateKey"];

    private static readonly string googleNotificationsRelativeUrl = ConfigurationManager.AppSettings["GoogleNotificationsRelativeUrl"];

    private readonly string gSuiteLicense = File.Exists(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") ? File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") : string.Empty;

    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public override bool IsReusable
    {
        get { return true; }
    }
  

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngineAsync webDavEngine = getOrInitializeWebDavEngine(context);

        context.Response.BufferOutput = false;
        GSuiteEngineAsync gSuiteEngine = getOrInitializeGSuiteEngine(context);

        using (var sqlDavContext = new DavContext(context))
        {
            await webDavEngine.RunAsync(sqlDavContext);
            if (gSuiteEngine != null)
            {
                await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(sqlDavContext));
            }
        }
    }

    private DavEngineAsync initializeWebDavEngine(HttpContext context)
    {

        ILogger logger = CalDAVServer.SqlStorage.AspNet.Logger.Instance;
        logger.LogFlags = LogFlagsEnum.LogGetResponseBody | LogFlagsEnum.LogPutRequestBody;
        DavEngineAsync webDavEngine = new DavEngineAsync
        {
            Logger = logger

            // Use idented responses if debug logging is enabled.
            , OutputXmlFormatting = true

            // Do not emit CORS headers, typically not required in case of CalDAV/CardDAV server.
            , CorsAllowedFor = null

            // Use full URIs only in case of a regular WebDAV server. Microsoft Mini-redirector does not support URIs without domain.
            , UseFullUris = false
        };

        webDavEngine.License = license;
        string contentRootPath = HttpContext.Current.Request.MapPath("/");

        // Set custom handler to process GET and HEAD requests to folders and display 
        // info about how to connect to server. We are using the same custom handler 
        // class (but different instances) here to process both GET and HEAD because 
        // these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        // request is not processed.
        MyCustomGetHandler handlerGet  = new MyCustomGetHandler(contentRootPath);
        MyCustomGetHandler handlerHead = new MyCustomGetHandler(contentRootPath);
        handlerGet.OriginalHandler  = webDavEngine.RegisterMethodHandler("GET",  handlerGet);
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead);

        // Set your iCalendar & vCard library license before calling any members.
        // iCalendar & vCard library accepts:
        // - WebDAV Server Engine license with iCalendar & vCard modules. Verify your license file to see if these modules are specified.
        // - or iCalendar and vCard Library license.
        ITHit.Collab.LicenseValidator.SetLicense(license);

        return webDavEngine;
    }

    private DavEngineAsync getOrInitializeWebDavEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeWebDavEngine(context);
        }

        return (DavEngineAsync)context.Application[ENGINE_KEY];
    }
    private GSuiteEngineAsync getOrInitializeGSuiteEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$GSuiteEngine$";
        if (string.IsNullOrEmpty(googleServiceAccountID) || string.IsNullOrEmpty(googleServicePrivateKey))
        {
            return null;
        }

        if (context.Application[ENGINE_KEY] == null)
        {
            var gSuiteEngine = new GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl)
            {
                License = gSuiteLicense, 
                Logger = CalDAVServer.SqlStorage.AspNet.Logger.Instance
            };

            context.Application[ENGINE_KEY] = gSuiteEngine;
        }

        return (GSuiteEngineAsync)context.Application[ENGINE_KEY];
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class DavHandler
    Inherits HttpTaskAsyncHandler

    Private ReadOnly license As String = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "License.lic")

    Private Shared ReadOnly googleServiceAccountID As String = ConfigurationManager.AppSettings("GoogleServiceAccountID")

    Private Shared ReadOnly googleServicePrivateKey As String = ConfigurationManager.AppSettings("GoogleServicePrivateKey")

    Private Shared ReadOnly googleNotificationsRelativeUrl As String = ConfigurationManager.AppSettings("GoogleNotificationsRelativeUrl")

    Private ReadOnly gSuiteLicense As String = If(File.Exists(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), String.Empty)

    Private Shared ReadOnly debugLoggingEnabled As Boolean = "true".Equals(ConfigurationManager.AppSettings("DebugLoggingEnabled"),
                                                                          StringComparison.InvariantCultureIgnoreCase)

    Public Overrides ReadOnly Property IsReusable As Boolean
        Get
            Return True
        End Get
    End Property

    Public Overrides Async Function ProcessRequestAsync(context As HttpContext) As Task
        Dim webDavEngine As DavEngineAsync = getOrInitializeWebDavEngine(context)
        context.Response.BufferOutput = False
        Dim gSuiteEngine As GSuiteEngineAsync = getOrInitializeGSuiteEngine(context)
        Using sqlDavContext = New DavContext(context)
            Await webDavEngine.RunAsync(sqlDavContext)
            If gSuiteEngine IsNot Nothing Then
                Await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(sqlDavContext))
            End If
        End Using
    End Function

    Private Function initializeWebDavEngine(context As HttpContext) As DavEngineAsync
        Dim logger As ILogger = CalDAVServer.SqlStorage.AspNet.Logger.Instance
        logger.LogFlags = LogFlagsEnum.LogGetResponseBody Or LogFlagsEnum.LogPutRequestBody
        Dim webDavEngine As DavEngineAsync = New DavEngineAsync With {.Logger = logger,
                                                                .OutputXmlFormatting = True, .CorsAllowedFor = Nothing, .UseFullUris = False}
        webDavEngine.License = license
        Dim contentRootPath As String = HttpContext.Current.Request.MapPath("/")
        ' Set custom handler to process GET and HEAD requests to folders and display 
        ' info about how to connect to server. We are using the same custom handler 
        ' class (but different instances) here to process both GET and HEAD because 
        ' these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        ' request is not processed.
        Dim handlerGet As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        Dim handlerHead As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        handlerGet.OriginalHandler = webDavEngine.RegisterMethodHandler("GET", handlerGet)
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead)
        ' Set your iCalendar & vCard library license before calling any members.
        ' iCalendar & vCard library accepts:
        ' - WebDAV Server Engine license with iCalendar & vCard modules. Verify your license file to see if these modules are specified.
        ' - or iCalendar and vCard Library license.
        ITHit.Collab.LicenseValidator.SetLicense(license)
        Return webDavEngine
    End Function

    Private Function getOrInitializeWebDavEngine(context As HttpContext) As DavEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$DavEngine$"
        If context.Application(ENGINE_KEY) Is Nothing Then
            context.Application(ENGINE_KEY) = initializeWebDavEngine(context)
        End If

        Return CType(context.Application(ENGINE_KEY), DavEngineAsync)
    End Function

    Private Function getOrInitializeGSuiteEngine(context As HttpContext) As GSuiteEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$GSuiteEngine$"
        If String.IsNullOrEmpty(googleServiceAccountID) OrElse String.IsNullOrEmpty(googleServicePrivateKey) Then
            Return Nothing
        End If

        If context.Application(ENGINE_KEY) Is Nothing Then
            Dim gSuiteEngine = New GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl) With {.License = gSuiteLicense, 
                                                                                                                                      .Logger = CalDAVServer.SqlStorage.AspNet.Logger.Instance
                                                                                                                                      }
            context.Application(ENGINE_KEY) = gSuiteEngine
        End If

        Return CType(context.Application(ENGINE_KEY), GSuiteEngineAsync)
    End Function
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private readonly string license = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
    private static readonly string googleServiceAccountID = ConfigurationManager.AppSettings["GoogleServiceAccountID"];

    private static readonly string googleServicePrivateKey = ConfigurationManager.AppSettings["GoogleServicePrivateKey"];

    private static readonly string googleNotificationsRelativeUrl = ConfigurationManager.AppSettings["GoogleNotificationsRelativeUrl"];

    private readonly string gSuiteLicense = File.Exists(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") ? File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "GSuiteLicense.lic") : string.Empty;

    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public override bool IsReusable
    {
        get { return true; }
    }
  

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngineAsync webDavEngine = getOrInitializeWebDavEngine(context);

        context.Response.BufferOutput = false;
        GSuiteEngineAsync gSuiteEngine = getOrInitializeGSuiteEngine(context);

        using (var sqlDavContext = new DavContext(context))
        {
            await webDavEngine.RunAsync(sqlDavContext);
            if (gSuiteEngine != null)
            {
                await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(sqlDavContext));
            }
        }
    }

    private DavEngineAsync initializeWebDavEngine(HttpContext context)
    {

        ILogger logger = CardDAVServer.SqlStorage.AspNet.Logger.Instance;
        logger.LogFlags = LogFlagsEnum.LogGetResponseBody | LogFlagsEnum.LogPutRequestBody;
        DavEngineAsync webDavEngine = new DavEngineAsync
        {
            Logger = logger

            // Use idented responses if debug logging is enabled.
            , OutputXmlFormatting = true

            // Do not emit CORS headers, typically not required in case of CalDAV/CardDAV server.
            , CorsAllowedFor = null

            // Use full URIs only in case of a regular WebDAV server. Microsoft Mini-redirector does not support URIs without domain.
            , UseFullUris = false
        };

        webDavEngine.License = license;
        string contentRootPath = HttpContext.Current.Request.MapPath("/");

        // Set custom handler to process GET and HEAD requests to folders and display 
        // info about how to connect to server. We are using the same custom handler 
        // class (but different instances) here to process both GET and HEAD because 
        // these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        // request is not processed.
        MyCustomGetHandler handlerGet  = new MyCustomGetHandler(contentRootPath);
        MyCustomGetHandler handlerHead = new MyCustomGetHandler(contentRootPath);
        handlerGet.OriginalHandler  = webDavEngine.RegisterMethodHandler("GET",  handlerGet);
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead);

        // Set your iCalendar & vCard library license before calling any members.
        // iCalendar & vCard library accepts:
        // - WebDAV Server Engine license with iCalendar & vCard modules. Verify your license file to see if these modules are specified.
        // - or iCalendar and vCard Library license.
        ITHit.Collab.LicenseValidator.SetLicense(license);

        return webDavEngine;
    }

    private DavEngineAsync getOrInitializeWebDavEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeWebDavEngine(context);
        }

        return (DavEngineAsync)context.Application[ENGINE_KEY];
    }
    private GSuiteEngineAsync getOrInitializeGSuiteEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$GSuiteEngine$";
        if (string.IsNullOrEmpty(googleServiceAccountID) || string.IsNullOrEmpty(googleServicePrivateKey))
        {
            return null;
        }

        if (context.Application[ENGINE_KEY] == null)
        {
            var gSuiteEngine = new GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl)
            {
                License = gSuiteLicense, 
                Logger = CardDAVServer.SqlStorage.AspNet.Logger.Instance
            };

            context.Application[ENGINE_KEY] = gSuiteEngine;
        }

        return (GSuiteEngineAsync)context.Application[ENGINE_KEY];
    }
}
]]></code>
      <code lang="VB"><![CDATA[Public Class DavHandler
    Inherits HttpTaskAsyncHandler

    Private ReadOnly license As String = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "License.lic")

    Private Shared ReadOnly googleServiceAccountID As String = ConfigurationManager.AppSettings("GoogleServiceAccountID")

    Private Shared ReadOnly googleServicePrivateKey As String = ConfigurationManager.AppSettings("GoogleServicePrivateKey")

    Private Shared ReadOnly googleNotificationsRelativeUrl As String = ConfigurationManager.AppSettings("GoogleNotificationsRelativeUrl")

    Private ReadOnly gSuiteLicense As String = If(File.Exists(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath & "GSuiteLicense.lic"), String.Empty)

    Private Shared ReadOnly debugLoggingEnabled As Boolean = "true".Equals(ConfigurationManager.AppSettings("DebugLoggingEnabled"),
                                                                          StringComparison.InvariantCultureIgnoreCase)

    Public Overrides ReadOnly Property IsReusable As Boolean
        Get
            Return True
        End Get
    End Property

    Public Overrides Async Function ProcessRequestAsync(context As HttpContext) As Task
        Dim webDavEngine As DavEngineAsync = getOrInitializeWebDavEngine(context)
        context.Response.BufferOutput = False
        Dim gSuiteEngine As GSuiteEngineAsync = getOrInitializeGSuiteEngine(context)
        Using sqlDavContext = New DavContext(context)
            Await webDavEngine.RunAsync(sqlDavContext)
            If gSuiteEngine IsNot Nothing Then
                Await gSuiteEngine.RunAsync(ContextConverter.ConvertToGSuiteContext(sqlDavContext))
            End If
        End Using
    End Function

    Private Function initializeWebDavEngine(context As HttpContext) As DavEngineAsync
        Dim logger As ILogger = CardDAVServer.SqlStorage.AspNet.Logger.Instance
        logger.LogFlags = LogFlagsEnum.LogGetResponseBody Or LogFlagsEnum.LogPutRequestBody
        Dim webDavEngine As DavEngineAsync = New DavEngineAsync With {.Logger = logger,
                                                                .OutputXmlFormatting = True, .CorsAllowedFor = Nothing, .UseFullUris = False}
        webDavEngine.License = license
        Dim contentRootPath As String = HttpContext.Current.Request.MapPath("/")
        ' Set custom handler to process GET and HEAD requests to folders and display 
        ' info about how to connect to server. We are using the same custom handler 
        ' class (but different instances) here to process both GET and HEAD because 
        ' these requests are very similar. Some WebDAV clients may fail to connect if HEAD 
        ' request is not processed.
        Dim handlerGet As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        Dim handlerHead As MyCustomGetHandler = New MyCustomGetHandler(contentRootPath)
        handlerGet.OriginalHandler = webDavEngine.RegisterMethodHandler("GET", handlerGet)
        handlerHead.OriginalHandler = webDavEngine.RegisterMethodHandler("HEAD", handlerHead)
        ' Set your iCalendar & vCard library license before calling any members.
        ' iCalendar & vCard library accepts:
        ' - WebDAV Server Engine license with iCalendar & vCard modules. Verify your license file to see if these modules are specified.
        ' - or iCalendar and vCard Library license.
        ITHit.Collab.LicenseValidator.SetLicense(license)
        Return webDavEngine
    End Function

    Private Function getOrInitializeWebDavEngine(context As HttpContext) As DavEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$DavEngine$"
        If context.Application(ENGINE_KEY) Is Nothing Then
            context.Application(ENGINE_KEY) = initializeWebDavEngine(context)
        End If

        Return CType(context.Application(ENGINE_KEY), DavEngineAsync)
    End Function

    Private Function getOrInitializeGSuiteEngine(context As HttpContext) As GSuiteEngineAsync
        'we don't use any double check lock pattern here because nothing wrong
        'is going to happen if we created occasionally several engines.
        Const ENGINE_KEY As String = "$GSuiteEngine$"
        If String.IsNullOrEmpty(googleServiceAccountID) OrElse String.IsNullOrEmpty(googleServicePrivateKey) Then
            Return Nothing
        End If

        If context.Application(ENGINE_KEY) Is Nothing Then
            Dim gSuiteEngine = New GSuiteEngineAsync(googleServiceAccountID, googleServicePrivateKey, googleNotificationsRelativeUrl) With {.License = gSuiteLicense, 
                                                                                                                                      .Logger = CardDAVServer.SqlStorage.AspNet.Logger.Instance
                                                                                                                                      }
            context.Application(ENGINE_KEY) = gSuiteEngine
        End If

        Return CType(context.Application(ENGINE_KEY), GSuiteEngineAsync)
    End Function
End Class
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.AutoPutUnderVersionControl">
            <summary>
            Determines if placing file under version control is automatic.
            </summary>
            <remarks>
            <value>Boolean value indicating if items must be put under version control before content or properties
            update. Default is <b>true</b>.</value>
            <para>
            Determines whether items will be placed under version control automatically
            or explicit request from client shall be made to put an item under version control.
            </para>
            <para>
            If this property is <c>true</c> the <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> will be called 
            after item is created and prior item content or properties update.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.#ctor">
            <summary>
            Initializes a new instance of this class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterMethodHandler(System.String,ITHit.Server.Extensibility.IMethodHandlerAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Registers custom method handler.
            </summary>
            <param name="method">HTTP verb.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.Server.Extensibility.IMethodHandlerAsync`1" /> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom method handler to be called by the engine.
            If the handler for the specified method was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
            <example>
            <code>
            <![CDATA[
               DavEngineAsync engine = new DavEngineAsync();
               MyCustomGetHandler handler = new MyCustomGetHandler();
               handler.OriginalHandler = engine.RegisterMethodHandler("GET", handler);
            
               MyDavContext context = new MyDavContext(...);
               engine.RunAsync(context);
            ]]>
            </code>
            </example>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[internal class MyCustomGetHandler : IMethodHandlerAsync<IHierarchyItemAsync>
{
    public IMethodHandlerAsync<IHierarchyItemAsync> OriginalHandler { get; set; }

    public bool EnableOutputBuffering
    {
        get { return false; }
    }

    public bool EnableOutputDebugLogging
    {
        get { return false; }
    }

    public bool EnableInputDebugLogging
    {
        get { return false; }
    }

    private readonly string htmlPath;

    public MyCustomGetHandler(string contentRootPathFolder)
    {
        this.htmlPath = contentRootPathFolder;
    }

    public async Task ProcessRequestAsync(ContextAsync<IHierarchyItemAsync> context, IHierarchyItemAsync item)
    {
        string urlPath = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd('/').Length);

        if (item is IItemCollectionAsync)
        {
            // In case of GET requests to WebDAV folders we serve a web page to display 
            // any information about this server and how to use it.

            // Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            // makes some useful things in BeforeResponseAsync.
            await context.EnsureBeforeResponseWasCalledAsync();
            IHttpAsyncHandler page = (IHttpAsyncHandler)System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(
                "~/MyCustomHandlerPage.aspx", typeof(MyCustomHandlerPage));

            if(Type.GetType("Mono.Runtime") != null)
            {
                page.ProcessRequest(HttpContext.Current);
            }
            else
            {
                // Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                // To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                await Task.Factory.FromAsync(page.BeginProcessRequest, page.EndProcessRequest, HttpContext.Current, null);
            }
        }
        else
        {
            await OriginalHandler.ProcessRequestAsync(context, item);
        }
    }

    public bool AppliesTo(IHierarchyItemAsync item)
    {
        return item is IFolderAsync || OriginalHandler.AppliesTo(item);
    }
}
]]></code>
      <code lang="VB"><![CDATA[Friend Class MyCustomGetHandler
    Implements IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public Property OriginalHandler As IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public ReadOnly Property EnableOutputBuffering As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputBuffering
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableOutputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputDebugLogging
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableInputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableInputDebugLogging
        Get
            Return False
        End Get
    End Property

    Private ReadOnly htmlPath As String

    Public Sub New(contentRootPathFolder As String)
        Me.htmlPath = contentRootPathFolder
    End Sub

    Public Async Function ProcessRequestAsync(context As ContextAsync(Of IHierarchyItemAsync), item As IHierarchyItemAsync) As Task Implements IMethodHandlerAsync(Of IHierarchyItemAsync).ProcessRequestAsync
        Dim urlPath As String = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd("/"c).Length)
        If TypeOf item Is IItemCollectionAsync Then
            ' In case of GET requests to WebDAV folders we serve a web page to display 
            ' any information about this server and how to use it.
            ' Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            ' makes some useful things in BeforeResponseAsync.
            Await context.EnsureBeforeResponseWasCalledAsync()
            Dim page As IHttpAsyncHandler = CType(System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath("~/MyCustomHandlerPage.aspx", GetType(MyCustomHandlerPage)), IHttpAsyncHandler)
            If Type.GetType("Mono.Runtime") IsNot Nothing Then
                page.ProcessRequest(HttpContext.Current)
            Else
                ' Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                ' To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                Await Task.Factory.FromAsync(AddressOf page.BeginProcessRequest, AddressOf page.EndProcessRequest, HttpContext.Current, Nothing)
            End If
        Else
            Await OriginalHandler.ProcessRequestAsync(context, item)
        End If
    End Function

    Public Function AppliesTo(item As IHierarchyItemAsync) As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).AppliesTo
        Return TypeOf item Is IFolderAsync OrElse OriginalHandler.AppliesTo(item)
    End Function
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CalDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[internal class MyCustomGetHandler : IMethodHandlerAsync<IHierarchyItemAsync>
{
    public IMethodHandlerAsync<IHierarchyItemAsync> OriginalHandler { get; set; }

    public bool EnableOutputBuffering
    {
        get { return false; }
    }

    public bool EnableOutputDebugLogging
    {
        get { return false; }
    }

    public bool EnableInputDebugLogging
    {
        get { return false; }
    }

    private readonly string htmlPath;

    public MyCustomGetHandler(string contentRootPathFolder)
    {
        this.htmlPath = contentRootPathFolder;
    }

    public async Task ProcessRequestAsync(ContextAsync<IHierarchyItemAsync> context, IHierarchyItemAsync item)
    {
        string urlPath = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd('/').Length);

        if (item is IItemCollectionAsync)
        {
            // In case of GET requests to WebDAV folders we serve a web page to display 
            // any information about this server and how to use it.

            // Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            // makes some useful things in BeforeResponseAsync.
            await context.EnsureBeforeResponseWasCalledAsync();

            // Request to iOS/OS X CalDAV/CardDAV profile.
            if (context.Request.RawUrl.EndsWith("?connect"))
            {
                await WriteProfileAsync(context, item, htmlPath);
                return;
            }
            IHttpAsyncHandler page = (IHttpAsyncHandler)System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(
                "~/MyCustomHandlerPage.aspx", typeof(MyCustomHandlerPage));

            if(Type.GetType("Mono.Runtime") != null)
            {
                page.ProcessRequest(HttpContext.Current);
            }
            else
            {
                // Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                // To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                await Task.Factory.FromAsync(page.BeginProcessRequest, page.EndProcessRequest, HttpContext.Current, null);
            }
        }
        else
        {
            await OriginalHandler.ProcessRequestAsync(context, item);
        }
    }

    public bool AppliesTo(IHierarchyItemAsync item)
    {
        return item is IFolderAsync || OriginalHandler.AppliesTo(item);
    }

    private async Task WriteProfileAsync(ContextAsync<IHierarchyItemAsync> context, IHierarchyItemBaseAsync item, string htmlPath)
    {
        string mobileconfigFileName = null;
        string decription = null;
        if (item is ICalendarFolderAsync)
        {
            mobileconfigFileName = "CalDAV.AppleProfileTemplete.mobileconfig";
            decription = (item as ICalendarFolderAsync).CalendarDescription;
        }

        decription = !string.IsNullOrEmpty(decription) ? decription : item.Name;

        string templateContent = null;
        using (TextReader reader = new StreamReader(Path.Combine(htmlPath, mobileconfigFileName)))
        {
            templateContent = await reader.ReadToEndAsync();
        }

        Uri url = new Uri(context.Request.UrlPrefix);

        string payloadUUID = item.Path.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries).Last(); // PayloadUUID

        string profile = string.Format(templateContent
            , url.Host // host name
            , item.Path // CalDAV / CardDAV Principal URL. Here we can return (await (item as ICurrentUserPrincipalAsync).GetCurrentUserPrincipalAsync()).Path if needed.
            , (context as DavContext).Identity.Name // user name
            , url.Port // port                
            , (url.Scheme == "https").ToString().ToLower() // SSL
            , decription // CardDAV / CardDAV Account Description
            , Assembly.GetAssembly(this.GetType()).GetName().Version.ToString()
            , Assembly.GetAssembly(typeof(DavEngineAsync)).GetName().Version.ToString()
            , payloadUUID
            );

        byte[] profileBytes = SignProfile(context, profile);

        context.Response.ContentType = "application/x-apple-aspen-config";
        context.Response.AddHeader("Content-Disposition", "attachment; filename=profile.mobileconfig");
        context.Response.ContentLength = profileBytes.Length;
        await context.Response.OutputStream.WriteAsync(profileBytes, 0, profileBytes.Length);
    }

    private byte[] SignProfile(ContextAsync<IHierarchyItemAsync> context, string profile)
    {
        // Here you will sign your profile with SSL certificate to avoid "Unsigned" warning on iOS and OS X.
        // For demo purposes we just return the profile content unmodified.
        return context.Engine.ContentEncoding.GetBytes(profile);
    }
}
]]></code>
      <code lang="VB"><![CDATA[Friend Class MyCustomGetHandler
    Implements IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public Property OriginalHandler As IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public ReadOnly Property EnableOutputBuffering As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputBuffering
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableOutputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputDebugLogging
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableInputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableInputDebugLogging
        Get
            Return False
        End Get
    End Property

    Private ReadOnly htmlPath As String

    Public Sub New(contentRootPathFolder As String)
        Me.htmlPath = contentRootPathFolder
    End Sub

    Public Async Function ProcessRequestAsync(context As ContextAsync(Of IHierarchyItemAsync), item As IHierarchyItemAsync) As Task Implements IMethodHandlerAsync(Of IHierarchyItemAsync).ProcessRequestAsync
        Dim urlPath As String = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd("/"c).Length)
        If TypeOf item Is IItemCollectionAsync Then
            ' In case of GET requests to WebDAV folders we serve a web page to display 
            ' any information about this server and how to use it.
            ' Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            ' makes some useful things in BeforeResponseAsync.
            Await context.EnsureBeforeResponseWasCalledAsync()
            ' Request to iOS/OS X CalDAV/CardDAV profile.
            If context.Request.RawUrl.EndsWith("?connect") Then
                Await WriteProfileAsync(context, item, htmlPath)
                Return
            End If

            Dim page As IHttpAsyncHandler = CType(System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath("~/MyCustomHandlerPage.aspx", GetType(MyCustomHandlerPage)), IHttpAsyncHandler)
            If Type.GetType("Mono.Runtime") IsNot Nothing Then
                page.ProcessRequest(HttpContext.Current)
            Else
                ' Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                ' To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                Await Task.Factory.FromAsync(AddressOf page.BeginProcessRequest, AddressOf page.EndProcessRequest, HttpContext.Current, Nothing)
            End If
        Else
            Await OriginalHandler.ProcessRequestAsync(context, item)
        End If
    End Function

    Public Function AppliesTo(item As IHierarchyItemAsync) As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).AppliesTo
        Return TypeOf item Is IFolderAsync OrElse OriginalHandler.AppliesTo(item)
    End Function

    Private Async Function WriteProfileAsync(context As ContextAsync(Of IHierarchyItemAsync), item As IHierarchyItemBaseAsync, htmlPath As String) As Task
        Dim mobileconfigFileName As String = Nothing
        Dim decription As String = Nothing
        If TypeOf item Is ICalendarFolderAsync Then
            mobileconfigFileName = "CalDAV.AppleProfileTemplete.mobileconfig"
            decription = TryCast(item, ICalendarFolderAsync).CalendarDescription
        End If

        decription = If(Not String.IsNullOrEmpty(decription), decription, item.Name)
        Dim templateContent As String = Nothing
        Using reader As TextReader = New StreamReader(Path.Combine(htmlPath, mobileconfigFileName))
            templateContent = Await reader.ReadToEndAsync()
        End Using

        Dim url As Uri = New Uri(context.Request.UrlPrefix)
        Dim payloadUUID As String = item.Path.Split({"/"c}, StringSplitOptions.RemoveEmptyEntries).Last()
        Dim profile As String = String.Format(templateContent,
                                             url.Host, ' host name
                                             item.Path, ' CalDAV / CardDAV Principal URL. Here we can return (await (item as ICurrentUserPrincipalAsync).GetCurrentUserPrincipalAsync()).Path if needed.
                                             TryCast(context, DavContext).Identity.Name, ' user name
                                             url.Port, ' port                
                                             (url.Scheme = "https").ToString().ToLower(), ' SSL
                                             decription, ' CardDAV / CardDAV Account Description
                                             Assembly.GetAssembly(Me.GetType()).GetName().Version.ToString(),
                                             Assembly.GetAssembly(GetType(DavEngineAsync)).GetName().Version.ToString(),
                                             payloadUUID
                                             )
        Dim profileBytes As Byte() = SignProfile(context, profile)
        context.Response.ContentType = "application/x-apple-aspen-config"
        context.Response.AddHeader("Content-Disposition", "attachment; filename=profile.mobileconfig")
        context.Response.ContentLength = profileBytes.Length
        Await context.Response.OutputStream.WriteAsync(profileBytes, 0, profileBytes.Length)
    End Function

    Private Function SignProfile(context As ContextAsync(Of IHierarchyItemAsync), profile As String) As Byte()
        ' Here you will sign your profile with SSL certificate to avoid "Unsigned" warning on iOS and OS X.
        ' For demo purposes we just return the profile content unmodified.
        Return context.Engine.ContentEncoding.GetBytes(profile)
    End Function
End Class
]]></code>
    </example><example>
      <para>The code below is part of 'CardDAVServer.SqlStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[internal class MyCustomGetHandler : IMethodHandlerAsync<IHierarchyItemAsync>
{
    public IMethodHandlerAsync<IHierarchyItemAsync> OriginalHandler { get; set; }

    public bool EnableOutputBuffering
    {
        get { return false; }
    }

    public bool EnableOutputDebugLogging
    {
        get { return false; }
    }

    public bool EnableInputDebugLogging
    {
        get { return false; }
    }

    private readonly string htmlPath;

    public MyCustomGetHandler(string contentRootPathFolder)
    {
        this.htmlPath = contentRootPathFolder;
    }

    public async Task ProcessRequestAsync(ContextAsync<IHierarchyItemAsync> context, IHierarchyItemAsync item)
    {
        string urlPath = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd('/').Length);

        if (item is IItemCollectionAsync)
        {
            // In case of GET requests to WebDAV folders we serve a web page to display 
            // any information about this server and how to use it.

            // Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            // makes some useful things in BeforeResponseAsync.
            await context.EnsureBeforeResponseWasCalledAsync();

            // Request to iOS/OS X CalDAV/CardDAV profile.
            if (context.Request.RawUrl.EndsWith("?connect"))
            {
                await WriteProfileAsync(context, item, htmlPath);
                return;
            }
            IHttpAsyncHandler page = (IHttpAsyncHandler)System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(
                "~/MyCustomHandlerPage.aspx", typeof(MyCustomHandlerPage));

            if(Type.GetType("Mono.Runtime") != null)
            {
                page.ProcessRequest(HttpContext.Current);
            }
            else
            {
                // Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                // To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                await Task.Factory.FromAsync(page.BeginProcessRequest, page.EndProcessRequest, HttpContext.Current, null);
            }
        }
        else
        {
            await OriginalHandler.ProcessRequestAsync(context, item);
        }
    }

    public bool AppliesTo(IHierarchyItemAsync item)
    {
        return item is IFolderAsync || OriginalHandler.AppliesTo(item);
    }

    private async Task WriteProfileAsync(ContextAsync<IHierarchyItemAsync> context, IHierarchyItemBaseAsync item, string htmlPath)
    {
        string mobileconfigFileName = null;
        string decription = null;
        if (item is IAddressbookFolderAsync)
        {
            mobileconfigFileName = "CardDAV.AppleProfileTemplete.mobileconfig";
            decription = (item as IAddressbookFolderAsync).AddressbookDescription;
        }

        decription = !string.IsNullOrEmpty(decription) ? decription : item.Name;

        string templateContent = null;
        using (TextReader reader = new StreamReader(Path.Combine(htmlPath, mobileconfigFileName)))
        {
            templateContent = await reader.ReadToEndAsync();
        }

        Uri url = new Uri(context.Request.UrlPrefix);

        string payloadUUID = item.Path.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries).Last(); // PayloadUUID

        string profile = string.Format(templateContent
            , url.Host // host name
            , item.Path // CalDAV / CardDAV Principal URL. Here we can return (await (item as ICurrentUserPrincipalAsync).GetCurrentUserPrincipalAsync()).Path if needed.
            , (context as DavContext).Identity.Name // user name
            , url.Port // port                
            , (url.Scheme == "https").ToString().ToLower() // SSL
            , decription // CardDAV / CardDAV Account Description
            , Assembly.GetAssembly(this.GetType()).GetName().Version.ToString()
            , Assembly.GetAssembly(typeof(DavEngineAsync)).GetName().Version.ToString()
            , payloadUUID
            );

        byte[] profileBytes = SignProfile(context, profile);

        context.Response.ContentType = "application/x-apple-aspen-config";
        context.Response.AddHeader("Content-Disposition", "attachment; filename=profile.mobileconfig");
        context.Response.ContentLength = profileBytes.Length;
        await context.Response.OutputStream.WriteAsync(profileBytes, 0, profileBytes.Length);
    }

    private byte[] SignProfile(ContextAsync<IHierarchyItemAsync> context, string profile)
    {
        // Here you will sign your profile with SSL certificate to avoid "Unsigned" warning on iOS and OS X.
        // For demo purposes we just return the profile content unmodified.
        return context.Engine.ContentEncoding.GetBytes(profile);
    }
}
]]></code>
      <code lang="VB"><![CDATA[Friend Class MyCustomGetHandler
    Implements IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public Property OriginalHandler As IMethodHandlerAsync(Of IHierarchyItemAsync)

    Public ReadOnly Property EnableOutputBuffering As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputBuffering
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableOutputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableOutputDebugLogging
        Get
            Return False
        End Get
    End Property

    Public ReadOnly Property EnableInputDebugLogging As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).EnableInputDebugLogging
        Get
            Return False
        End Get
    End Property

    Private ReadOnly htmlPath As String

    Public Sub New(contentRootPathFolder As String)
        Me.htmlPath = contentRootPathFolder
    End Sub

    Public Async Function ProcessRequestAsync(context As ContextAsync(Of IHierarchyItemAsync), item As IHierarchyItemAsync) As Task Implements IMethodHandlerAsync(Of IHierarchyItemAsync).ProcessRequestAsync
        Dim urlPath As String = context.Request.RawUrl.Substring(context.Request.ApplicationPath.TrimEnd("/"c).Length)
        If TypeOf item Is IItemCollectionAsync Then
            ' In case of GET requests to WebDAV folders we serve a web page to display 
            ' any information about this server and how to use it.
            ' Remember to call EnsureBeforeResponseWasCalledAsync here if your context implementation
            ' makes some useful things in BeforeResponseAsync.
            Await context.EnsureBeforeResponseWasCalledAsync()
            ' Request to iOS/OS X CalDAV/CardDAV profile.
            If context.Request.RawUrl.EndsWith("?connect") Then
                Await WriteProfileAsync(context, item, htmlPath)
                Return
            End If

            Dim page As IHttpAsyncHandler = CType(System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath("~/MyCustomHandlerPage.aspx", GetType(MyCustomHandlerPage)), IHttpAsyncHandler)
            If Type.GetType("Mono.Runtime") IsNot Nothing Then
                page.ProcessRequest(HttpContext.Current)
            Else
                ' Here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required. 
                ' To call APM method (Begin/End) from TAP method (Task/async/await) the Task.FromAsync must be used.
                Await Task.Factory.FromAsync(AddressOf page.BeginProcessRequest, AddressOf page.EndProcessRequest, HttpContext.Current, Nothing)
            End If
        Else
            Await OriginalHandler.ProcessRequestAsync(context, item)
        End If
    End Function

    Public Function AppliesTo(item As IHierarchyItemAsync) As Boolean Implements IMethodHandlerAsync(Of IHierarchyItemAsync).AppliesTo
        Return TypeOf item Is IFolderAsync OrElse OriginalHandler.AppliesTo(item)
    End Function

    Private Async Function WriteProfileAsync(context As ContextAsync(Of IHierarchyItemAsync), item As IHierarchyItemBaseAsync, htmlPath As String) As Task
        Dim mobileconfigFileName As String = Nothing
        Dim decription As String = Nothing
        If TypeOf item Is IAddressbookFolderAsync Then
            mobileconfigFileName = "CardDAV.AppleProfileTemplete.mobileconfig"
            decription = TryCast(item, IAddressbookFolderAsync).AddressbookDescription
        End If

        decription = If(Not String.IsNullOrEmpty(decription), decription, item.Name)
        Dim templateContent As String = Nothing
        Using reader As TextReader = New StreamReader(Path.Combine(htmlPath, mobileconfigFileName))
            templateContent = Await reader.ReadToEndAsync()
        End Using

        Dim url As Uri = New Uri(context.Request.UrlPrefix)
        Dim payloadUUID As String = item.Path.Split({"/"c}, StringSplitOptions.RemoveEmptyEntries).Last()
        Dim profile As String = String.Format(templateContent,
                                             url.Host, ' host name
                                             item.Path, ' CalDAV / CardDAV Principal URL. Here we can return (await (item as ICurrentUserPrincipalAsync).GetCurrentUserPrincipalAsync()).Path if needed.
                                             TryCast(context, DavContext).Identity.Name, ' user name
                                             url.Port, ' port                
                                             (url.Scheme = "https").ToString().ToLower(), ' SSL
                                             decription, ' CardDAV / CardDAV Account Description
                                             Assembly.GetAssembly(Me.GetType()).GetName().Version.ToString(),
                                             Assembly.GetAssembly(GetType(DavEngineAsync)).GetName().Version.ToString(),
                                             payloadUUID
                                             )
        Dim profileBytes As Byte() = SignProfile(context, profile)
        context.Response.ContentType = "application/x-apple-aspen-config"
        context.Response.AddHeader("Content-Disposition", "attachment; filename=profile.mobileconfig")
        context.Response.ContentLength = profileBytes.Length
        Await context.Response.OutputStream.WriteAsync(profileBytes, 0, profileBytes.Length)
    End Function

    Private Function SignProfile(context As ContextAsync(Of IHierarchyItemAsync), profile As String) As Byte()
        ' Here you will sign your profile with SSL certificate to avoid "Unsigned" warning on iOS and OS X.
        ' For demo purposes we just return the profile content unmodified.
        Return context.Engine.ContentEncoding.GetBytes(profile)
    End Function
End Class
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterPropertyHandler(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync)">
            <summary>
            Registers custom property handler.
            </summary>
            <param name="propName">Property name.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Property handler allows formatting of property values to XML and reading property values from XML.
            Using this method you can register custom property handler to be called by the engine.
            If the handler for the specified property was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterOptionsHandler(System.String,ITHit.WebDAV.Server.Extensibility.IOptionsHandler)">
            <summary>
            Registers custom options handler.
            </summary>
            <param name="name">Token that will be added to 'DAV' header for OPTIONS response.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom options handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterReportHandler(System.String,System.String,ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync)">
            <summary>
            Registers custom report handler.
            </summary>
            <param name="name">Report element name.</param>
            <param name="namespace">Report namespace.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom report handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RunAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Processes WebDAV request and generates WebDAV response.
            </summary>
            <param name="context">
            Instance of your context class derived from <see cref="T:ITHit.Server.ContextAsync`1"/> class.
            </param>
            <returns> .</returns>
            <remarks>
            You must call this method in each request to your WebDAV server passing your 
            context class derived from <see cref="T:ITHit.Server.ContextAsync`1"/> as input parameter. 
            </remarks>
            <example>
            <code>
            DavEngineAsync engine = new DavEngineAsync();
            engine.License = "...";
            ...
            MyContext context = new MyContext(HttpContext.Current);
            engine.RunAsync(context);
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.DisposeSafe(ITHit.Server.IHierarchyItemBaseAsync)">
            <summary>
            If item is not null and item implements <see cref="T:System.IDisposable"/> calls 
            <see cref="M:System.IDisposable.Dispose"/> wrapped in try-catch block.
            </summary>
            <param name="item">Item that can optionally implement <see cref="T:System.IDisposable"/>.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.ProcessWellKnownRequestAsync(ITHit.Server.IHierarchyItemBaseAsync,ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Sets 301 Moved Permanently in case of requests to '/.well-known/caldav' 
            or '/.well-known/carddav' url.
            </summary>
            <remarks>
            <para>
            Gives a chance for the user to return hierarchy item that coresponds to 
            well-known requests to CalDAV and CardDAV servers.
            </para>
            <para>
            http://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml
            http://tools.ietf.org/html/rfc5785
            http://tools.ietf.org/html/rfc6764
            </para>
            </remarks>
            <returns>Boolean value indicating if this is a well known request.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEnvironment">
            <summary>
            Exposes environment specific information like the .net runtime running.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavEnvironment.isRunningOnMono">
            <summary>
            Indicating whether the current .net runtime is mono or not.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEnvironment.#cctor">
            <summary>
            Initializes the <see cref="T:ITHit.WebDAV.Server.DavEnvironment"/> class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEnvironment.IsRunningOnMono">
            <summary>
            Gets a value indicating whether the current .net runtime is mono or not.
            </summary>
            <returns><code>True</code> if the current runtime is mono otherwise <code>false</code>.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavException">
            <summary>
            Exception which can be thrown by WebDAV interface implementations.
            </summary>
            <remarks>
            There are some other exceptions derived from this one which contain specific
            fields, like <see cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.ErrorDetails">
            <summary>
            Contains XML element name and namespace which will be written to the response body.
            It provides more information about error which can be interpreted by clients.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.Code">
            <summary>
            HTTP status code and description that will be sent to client.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor">
            <summary>
            Initializes a new instance of the DavException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message and a
            reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
            (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, status
            code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, details
            and status code.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message,
            description, status code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
             or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>
            <param name="item">Instance of <see cref="T:ITHit.Server.IHierarchyItemBaseAsync"/>.</param>
            <param name="renderContent">Some methods, like "HEAD" forbid any content in response, this parameter will
            be <c>false</c> in this 
            case and nothing shall be written in the response.</param>
            <remarks>
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.RenderInlineAsync(System.Xml.XmlWriter,ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in <see cref="M:ITHit.WebDAV.Server.DavException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)"/>
            method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavStatus">
            <summary>
            Represents HTTP status code with description.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.OK">
            <summary>
            Successful result.
            </summary>  
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNAUTHORIZED">
            <summary>
            The request requires user authentication.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CONFLICT">
            <summary>
            The request could not be completed due to a conflict with the current state of the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CREATED">
            <summary>
            The request has been fulfilled and resulted in a new resource being created.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY">
            <summary>
            This status code means that the method could
            not be performed on the resource because the requested action
            depended on another action and that action failed.  For example, if a
            command in a PROPPATCH method fails, then, at minimum, the rest of
            the commands will also fail with 424 (Failed Dependency).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.LOCKED">
            <summary>
            This status code means the source or destination resource
            of a method is locked.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NO_CONTENT">
            <summary>
            The server has fulfilled the request but does not need to return an entity-body, and might want to return
            updated metainformation.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED">
            <summary>
            The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED">
            <summary>
            The precondition given in one or more of the request-header fields evaluated to false when it was tested on
            the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INTERNAL_ERROR">
            <summary>
            The server encountered an unexpected condition which prevented it from fulfilling the request. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.BAD_REQUEST">
            <summary>
            The request could not be understood by the server due to malformed syntax.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MULTISTATUS">
            <summary>
            The 207 (Multi-Status) status code provides status for multiple
            independent operations.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_FOUND">
            <summary>
            The server has not found anything matching the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_MODIFIED">
            <summary>
            If the client has performed a conditional GET request and access is allowed, but the document has not been
            modified, the server SHOULD respond with this status code.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PARTIAL_CONTENT">
            <summary>
            The server has fulfilled the partial GET request for the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FORBIDDEN">
            <summary>
            The server understood the request, but is refusing to fulfill it.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_IMPLEMENTED">
            <summary>
            The server does not support the functionality required to fulfill the request. This is the appropriate 
            response when the server does not recognize the request method and is not capable of supporting it for any
            resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNSUPPORTED_MEDIA_TYPE">
            <summary>
            The server is refusing to service the request because the entity of the request is in a format not
            supported by the requested resource for the requested method. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MOVED_PERMANENTLY">
            <summary>
            The requested resource resides permanently under a different URI.
            </summary>
            <remarks>The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.</remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FOUND">
            <summary>
            The requested resource resides temporarily under a different URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INSUFFICIENT_STORAGE">
            <summary>
            The 507 (Insufficient Storage) status code means the method could not
            be performed on the resource because the server is unable to store
            the representation needed to successfully complete the request.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Code">
            <summary>
            HTTP status code.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Description">
            <summary>
            Status description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.HttpString">
            <summary>
            Formats status as HTTP string.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the DavStatus struct.
            </summary>
            <param name="code">HTTP status code.</param>
            <param name="description">Status description.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Equality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Inequality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.AutoVersion">
            <summary>
            Auto versioning modes supported by item to be used with versioning unaware clients.
            </summary>
            <remarks>
            <para>
            This enumeration determines how engine responds to WebDAV client requests that attempt to modify 
            checked-in items content or properties. Each item that support versioning can function in one of the following 
            auto-versioning modes:
            </para>
            <para>
            <b>NoAutoVersioning Mode.</b>
            In this mode item must be checked-out before modifications. Clients that does not support DeltaV will not be
            able to modify checked-in items.
            </para>
            <para>
            <b>CheckOutCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. Potentially many
            versions may be created. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
            <item><description>Auto check-out performed.</description></item>
            <item><description>Modifications performed.</description></item>
            <item><description>Auto check-in performed.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).</description></item>
            </list>
            </para>
            <para>
            <b>CheckOutUnlockedCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If WebDAV client
            locks the item prior to update, the item will be checked in during unlock. This mode reduces the number of
            versions created by versioning unaware clients. The item is never left checked-out. This mode is recommended if
            you need to support both Class 1 and Class 2 WebDAV clients. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                <item><description>Auto check-in performed if item not locked.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).
            <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
            </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>CheckOut Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If the item 
            was not locked before the update it will be left in checked-out state after modifications. Workflow for
            versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (optional). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>LockedCheckOut Mode.</b>
            Only WebDAV client applications that lock item before the update will be able to modify checked-in item. 
            This mode minimizes amount of versions created by versioning unaware clients. Class 1 WebDAV applications will 
            not be able to modify checked-in items. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (required).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (required). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.NoAutoVersioning">
            <summary>
            Auto versioning is not supported for checked-in items. Modification requests of versioning unaware clients
            will fail if item was not checked-out.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutCheckIn">
            <summary>
            Before any item modification (such as changing content or properties) 
            by versioning unaware client  engine will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/>. After the item is
            modified <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> will be called.
            </summary>
            <remarks>
            This potentially can create a lot of versions.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutUnlockedCheckIn">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/>. If item is not locked engine
            will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> when modification completes.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> will be called before the
            <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOut">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/>. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> will not be called.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> will be called before the
            <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.LockedCheckOut">
            <summary>
            If client tries to modify locked checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/>.
            <para>
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> will be called before the <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)"/>.
            If lock expires you must check-in item manually.
            </para>
            <para>
            If item is not locked - update request will fail.
            </para>
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync">
            <summary>
            Base interface for items that support versioning and item versions (DeltaV items).
            </summary>
            <remarks>
            This interface defines properties common to all items that support versioning and item versions. 
            It provides the means of getting and setting comments and author name when creating new version. 
            The author of the version is set and get via <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCreatorDisplayNameAsync(System.String)"/>,
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCreatorDisplayNameAsync"/>methods and comment via <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCommentAsync"/>,
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCommentAsync(System.String)"/> methods.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCommentAsync(System.String)">
            <summary>
            Sets a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <returns>
            .
            </returns>
            <param name="comment">Comment string.</param>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItemAsync.SetCommentAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCommentAsync">
            <summary>
            Retrieves a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <returns>Comment string.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItemAsync.GetCommentAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCreatorDisplayNameAsync(System.String)">
            <summary>
            Sets display name of the user that created this item.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            Sets description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <param name="creatorDisplayName">String representing author name.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItemAsync.SetCreatorDisplayNameAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCreatorDisplayNameAsync">
            <summary>
            Retrieves display name of the user that created this item.
            </summary>
            <remarks>
            Retrieves description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <returns>String representing author name.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItemAsync.GetCreatorDisplayNameAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IHistoryAsync">
            <summary>
            Contains all versions of a particular version-controlled item.
            </summary>
            <remarks>
            The important property of this interface is <see cref="T:System.IO.Path"/> property inherited from IHierarchyItem. 
            The url returned by this property is used by client applications to remove item from version control. 
            The client application submits DELETE WebDAV request to this url and the engine calls
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> 
            passing <b>false</b> as a parameter. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> you will
            usually delete all versions. 
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetCurrentVersionAsync">
            <summary>
            Retrieves current item version.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistoryAsync.GetCurrentVersionAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetVersionSetAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Retrieves all versions of current item.
            </summary>
            <returns>
            .
            </returns>
            <param name="propNames">Names of properties which engine will request from the returned items.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistoryAsync.GetVersionSetAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetRootVersionAsync">
            <summary>
            Retrieves item's root version.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistoryAsync.GetRootVersionAsync&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionAsync">
            <summary>
            Represents single item version.
            </summary>
            <remarks>
            <para>
            Defines the properties and methods that item version must implement. In addition to methods and properties
            provided by <see cref="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync"/> this interface also provides methods for getting version name, next
            version and previous version. 
            </para>
            <para>
            Usually you will implement <b>IVersion</b> interface for your file version objects together with
            <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync"/> interface. While <b>IFile</b> interface is optional for file versions it may be useful if
            your DeltaV client application will request content of the file version. In this case 
            <see cref="!:IContentAsync.ReadAsync"/>, <see cref="!:IContentAsync.ContentLength"/> and <see cref="!:IContentAsync.ContentType"/> 
            members of the <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync"/> interface will be requested by the engine. Copying, moving, updating 
            properties and content is not allowed for a version, your <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.CopyToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)"/>, 
            <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.MoveToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,ITHit.WebDAV.Server.MultistatusException)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/> and
            <see cref="!:IContentAsync.WriteAsync"/> implementations must throw <see cref="T:ITHit.WebDAV.Server.DavException"/> with status 
            <see cref="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED"/>.
            </para>
            <para>
            Generally from your <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionAsync.VersionName"/> implementation you can return any string suitable for 
            displaying to user as a version or the hierarchy item. This string must be unique among versions for this 
            hierarchy item. Usually you will return “1”, “2”, etc or “3.1”, “3.4”, etc. 
            </para>
            <para>
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetSuccessorAsync"/> and <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetPredecessorAsync"/> methods of this interface return next and previous
            version for the item. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetVersionableItemAsync"/> method returns the hierarchy item (usually file) to
            which this version belongs.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetSuccessorAsync">
            <summary>
            Next version or null if no next version exists.
            </summary>
            <returns>Version item representing next version
             in the list of versions or null if no next version exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionAsync.GetSuccessorAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetPredecessorAsync">
            <summary>
            Previous version or null if no previous version exists.
            </summary>
            <returns>Version item representing previous version in the list of versions or null if no previous version
            exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionAsync.GetPredecessorAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetVersionableItemAsync">
            <summary>
            Hierarchy item for this version.
            </summary>
            <returns>
            .
            </returns>
            <value>Hierarchy item for this version.</value>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionAsync.GetVersionableItemAsync&quot;]/*" />
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionAsync.VersionName">
            <summary>
            Name of the version.
            </summary>
            <value>Name of the version.</value>
            <remarks>
            Must be unique among version items for a given hierarchy item. This string is intended for display
            for a user.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionAsync.VersionName&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync">
            <summary>
            This interface must be implemented on items that support versioning.
            </summary>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version control
            engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> method passing <b>true</b> as a parameter.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> implementation you must create a new version. The content and
            properties of the new version must be copied from this item. After the call to 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must point to the object 
            implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistoryAsync"/> interface that will contain single version. The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut"/> 
            property must return <b>false</b>.
            </para>
            <para>
            <b>If item is under version control it mast always have at last one version in its versions list.</b>
            </para>
            <para>
            After the item had been put under version control client can issue checkout command.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/> implementation you will mark item as checked-out and allow item modifications.
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            <para>
            Finally client issues check-in command or discards changes issuing uncheck-out command.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> implementation you will create a new version. The content and properties of the
            new version must be copied from this item. The item must be marked as checked-in.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync"/> implementation you will discard changes and restore pre-checkout state.
            Content and properties must be copied from current version to this item. The item must be marked as checked-in.
            </para>
            <para>
            The typical versioning workflow:
            <list type="number">
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/>. Create new version,
            copy content and properties from this item to new version.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)"/>.
            Mark item as checked-out.</description></item>
            <item><description>Engine calls <see cref="!:IContentAsync.WriteAsync"/> or <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/>.
            Modify item content and properties.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> or
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync"/>. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync"/> - create new version, copy content and
            properties from this item to new version. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync"/> - copy content and properties from
            current version to this item. Mark item as checked-in.</description></item>
            </list>
            </para>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)"/> implementation you will create a new version and copy content and
            properties from <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersionAsync"/> passed as a parameter to new version. You will also replace content and
            properties of this item. The new created version becomes current version. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)"/> 
            method can only be called when item is in check-in state.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)"/> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must return <b>null</b> after this call.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory">
            <summary>
            Current item version history. Null, if item is not under version control.
            </summary>
            <value>
            Item implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistoryAsync" /> interface or null if item is not under version control.
            </value>
            <remarks>If item is under version control it always has at last
            one version in its versions list. This property is used for precondition checking and shall not throw
            exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.VersionHistory&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync">
            <summary>
            Creates new version. Copies all properties and content from this item.
            </summary>        
            <returns>
            Url of the newly created version.
            </returns>
            <remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <para>
            In your implementation you must create a new version. The content and properties of the new version must be
            copied from this item. 
            </para>
            <para>
            After the call to this method method <see cref="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetCurrentVersionAsync" /> must return the
            created version.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.CheckInAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)">
            <summary>
            Allow modifications to the content and properties of this version-controlled item.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)" /> implementation you will mark item as checked-out and allow item
            modifications. 
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.CheckOutAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync">
            <summary>
            Cancels the checkout and restores the pre-checkout state of the version-controlled item.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync" /> implementation you will discard changes and restore pre-checkout state. 
            Content and properties must be copied from current version to this item. The item must be marked as
            checked-in.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.UnCheckOutAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)">
            <summary>
            Updates content and properties of the item to those identified by <paramref name="version" /> parameter.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)" /> implementation you will create a new version and copy content and 
            properties from <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersionAsync" /> passed as a parameter to new version. You will also replace content 
            and properties of this item. The new created version becomes current version. 
            </para>
            <para>
            The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)" /> method can only be called when item is in check-in state.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.UpdateToVersionAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.SetAutoVersionAsync(ITHit.WebDAV.Server.DeltaV.AutoVersion)">
            <summary>
            Sets property which determines how checked-in item responds to
            WebDAV client attempts to modify its content or properties.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>        
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion" /> enum values.</value>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.SetAutoVersionAsync&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.GetAutoVersionAsync">
            <summary>
            Retrieves property which determines how checked-in item responds to WebDAV
            client attempts to modify its content or properties.
            </summary>
            <returns>
            .
            </returns>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion" /> enum values.</value>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.GetAutoVersionAsync&quot;]/*" />
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut">
            <summary>
            Gets a value indicating whether the item is in checked-in or checked-out state.
            </summary>
            <value>
            Boolean value indicating if item is in checked-out state.
            </value>
            <remarks>
            This property is used for precondition checking and shall not throw exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.IsCheckedOut&quot;]/*" />
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)">
            <summary>
            Puts or removes current item from version control.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version
            control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)" /> method passing <b>true</b> as a parameter.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)" /> implementation you must create a new version.
            The content and properties of the new version must be copied from this item. After the call to 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)" /> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory" /> property must point to the object 
            implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistoryAsync" /> interface that will contain single version.
            The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut" /> property must return <b>false</b>;
            </para>
            <para>
            <b>If item is under version control it mast always have at last one version in its
            versions list.</b>
            </para>
            <para>
            If <see cref="P:ITHit.WebDAV.Server.DavEngineAsync.AutoPutUnderVersionControl" /> is <b>true</b> and item is not under version control
            prior to any item content or properties update <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)" />
            will be called.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)" /> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory" /> property must return <b>null</b> after this call.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.PutUnderVersionControl&quot;]/*" />
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsAutoCheckedOut">
            <summary>
            Gets a value indicating whether the item was check-out automatically by engine without
            explicit request from client.
            </summary>
            <remarks>
            Before checking-out the engine sets this property.
            When item is being unlocked engine reads this property and calls 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync" /> if necessary. This property is required for auto-versioning.
            This property shall not throw exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItemAsync.IsAutoCheckedOut&quot;]/*" />
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating DeltaV server items and version controlling.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.EncodeUtil">
            <summary>
            Encodes/Decodes url parts.
            </summary>
            <remarks>
            This class shall be used to encode/decode parts of urls. Unlike <see cref="!:HttpUtility"/> class provided with .Net, this class encodes ' '(space) as %2b.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.EncodeUrlPart(System.String)">
            <summary>
            Encodes url part.
            </summary>
            <param name="part">Url part to encode.</param>
            <returns>Encoded url part.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.DecodeUrlPart(System.String)">
            <summary>
            Decodes url part.
            </summary>
            <param name="part">Url part to decode.</param>
            <returns>Decoded url part.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.ErrorDetails">
            <summary>
            Describes detail that can be passed to <see cref="T:ITHit.WebDAV.Server.DavException"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_IN">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-in property
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-out property
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_HISTORY">
            <summary>
            If the request-URL identifies a version history, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_COPY_HISTORY">
            <summary>
            If the request-URL identifies a version
            history, the request MUST fail. In order to create another
            version history whose versions have the same content and dead
            properties, the appropriate sequence of VERSION-CONTROL, CHECKOUT,
            PUT, PROPPATCH, and CHECKIN requests must be made
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT_VERSION_CONTROLLED_RESOURCE">
            <summary>
            The request-URL MUST identify a version-controlled resource with a DAV:checked-out property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.VERSION_HISTORY_IS_TREE">
            <summary>
            If the request-URL identifies a
            checked-out version-controlled resource that will be automatically
            checked in when the lock is removed, then the versions identified
            by the DAV:predecessor-set of the checked-out resource MUST be
            descendants of the root version of the version history for the
            DAV:checked-out version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_CONTENT">
            <summary>
            If the request-URL
            identifies a resource with a DAV:checked-in property, the request
            MUST fail unless DAV:auto-version semantics will automatically
            check out the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_PROPERTY">
            <summary>
            If the request attempts to modify a dead property, same semantics as PUT
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_LIVE_PROPERTY">
            <summary>
            If the request attempts to access a
            property defined by this document, the semantics of that property
            MUST be supported by the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_VERSION_DELETE">
            <summary>
            A server MAY fail an attempt to DELETE a version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_REPORT">
            <summary>
            The specified report MUST be supported by
            the resource identified by the request-URL.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_PROTECTED_PROPERTY">
            <summary>
            The client attempted to set a protected property in a PROPPATCH (such as DAV:getetag).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PROPFIND_FINITE_DEPTH">
            <summary>
            This server does not allow infinite-depth PROPFIND requests on collections.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PRESERVED_LIVE_PROPERTIES">
            <summary>
            The server received an otherwise-valid MOVE or COPY request, but
            cannot maintain the live properties with the same behavior at the destination. It may be that
            the server only supports some live properties in some parts of the repository, or simply has an
            internal error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_CONFLICTING_LOCK">
            <summary>
            A LOCK request failed due the presence of an already existing conflicting lock. Note that a
            lock can be in conflict although the resource to which the request was directed is only
            indirectly locked. In this case, the precondition code can be used to inform the client about
            the resource that is the root of the conflicting lock, avoiding a separate lookup of the
            "lockdiscovery" property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_SUBMITTED">
            <summary>
            The request could not succeed because a lock token should have been submitted. This
            element, if present, MUST contain at least one URL of a locked resource that prevented the
            request. In cases of MOVE, COPY, and DELETE where collection locks are involved, it can
            be difficult for the client to find out which locked resource made the request fail -- but the
            server is only responsible for returning one such locked resource. The server MAY return
            every locked resource that prevented the request from succeeding if it knows them all.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_MATCHES_REQUEST_URI">
            <summary>
            A request may include a Lock-Token header to identify a lock for the
            UNLOCK method. However, if the Request-URI does not fall within the scope of the lock
            identified by the token, the server SHOULD use this error. The lock may have a scope that
            does not include the Request-URI, or the lock could have disappeared, or the token may be
            invalid.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_EXTERNAL_ENTITIES">
            <summary>
            If the server rejects a client request because the request body contains an
            external entity, the server SHOULD use this error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS">
            <summary>
            The number of matching principals must fall within
            server-specific, predefined limits. For example, this condition might be triggered if a search specification
            would cause the return of an extremely large number of responses.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the ErrorDetails struct.
            </summary>
            <param name="namespace">Element namespace.</param>
            <param name="name">Element name.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Namespace">
            <summary>
            Gets element namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Name">
            <summary>
            Gets element name.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Equality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Inequality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Inequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler">
            <summary>
            Provides point of extension to OPTIONS request.
            </summary>
            <remarks>
            If you need to implement your own extension to WebDAV and add token to DAV header in OPTIONS response,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterOptionsHandler(System.String,ITHit.WebDAV.Server.Extensibility.IOptionsHandler)"/> method
            passing token as first argument to it.
            When building DAV header engine will call all registered options handlers to determine if this particular
            options is available for the item.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IOptionsHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            The method is called to determine if the option is available for the item and shall be
            enlisted in DAV header for OPTIONS response.
            </summary>
            <param name="item">Item for which request is made.</param>
            <returns><c>true</c>if option token shall be enlisted.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync">
            <summary>
            Provides point of extension to PROPFIND, PROPPATCH requests.
            </summary>
            <remarks>
            If you need to implement your own live property,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterPropertyHandler(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync)"/> method.
            Engine will call this handler when it needs to read/write the property.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.WriteAsync(System.Xml.XmlWriter,ITHit.WebDAV.Server.IHierarchyItemAsync,ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Writes property value to xml writer.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write property value.</param>
            <param name="item">Item for which to retrieve property.</param>
            <param name="context">Context.</param> 
            <returns>
            .
            </returns>       
            <remarks>
            Property writer shall retrieve and validate all values first and only then write anything to writer.
            Otherwise exception may be thrown while retrieving properties and output XML will be broken.
            </remarks>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.UpdateAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.WebDAV.Server.IHierarchyItemAsync,System.Xml.Linq.XElement)">
            <summary>
            Updates value of property.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item in which to update property.</param>
            <param name="value">Xml with property value.</param>
            <returns>
            .
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this property can be set/retrieved form an item.
            </summary>
            <param name="item">Item to determine whether property applies to it.</param>
            <returns><c>true</c> if the property applies to the item.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.IsReadonly">
            <summary>
            Gets a value indicating whether the property is readonly and cannot be updated.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.IncludeInAllProp">
            <summary>
            Gets a value indicating whether the property shall be included in 'allprop' response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync">
            <summary>
            Provides point of extension to REPORT requests.
            </summary>
            <remarks>
            If you need to implement your own report,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterReportHandler(System.String,System.String,ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync)"/> method.
            Engine will call this handler when it needs to execute a report.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this report can be executed for an item.
            </summary>
            <param name="item">Item to determine whether the report applies to it.</param>
            <returns><c>true</c> if the report applies to the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync.HandleReportAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.WebDAV.Server.IHierarchyItemAsync,System.Xml.Linq.XElement)">
            <summary>
            Generates report response.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item for which request is sent.</param>
            <param name="reportElement">Root request XML element.</param>
            <returns>
            .
            </returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.NamespaceDoc">
            <summary>
            This namespace provides interfaces for extending the engine with support of different methods, properties etc.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.IHierarchyItemAsync">
            <summary>
            Represents one item (file, folder) in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods common to all WebDAV folders and files.
            <see cref="P:ITHit.Server.IHierarchyItemBaseAsync.Created"/> and <see cref="P:ITHit.Server.IHierarchyItemBaseAsync.Modified"/> properties must return Universal Coordinated Time (UTC).
            <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/> are called when WebDAV client is reading, adding,
            updating or deleting properties.  This interface also provides methods for managing hierarchy: moving, copying
            and deleting WebDAV items.  See <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.CopyToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.MoveToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,ITHit.WebDAV.Server.MultistatusException)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.DeleteAsync(ITHit.WebDAV.Server.MultistatusException)"/> methods.
            Your file items must implement <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync"/> interface, folder items - <see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync"/> interface.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.CopyToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Creates a copy of this item with a new name in the destination folder.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="deep">Indicates whether to copy entire subtree.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus" /> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)" />.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">Destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT" /> if destination folder doesn't exist.
            </exception>
            <remarks>
            <para>
            If error occurred while copying file located in a subtree, the server 
            should try to continue copy operation and copy all other items. In this case 
            you must add that error <paramref name="multistatus" /> container.
            </para>
            <para>
            A CopyToAsync method invocation must not copy any locks active on the source item.
            However, if this method copies the item into a folder that has a deep lock,
            then the destination item must be added to the lock.
            </para>
            </remarks>
            <example>
            <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para><code lang="C#"><![CDATA[public override async Task CopyToAsync(IItemCollectionAsync destFolder, string destName, bool deep, MultistatusException multistatus)
{
    DavFolder targetFolder = (DavFolder)destFolder;

    if (targetFolder == null || !Directory.Exists(targetFolder.FullPath))
    {
        throw new DavException("Target directory doesn't exist", DavStatus.CONFLICT);
    }

    string newFilePath = System.IO.Path.Combine(targetFolder.FullPath, destName);
    string targetPath = targetFolder.Path + EncodeUtil.EncodeUrlPart(destName);

    // If an item with the same name exists - remove it.
    try
    {
        IHierarchyItemAsync item = await context.GetHierarchyItemAsync(targetPath);
        if (item != null)
            await item.DeleteAsync(multistatus);
    }
    catch (DavException ex)
    {
        // Report error with other item to client.
        multistatus.AddInnerException(targetPath, ex);
        return;
    }

    // Copy the file togather with all extended attributes (custom props and locks).
    try
    {
        File.Copy(fileSystemInfo.FullName, newFilePath);

        var newFileSystemInfo = new FileInfo(newFilePath);
        if (FileSystemInfoExtension.IsUsingFileSystemAttribute)
        {
            await fileSystemInfo.CopyExtendedAttributes(newFileSystemInfo);
        }

        // Locks should not be copied, delete them.
        if (await fileSystemInfo.HasExtendedAttributeAsync("Locks"))
        {
            await newFileSystemInfo.DeleteExtendedAttributeAsync("Locks");
        }
    }
    catch (UnauthorizedAccessException)
    {
        // Fail
        NeedPrivilegesException ex = new NeedPrivilegesException("Not enough privileges");
        string parentPath = System.IO.Path.GetDirectoryName(Path);
        ex.AddRequiredPrivilege(parentPath, Privilege.Bind);
        throw ex;
    }
    await context.socketService.NotifyCreatedAsync(targetPath);
}
]]></code><code lang="VB"><![CDATA[Public Overrides Async Function CopyToAsync(destFolder As IItemCollectionAsync, destName As String, deep As Boolean, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.CopyToAsync
    Dim targetFolder As DavFolder = CType(destFolder, DavFolder)
    If targetFolder Is Nothing OrElse Not Directory.Exists(targetFolder.FullPath) Then
        Throw New DavException("Target directory doesn't exist", DavStatus.CONFLICT)
    End If

    Dim newFilePath As String = System.IO.Path.Combine(targetFolder.FullPath, destName)
    Dim targetPath As String = targetFolder.Path & EncodeUtil.EncodeUrlPart(destName)
    ' If an item with the same name exists - remove it.
    Try
        Dim item As IHierarchyItemAsync = Await context.GetHierarchyItemAsync(targetPath)
        If item IsNot Nothing Then Await item.DeleteAsync(multistatus)
    Catch ex As DavException
        ' Report error with other item to client.
        multistatus.AddInnerException(targetPath, ex)
        Return
    End Try

    ' Copy the file togather with all extended attributes (custom props and locks).
    Try
        File.Copy(fileSystemInfo.FullName, newFilePath)
        Dim newFileSystemInfo = New FileInfo(newFilePath)
        If FileSystemInfoExtension.IsUsingFileSystemAttribute Then
            Await fileSystemInfo.CopyExtendedAttributes(newFileSystemInfo)
        End If

        ' Locks should not be copied, delete them.
        If Await fileSystemInfo.HasExtendedAttributeAsync("Locks") Then
            Await newFileSystemInfo.DeleteExtendedAttributeAsync("Locks")
        End If
    Catch __unusedUnauthorizedAccessException1__ As UnauthorizedAccessException
        ' Fail
        Dim ex As NeedPrivilegesException = New NeedPrivilegesException("Not enough privileges")
        Dim parentPath As String = System.IO.Path.GetDirectoryName(Path)
        ex.AddRequiredPrivilege(parentPath, Privilege.Bind)
        Throw ex
    End Try

    Await context.socketService.NotifyCreatedAsync(targetPath)
End Function

]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.MoveToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Moves this item to the destination folder under a new name.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus" /> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)" />.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The source or the destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT" /> if destination folder doesn't exist.
            </exception>
            <remarks>
            <papa>
            If the item is locked the server must not move any locks with the item. However, items must be added to an
            existing lock at the destination.
            </papa>
            </remarks>
            <example>
            <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para><code lang="C#"><![CDATA[public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
{
    await RequireHasTokenAsync();

    DavFolder targetFolder = (DavFolder)destFolder;

    if (targetFolder == null || !Directory.Exists(targetFolder.FullPath))
    {
        throw new DavException("Target directory doesn't exist", DavStatus.CONFLICT);
    }

    string newDirPath = System.IO.Path.Combine(targetFolder.FullPath, destName);
    string targetPath = targetFolder.Path + EncodeUtil.EncodeUrlPart(destName);

    // If an item with the same name exists in target directory - remove it.
    try
    {
        IHierarchyItemAsync item = await context.GetHierarchyItemAsync(targetPath) as IHierarchyItemAsync;

        if (item != null)
        {
            await item.DeleteAsync(multistatus);
        }
    }
    catch (DavException ex)
    {
        // Report exception to client and continue with other items by returning from recursion.
        multistatus.AddInnerException(targetPath, ex);
        return;
    }

    // Move the file.
    try
    {
        File.Move(fileSystemInfo.FullName, newDirPath);

        FileInfo newFileInfo = new FileInfo(newDirPath);
        if (FileSystemInfoExtension.IsUsingFileSystemAttribute)
        {
            await fileSystemInfo.MoveExtendedAttributes(newFileInfo);
        }

        // Locks should not be copied, delete them.
        if (await newFileInfo.HasExtendedAttributeAsync("Locks"))
            await newFileInfo.DeleteExtendedAttributeAsync("Locks");
    }
    catch (UnauthorizedAccessException)
    {
        // Exception occurred with the item for which MoveTo was called - fail the operation.
        NeedPrivilegesException ex = new NeedPrivilegesException("Not enough privileges");
        ex.AddRequiredPrivilege(targetPath, Privilege.Bind);

        string parentPath = System.IO.Path.GetDirectoryName(Path);
        ex.AddRequiredPrivilege(parentPath, Privilege.Unbind);
        throw ex;
    }
    // Refresh client UI.
    await context.socketService.NotifyMovedAsync(Path, targetPath);
}
]]></code><code lang="VB"><![CDATA[Public Overrides Async Function MoveToAsync(destFolder As IItemCollectionAsync, destName As String, multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.MoveToAsync
    Await RequireHasTokenAsync()
    Dim targetFolder As DavFolder = CType(destFolder, DavFolder)
    If targetFolder Is Nothing OrElse Not Directory.Exists(targetFolder.FullPath) Then
        Throw New DavException("Target directory doesn't exist", DavStatus.CONFLICT)
    End If

    Dim newDirPath As String = System.IO.Path.Combine(targetFolder.FullPath, destName)
    Dim targetPath As String = targetFolder.Path & EncodeUtil.EncodeUrlPart(destName)
    ' If an item with the same name exists in target directory - remove it.
    Try
        Dim item As IHierarchyItemAsync = TryCast(Await context.GetHierarchyItemAsync(targetPath), IHierarchyItemAsync)
        If item IsNot Nothing Then
            Await item.DeleteAsync(multistatus)
        End If
    Catch ex As DavException
        ' Report exception to client and continue with other items by returning from recursion.
        multistatus.AddInnerException(targetPath, ex)
        Return
    End Try

    ' Move the file.
    Try
        File.Move(fileSystemInfo.FullName, newDirPath)
        Dim newFileInfo As FileInfo = New FileInfo(newDirPath)
        If FileSystemInfoExtension.IsUsingFileSystemAttribute Then
            Await fileSystemInfo.MoveExtendedAttributes(newFileInfo)
        End If

        ' Locks should not be copied, delete them.
        If Await newFileInfo.HasExtendedAttributeAsync("Locks") Then Await newFileInfo.DeleteExtendedAttributeAsync("Locks")
    Catch __unusedUnauthorizedAccessException1__ As UnauthorizedAccessException
        ' Exception occurred with the item for which MoveTo was called - fail the operation.
        Dim ex As NeedPrivilegesException = New NeedPrivilegesException("Not enough privileges")
        ex.AddRequiredPrivilege(targetPath, Privilege.Bind)
        Dim parentPath As String = System.IO.Path.GetDirectoryName(Path)
        ex.AddRequiredPrivilege(parentPath, Privilege.Unbind)
        Throw ex
    End Try

    ' Refresh client UI.
    Await context.socketService.NotifyMovedAsync(Path, targetPath)
End Function

]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.DeleteAsync(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Deletes this item.
            </summary>
            <param name="multistatus">If some items fail to delete but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus" /> using
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)" />.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item or its parent was locked and client did not provide lock
            token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree
            and whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT" /> if destination folder doesn't exist.
            </exception>
            <example>
            <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para><code lang="C#"><![CDATA[public override async Task DeleteAsync(MultistatusException multistatus)
{
    await RequireHasTokenAsync();
    if (FileSystemInfoExtension.IsUsingFileSystemAttribute)
    {
        await fileSystemInfo.DeleteExtendedAttributes();
    }

    fileSystemInfo.Delete();
    await context.socketService.NotifyDeletedAsync(Path);
}
]]></code><code lang="VB"><![CDATA[Public Overrides Async Function DeleteAsync(multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.DeleteAsync
    Await RequireHasTokenAsync()
    If FileSystemInfoExtension.IsUsingFileSystemAttribute Then
        Await fileSystemInfo.DeleteExtendedAttributes()
    End If

    fileSystemInfo.Delete()
    Await context.socketService.NotifyDeletedAsync(Path)
End Function

]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)">
            <summary>
            Gets values of all properties or selected properties for this item.
            </summary>
            <param name="props">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> with property names which values are requested by WebDAV client. 
            If a property does not exist for this hierarchy item then the property value shall not be returned.
            </param>
            <param name="allprop">
            If it is <c>true</c> it means that besides properties listed in <paramref name="props" /> you need to 
            return all properties you think may be useful to client.
            </param>
            <returns>
            Enumerable with property values.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> props, bool allprop)
{
    List<PropertyValue> propertyValues = await GetPropertyValuesAsync();

    PropertyName snippet = props.FirstOrDefault(s => s.Name == snippetProperty);
    if (snippet.Name == snippetProperty && this is DavFile)
    {
        propertyValues.Add(new PropertyValue(snippet, ((DavFile)this).Snippet));
    }

    if (!allprop)
    {
        propertyValues = propertyValues.Where(p => props.Contains(p.QualifiedName)).ToList();
    }

    return propertyValues;
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetPropertiesAsync(props As IList(Of PropertyName), allprop As Boolean) As Task(Of IEnumerable(Of PropertyValue)) Implements IHierarchyItemAsync.GetPropertiesAsync
    Dim propertyValues As List(Of PropertyValue) = Await GetPropertyValuesAsync()
    Dim snippet As PropertyName = props.FirstOrDefault(Function(s) s.Name = snippetProperty)
    If snippet.Name = snippetProperty AndAlso TypeOf Me Is DavFile Then
        propertyValues.Add(New PropertyValue(snippet, CType(Me, DavFile).Snippet))
    End If

    If Not allprop Then
        propertyValues = propertyValues.Where(Function(p) props.Contains(p.QualifiedName)).ToList()
    End If

    Return propertyValues
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertyNamesAsync">
            <summary>
            Gets names of all properties for this item.
            </summary>
            <returns>
            Enumerable with available property names.
            </returns>
            <remarks>
            <para>Most WebDAV clients never request list of property names, so your implementation can just return
            empty enumerable.</para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<IEnumerable<PropertyName>> GetPropertyNamesAsync()
{
    IList<PropertyValue> propertyValues = await GetPropertyValuesAsync();
    return propertyValues.Select(p => p.QualifiedName);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetPropertyNamesAsync() As Task(Of IEnumerable(Of PropertyName)) Implements IHierarchyItemAsync.GetPropertyNamesAsync
    Dim propertyValues As IList(Of PropertyValue) = Await GetPropertyValuesAsync()
    Return propertyValues.Select(Function(p) p.QualifiedName)
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds, modifies and removes properties for this item.
            </summary>
            <param name="setProps">List of properties to be set.</param>
            <param name="delProps">List of property names to be removed. Properties that don't exist shall be skipped.</param>
            <param name="multistatus">The standard requires this operation to be transactional.
            If some properties fail to update but there is no possibility to rollback the transaction
            in <see cref="M:ITHit.Server.ContextAsync`1.BeforeResponseAsync" />, add
            information about the error into <paramref name="multistatus" /> 
            using <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)" />.
            In this case engine will report correct statuses for all properties at least
            (although this is against standard).
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked and client
            did not provide lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">
            The exception shall contain statuses for all properties that
            failed to update.
            Typical property error statuses:
            <list type="bullet">
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT" /> - the client has provided a value
            whose semantics are not appropriate for the property, this includes
            trying to set read-only properties.
            </description>
            </item>
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY" /> - indicates this action would
            have succeeded if it were not for the conflict with
            updating/removing some other property.
            </description>
            </item>
            </list>
            </exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)" /> implementation you will create,
            modify and delete item properties.
            Single property update request may invoke following methods of single item which update properties:
            <list type="bullet">
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetOwnerAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetGroupAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.SetAutoVersionAsync(ITHit.WebDAV.Server.DeltaV.AutoVersion)" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCommentAsync(System.String)" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCreatorDisplayNameAsync(System.String)" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.SetGroupMembersAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.IPrincipalAsync})" /></item>
                <item><see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)" /></item>
            </list>
            Engine will update properties (call these methods) one by one unless exception is thrown.
            If an exception is thrown during a property update engine will report all remaining properties
            as failed with status <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY" />
            </para>
            <para>
            The standard requires that request which updates properties is atomic (PROPPATCH).
            If your storage supports transactions then atomicity requirement can be implemented
            by committing or rollbacking the transaction in <see cref="M:ITHit.Server.ContextAsync`1.BeforeResponseAsync" />.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task UpdatePropertiesAsync(IList<PropertyValue> setProps, IList<PropertyName> delProps, MultistatusException multistatus)
{
    await RequireHasTokenAsync();
    List<PropertyValue> propertyValues = await GetPropertyValuesAsync();
    foreach (PropertyValue propToSet in setProps)
    {
        // Microsoft Mini-redirector may update file creation date, modification date and access time passing properties:
        // <Win32CreationTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:15:34 GMT</Win32CreationTime>
        // <Win32LastModifiedTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastModifiedTime>
        // <Win32LastAccessTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastAccessTime>
        // In this case update creation and modified date in your storage or do not save this properties at all, otherwise 
        // Windows Explorer will display creation and modification date from this props and it will differ from the values 
        // in the Created and Modified fields in your storage 
        if (propToSet.QualifiedName.Namespace == "urn:schemas-microsoft-com:")
        {
            switch (propToSet.QualifiedName.Name)
            {
                case "Win32CreationTime":
                    fileSystemInfo.CreationTimeUtc = DateTime.Parse(propToSet.Value,
                        new System.Globalization.CultureInfo("en-US")).ToUniversalTime();
                    break;
                case "Win32LastModifiedTime":
                    fileSystemInfo.LastWriteTimeUtc = DateTime.Parse(propToSet.Value,
                        new System.Globalization.CultureInfo("en-US")).ToUniversalTime();
                    break;
                default:
                    context.Logger.LogDebug(string.Format("Unspecified case: DavHierarchyItem.UpdateProperties {0} from {1} namesapce",
                        propToSet.QualifiedName.Name, propToSet.QualifiedName.Namespace));
                    break;
            }
        }
        else
        {
            PropertyValue existingProp = propertyValues.FirstOrDefault(p => p.QualifiedName == propToSet.QualifiedName);

            if (existingProp != null)
            {
                existingProp.Value = propToSet.Value;
            }
            else
            {
                propertyValues.Add(propToSet);
            }
        }
    }

    propertyValues.RemoveAll(prop => delProps.Contains(prop.QualifiedName));

    await fileSystemInfo.SetExtendedAttributeAsync(propertiesAttributeName, propertyValues);
    await context.socketService.NotifyUpdatedAsync(Path);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function UpdatePropertiesAsync(setProps As IList(Of PropertyValue), delProps As IList(Of PropertyName), multistatus As MultistatusException) As Task Implements IHierarchyItemAsync.UpdatePropertiesAsync
    Await RequireHasTokenAsync()
    Dim propertyValues As List(Of PropertyValue) = Await GetPropertyValuesAsync()
    For Each propToSet As PropertyValue In setProps
        ' Microsoft Mini-redirector may update file creation date, modification date and access time passing properties:
        ' <Win32CreationTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:15:34 GMT</Win32CreationTime>
        ' <Win32LastModifiedTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastModifiedTime>
        ' <Win32LastAccessTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastAccessTime>
        ' In this case update creation and modified date in your storage or do not save this properties at all, otherwise 
        ' Windows Explorer will display creation and modification date from this props and it will differ from the values 
        ' in the Created and Modified fields in your storage 
        If propToSet.QualifiedName.Namespace = "urn:schemas-microsoft-com:" Then
            Select Case propToSet.QualifiedName.Name
                Case "Win32CreationTime"
                    fileSystemInfo.CreationTimeUtc = DateTime.Parse(propToSet.Value,
                                                                   New System.Globalization.CultureInfo("en-US")).ToUniversalTime()
                Case "Win32LastModifiedTime"
                    fileSystemInfo.LastWriteTimeUtc = DateTime.Parse(propToSet.Value,
                                                                    New System.Globalization.CultureInfo("en-US")).ToUniversalTime()
                Case Else
                    context.Logger.LogDebug(String.Format("Unspecified case: DavHierarchyItem.UpdateProperties {0} from {1} namesapce",
                                                         propToSet.QualifiedName.Name, propToSet.QualifiedName.Namespace))
            End Select
        Else
            Dim existingProp As PropertyValue = propertyValues.FirstOrDefault(Function(p) p.QualifiedName = propToSet.QualifiedName)
            If existingProp IsNot Nothing Then
                existingProp.Value = propToSet.Value
            Else
                propertyValues.Add(propToSet)
            End If
        End If
    Next

    propertyValues.RemoveAll(Function(prop) delProps.Contains(prop.QualifiedName))
    Await fileSystemInfo.SetExtendedAttributeAsync(propertiesAttributeName, propertyValues)
    Await context.socketService.NotifyUpdatedAsync(Path)
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.IItemCollectionAsync">
            <summary>
            Base interface for folders.
            </summary>
            <remarks>
            <para>Base interface for all kinds of folders (<see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync"/>, <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync"/> etc.).</para>
            <para>In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/> interface this interface also provides <see cref="M:ITHit.WebDAV.Server.IItemCollectionAsync.GetChildrenAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Collections.Generic.IList{ITHit.WebDAV.Server.Paging.OrderProperty})"/> method to list all children of this folder.</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IItemCollectionAsync.GetChildrenAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Collections.Generic.IList{ITHit.WebDAV.Server.Paging.OrderProperty})">
            <summary>
            Gets direct children of this folder.
            </summary>
            <param name="propNames">List of properties requested by the client.</param>
            <param name="offset">The number of items to skip before returning the remaining items.</param>
            <param name="nResults">The number of items to return.</param>
            <param name="orderProps">List of order properties requested by the client.</param>
            <returns>Instance of <see cref="T:ITHit.WebDAV.Server.Paging.PageResults" /> class that contains items on a requested page and total number of items in a folder.</returns>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public virtual async Task<PageResults> GetChildrenAsync(IList<PropertyName> propNames, long? offset, long? nResults, IList<OrderProperty> orderProps)
{
    // Enumerates all child files and folders.
    // You can filter children items in this implementation and 
    // return only items that you want to be visible for this 
    // particular user.

    IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();

    long totalItems = 0;
    FileSystemInfo[] fileInfos = dirInfo.GetFileSystemInfos();
    totalItems = fileInfos.Length;

    // Apply sorting.
    fileInfos = SortChildren(fileInfos, orderProps);

    // Apply paging.
    if (offset.HasValue && nResults.HasValue)
    {
        fileInfos = fileInfos.Skip((int)offset.Value).Take((int)nResults.Value).ToArray();
    }

    foreach (FileSystemInfo fileInfo in fileInfos)
    {
        string childPath = Path + EncodeUtil.EncodeUrlPart(fileInfo.Name);
        IHierarchyItemAsync child = await context.GetHierarchyItemAsync(childPath);
        if (child != null)
        {
            children.Add(child);
        }
    }

    return new PageResults(children, totalItems);
}
]]></code>
      <code lang="VB"><![CDATA[Public Overridable Async Function GetChildrenAsync(propNames As IList(Of PropertyName), offset As Long?, nResults As Long?, orderProps As IList(Of OrderProperty)) As Task(Of PageResults) Implements IItemCollectionAsync.GetChildrenAsync
    ' Enumerates all child files and folders.
    ' You can filter children items in this implementation and 
    ' return only items that you want to be visible for this 
    ' particular user.
    Dim children As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
    Dim totalItems As Long = 0
    Dim fileInfos As FileSystemInfo() = dirInfo.GetFileSystemInfos()
    totalItems = fileInfos.Length
    ' Apply sorting.
    fileInfos = SortChildren(fileInfos, orderProps)
    ' Apply paging.
    If offset.HasValue AndAlso nResults.HasValue Then
        fileInfos = fileInfos.Skip(CInt(offset.Value)).Take(CInt(nResults.Value)).ToArray()
    End If

    For Each fileInfo As FileSystemInfo In fileInfos
        Dim childPath As String = Path & EncodeUtil.EncodeUrlPart(fileInfo.Name)
        Dim child As IHierarchyItemAsync = Await context.GetHierarchyItemAsync(childPath)
        If child IsNot Nothing Then
            children.Add(child)
        End If
    Next

    Return New PageResults(children, totalItems)
End Function

]]></code>
    </example>   
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ArgumentUtil">
            <summary>
            Utility to check arguments.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgumentNotNull(System.Object,System.String)">
            <summary>
            Checks that argument is not null.
            </summary>
            <param name="obj">Argument to check.</param>
            <param name="paramName">Argument name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgument(System.Boolean,System.String)">
            <summary>
            Checks argument for certain condition.
            </summary>
            <param name="b">Condition result.</param>
            <param name="s">Argument name.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav">
            <summary>
            DeltaV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav.PropertyNames">
            <summary>
            DeltaV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamInput">
            <summary>
            Logs input content
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamOutput">
            <summary>
            Calculates content length ang logs output content
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.FilterStreamOutput.FinishWriting">
            <summary>
            Synchronous version, can be used for .Net Core 2.x
            Writes the entire contents of this memory stream to output .
            </summary>
            <returns></returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler">
            <summary>
            Summary description for AclDAVHandler.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this method shall be enlisted in 'supported-method-set' for 
            <paramref name="item"/>.
            </summary>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.Server.ContextAsync`1.GetHierarchyItemAsync(System.String)"/> or <b>null</b>.</param>
            <returns>Boolean indicating whether this handler implementation can handle request for the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.ProcessRequestAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Processes request.
            </summary>
            <param name="context">Instance of context class derived from <see cref="T:ITHit.Server.ContextAsync`1"/> class.</param>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.Server.ContextAsync`1.GetHierarchyItemAsync(System.String)"/> or <b>null</b>.</param>
            <remarks>The <see cref="!:IMethodHandlerAsync.ProcessRequestAsync(ContextAsync&lt;IHierarchyItemAsync&gt;, IHierarchyItemAsync)"/> method is called by the engine during <see cref="M:ITHit.WebDAV.Server.DavEngineAsync.RunAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})"/> call. 
            The hierarchy item returned from <see cref="M:ITHit.Server.ContextAsync`1.GetHierarchyItemAsync(System.String)"/> is passed to this method. 
            If <see cref="M:ITHit.Server.ContextAsync`1.GetHierarchyItemAsync(System.String)"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseDavHandler">
            <summary>
            Summary description for BaseDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo">
            <summary>
            Information about file being uploaded.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.GetParentAsync">
            <summary>
            Returns parent folder and name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Name">
            <summary>
            Gets name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Stream">
            <summary>
            Gets upload stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentType">
            <summary>
            Gets file's content type.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentLength">
            <summary>
            Gets content length.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.UpdateFileDataAsync(ITHit.Server.RequestAsync,ITHit.Server.IContentAsync,System.IO.Stream,System.Int64,System.String)">
            <summary>
            Returns true if file was updated completely (or last chunk written),
            so file can be automatically checked in.
            </summary>
            <param name="request"></param>
            <param name="file"></param>
            <param name="inputStream"></param>
            <param name="length"></param>
            <param name="contentType"></param>
            <returns></returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CancelUploadDavHandler">
            <summary>
            Summary description for CancelUploadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CopyDavHandler">
            <summary>
            Summary description for CopyDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.DeleteDavHandler">
            <summary>
            Summary description for DeleteDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.GetDavHandler">
            <summary>
            Summary description for GetDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.HeadDavHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.LockDavHandler">
            <summary>
            Summary description for LockDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler">
            <summary>
             An HTTP request using the MKCALENDAR method creates a new calendar collection resource.
            </summary>
            <remarks>
            The implementation is not optimal, because it makes extra call to GetHierarchyItem in 
            case url is not eaquel to displayname
            http://tools.ietf.org/html/rfc4791#section-5.3.1
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler.ProcessRequestAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            When creating new calendars iCal submits request that looks like the following:
            MKCALENDAR https://base/calendars/Volodymyr/423C82A5-CB6F-475D-A564-3AA73C5EAA39/
            but specifies display name in the displayname property, which is totally according to RFC
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcolDavHandler">
            <summary>
            Summary description for MkcolDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MoveDavHandler">
            <summary>
            Summary description for MoveDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PostDavHandler">
            <summary>
            Summary description for PostDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PropfindDavHandler">
            <summary>
            Summary description for PropfindDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.ProppatchDavHandler">
            <summary>
            Summary description for ProppatchDavHandler
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.SearchDavHandler">
            <summary>
            Summary description for SearchDavHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.UnlockDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse">
            Status for an items to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
             Initializes a new instance.
            
             @param itemPath Path of the item in the hierarchy tree.
             @param status WebDAV response for the item.
             @param href href to be included in the response.
             @param responseDescription description of the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Hrefs">
             Hrefs included in the response.
            
             @return path of the item.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Code">
             Gets the response for the item.
            
             @return response for the item
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.MultistatusResponse.AddResponse(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
            <summary>
            Adds new responses to the private collection in this class.
            </summary>
            <param name="path"></param>
            <param name="code"></param>
            <param name="href"></param>
            <param name="responseDescription"></param>   
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStat">
            Status for a number of properties to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.#ctor(System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyValue},ITHit.WebDAV.Server.DavException)">
            Initializes new instance.
            @param property list of properties with the same status.
            @param status status for these properties.
            @param description description.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.Properties">
            Retrieves list of properties with the same status.
            @return list of properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse">
            Response that may be present in multistatus response.
            Describes status of properties relating to the same item.
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.#ctor(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.Impl.Multistatus.PropStat},System.String)">
             Initializes new instance.
            
             @param itemPath    path to item which contains these properties.
             @param propStats   statuses for different properties related to this item.
             @param description description for the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.PropStats">
             Retrieves statuses for properties grouped by item they relate to.
            
             @return statuses for properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.Response">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.Response.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.AllowedSharingModes">
            <summary>
            Defines allowed sharing modes for calendar.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.CalendarHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            calendar collections owned by the associated principal resource.
            </summary>
            <remarks>
            <param>
            This property SHOULD be defined on a principal
            resource.  If defined, it MAY be protected and SHOULD NOT be
            returned by a PROPFIND DAV:allprop request (as defined in Section
            12.14.1 of [RFC2518]).
            </param>
            <param>
            The CALDAV:calendar-home-set property is meant to allow
             users to easily find the calendar collections owned by the
             principal.  Typically, users will group all the calendar
             collections that they own under a common collection.  This
             property specifies the URL of collections that are either calendar
             collections or ordinary collections that have child or descendant
             calendar collections owned by the principal.
             </param>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.Invite">
            <summary>
            Used to show to whom a calendar has been shared.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CardDav.AddressbookHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            address book collections owned by the associated principal
            resource.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarMultigetReportHandler.GetHierarchyItemsAsync(ITHit.WebDAV.Server.IHierarchyItemAsync,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="item">Instance of <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/>.</param>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarQueryReportHandler">
            <summary>
            Processes calendar-query report.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CardDav.AddressbookMultigetReportHandler.GetHierarchyItemsAsync(ITHit.WebDAV.Server.IHierarchyItemAsync,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="item">Instance of <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/>.</param>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.CardDav.AddressbookQueryReportHandler">
            <summary>
            Processes addressbook-query report.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.MultigetReportHandler">
            <summary>
            Base class for processing <b>calendar-multiget</b> report and <b>addressbook-multiget</b> reports.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.QueryReportHandler">
            <summary>
            Base class for processing <b>calendar-query</b> report and <b>addressbook-query</b> reports.
            </summary>    
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.QueryReportHandler.GetDepth(ITHit.Server.RequestAsync)">
            <summary>
            The request MAY include a Depth header.  If no Depth header is included, Depth:0 is assumed.
            http://tools.ietf.org/html/rfc4791#section-7.8
            </summary>
            <returns>
            This implementation is different from the ITHit.WebDAV.Server.Impl.Util.DavRequestExtensions.GetDepth() 
            implementation. This one returns 1 in case Depth heder is not present.
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.ReadTillSeparatorInChunksAsync(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            After this method <see cref="F:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.readCachedData"/> contains cached data right after next boundary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Sharing">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.StreamAdaptorBase">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.#ctor(System.IO.Stream)">
            <summary>
            Stream adaptor constructor
            </summary>
            <param name="stream">Underlaying stream to operate</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Read from underlaying stream
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Writes to underlaying stream
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously flush underlaying stream
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.Flush">
            <summary>
            Flush underlaying stream
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.Dispose(System.Boolean)">
            <summary>
            Releases all resources used by the System.IO.Stream.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances
            the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns>The total number of bytes read into the buffer. This can be less than the number
                of bytes requested if that many bytes are not currently available, or zero (0)
                if the end of the stream has been reached.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.StreamAdaptorBase.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances 
            the current position within this stream by the number of
            bytes written.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Url">
            <summary>
            TODO: Update summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav.PropertyNames">
            <summary>
            WebDAV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav.PropertyLimit">
            <summary>
            WebDAV Limit Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.InvalidLicenseException">
            <summary>
            Exception that indicates that the license is invalid.
            </summary>
            <remarks>The license is invalid.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseChecker">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CheckLicenseAsync(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CheckLicenseAsync(System.String,System.String)">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseModule">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseValidator">
            <summary>
            Validates license file.
            </summary>
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.License.LicenseValidator.Modules">
            <summary>
            Contains names of modules
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseValidator.CheckLicenseIsValidAsync(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseValidator.CheckLicenseModule(ITHit.WebDAV.Server.License.LicenseModule)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseValidator.CheckLicenseIsValidAsync(System.String,System.String[])">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl">
            <summary>
            Default logger implementation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogDebug(System.String)">
            <summary>
            Logs in debug mode.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogError(System.String,System.Exception)">
            <summary>
            Logs message in error mode.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="exception">Exception to be logged.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFile">
            <summary>
            Log file path.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.FileSize">
            <summary>
            Gets and sets maximum log file size in bytes.
            </summary>
            <value>
            Maximum log file size in bytes. Default is 1048576 bytes.
            </value>
            <remarks>
            When the file exceeds the size specified by <c>FileSize</c> the new log file is created. The old file is renamed to &lt;filename&gt;.&lt;number&gt;.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.MaxBackups">
            <summary>
            Gets and sets Maximum number of log file backups.
            </summary>
            <value>
            Amount of log file backups. Default is 1.
            </value>
            <remarks>
            If the amount of the backup files created is higher than <c>MaxBackups</c> the oldest file is automatically deleted.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.IsDebugEnabled">
            <summary>
            Determines whether debug mode is enabled.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFlags">
            <summary>
            Logging flags.
            </summary>
            <remarks>By default Engine does not log GET response body and PUT request body.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.FileLogger">
            <summary>
            Provides static methods for writing to a log file.
            </summary>
            <remarks>
            <param>
            By default the log file is not created if you did not specify log file name.
            You can specify the folder and file name setting <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile"/> property. 
            Amount of output and maximum file size are controlled via <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.Level"/> and <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize"/> properties.
            </param>
            <param>
            <b>Important!</b> If you host your server in IIS/ASP.NET make sure your log file is created outside of the \bin folder. If your logfile will be created in a \bin folder, your server will restart each time the logfile is updated, recycling application and session state.
            </param>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile">
            <summary>
            Gets and sets log file name and path.
            </summary>
            <value>
            Log file name and path.
            </value>
            <remarks>
            <param>
            By default the log file is created in the folder where the calling assembly 
            resides. The folder in which you plan store your log files must exist and 
            your web application must have enough permission for writing and creating 
            files in this folder. Note that if you are creating HttpHandler-based server usually on Windows XP your web application 
            runs under ASPNET account while on Windows 2003 it runs under Network Service account.
            </param>
            <param>
            If you are requesting your server with a WebDAV client and log file is not 
            created, most likely there is no permissions for creating file or the web 
            requests simply does not reach your application.
            </param>
            <code>
            public class WebDAVHandler : IHttpHandler
            {
            	public void ProcessRequest(HttpContext context)
            	{
            		FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";
            		...
            	}
            	...
            }
            </code>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.Level">
            <summary>
            Gets and sets how much information is written to log file.
            </summary>
            <value>Logging level. Default is <c>Info</c></value>
            <remarks>
            Provides the method of limiting amount of logging output. During the 
            development you will usually set <c>LogLevel</c> to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.All"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug"/> level, while 
            deploying you can set it to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Error"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize">
            <summary>
            Gets and sets maximum log file size in bytes.
            </summary>
            <value>
            Maximum log file size in bytes. Default is 1048576 bytes.
            </value>
            <remarks>
            When the file exceeds the size specified by <c>FileSize</c> the new log file is created. The old file is renamed to &lt;filename&gt;.&lt;number&gt;.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.MaxBackups">
            <summary>
            Gets and sets Maximum number of log file backups.
            </summary>
            <value>
            Amount of log file backups. Default is 1.
            </value>
            <remarks>
            If the amount of the backup files created is higher than <c>MaxBackups</c> the oldest file is automatically deleted.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String)">
            <summary>
            Wrights a message to a log file with level <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Info"/>.
            </summary>
            <param name="message">Message to be logged.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String,ITHit.WebDAV.Server.Logger.LogLevel)">
            <summary>
            Wrights a message to a log file with a specified log level.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="level">Logging level.</param>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.LogLevel">
            <summary>
            Type of information being logged.
            </summary>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.All">
            <summary>
            All messages will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug">
            <summary>
            Messages with <c>LogLevel.Debug</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Info">
            <summary>
            Messages with <c>LogLevel.Info</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Warn">
            <summary>
            Messages with <c>LogLevel.Warn</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Error">
            <summary>
            Messages with <c>LogLevel.Error</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal">
            <summary>
            Messages with <c>LogLevel.Fatal</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Off">
            <summary>
            No messages will be written to log.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.NamespaceDoc">
            <summary>
            The ITHit.WebDav.Server.Logger namespace provides DefaultLogger class. This namespace provides functionality for logging HTTP content and headers transmitted between server and server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync">
            <summary>
            Implement this interface if your repository will be viewed by Windows Explorer,
            so it is possible to view/modify attributes of files/folders.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync.GetFileAttributesAsync">
            <summary>
            Retrieves file attributes.
            </summary>
            <returns>File attributes.</returns>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<FileAttributes> GetFileAttributesAsync()
{
    if (Name.StartsWith("."))
    {
        return fileSystemInfo.Attributes | FileAttributes.Hidden;
    }
    return fileSystemInfo.Attributes;
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetFileAttributesAsync() As Task(Of FileAttributes) Implements IMsItemAsync.GetFileAttributesAsync
    If Name.StartsWith(".") Then
        Return fileSystemInfo.Attributes Or FileAttributes.Hidden
    End If

    Return fileSystemInfo.Attributes
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync.SetFileAttributesAsync(System.IO.FileAttributes)">
            <summary>
            Updates file attributes.
            </summary>
            <param name="value">File attributes.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task SetFileAttributesAsync(FileAttributes value)
{
    File.SetAttributes(fileSystemInfo.FullName, value);
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function SetFileAttributesAsync(value As FileAttributes) As Task Implements IMsItemAsync.SetFileAttributesAsync
    File.SetAttributes(fileSystemInfo.FullName, value)
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.MicrosoftExtensions.NamespaceDoc">
            <summary>
            This namespace provides interfaces required by Windows eplorer to read/write file attributes.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MimeType">
            <summary>
            Provides functionality for getting mime type by file extension.
            </summary>
            <remarks>
            <para>
            The <see cref="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)" /> static method of this class returns mime type by provided file extension. 
            The class is usually utilized in <see cref="!:IContentAsync.ContentType" /> implementation. The mime-type is returned in
            a Content-Type header with GET request.
            The set of values can be extended with using <see cref="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)" /> method.
            </para>
            <para>
            When deciding which action to perform when downloading a file some WebDAV clients and browsers
            (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type header
            returned by server. For identical behavior in all browsers and WebDAV clients your server must return a correct
            mime-type with a requested file.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public string ContentType
{
    get { return MimeType.GetMimeType(fileSystemInfo.Extension) ?? "application/octet-stream"; }
}
]]></code>
      <code lang="VB"><![CDATA[Public ReadOnly Property ContentType As String Implements IContentAsync.ContentType
    Get
        Return If(MimeType.GetMimeType(fileSystemInfo.Extension), "application/octet-stream")
    End Get
End Property

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)">
            <summary>
            Extends the list of content types or replaces existing value with a new one.
            </summary>
            <param name="extension">File extension.</param>
            <param name="mimeType">File mime type.</param>
            <example>
            <code>
            MimeType.ExtendTypesTable("exten", "application/exten");
            Console.WriteLine(MimeType.GetMimeType("exten"));
            </code>
            Writes: <c>"application/exten"</c>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)">
            <summary>
            Returns the mime type corresponding to file extension.
            </summary>
            <param name="extension">File extension.</param>
            <returns>String representing mime-type or null if mime-type was not found for the specified extension.
            </returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.MultistatusException">
            <summary>
            Exception which contains errors for multiple items or properties.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor(System.String)">
            <summary>
            Initializes new message.
            </summary>
            <param name="message">Error text.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds all errors from <paramref name="mex"/> exception to this one.
            </summary>
            <param name="mex">Exception to merge with.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)">
            <summary>
            Adds item error.
            </summary>
            <param name="itemPath">tem path for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)">
            <summary>
            Addes property error.
            </summary>
            <param name="itemPath">Item path for which property operation failed.</param>
            <param name="propertyName">Property name for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.RenderAsync(ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync},ITHit.Server.IHierarchyItemBaseAsync,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>        
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>
            <param name="item">Instance of <see cref="T:ITHit.Server.IHierarchyItemBaseAsync"/>.</param>
            <param name="renderContent">Whether content shall be written to output.</param>
            <remarks>        
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.RenderInlineAsync(System.Xml.XmlWriter,ITHit.Server.ContextAsync{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.Server.ContextAsync`1"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.NamespaceDoc">
            <summary>
            This namespace provides classes for accessing WebDAV server items, file structure management, properties management.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.NamespaceDoc">
            <summary>
            This namespace provides interfaces and classes for managing Internet Calendaring and Scheduling (iCalendar) format.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.NamespaceDoc">
            <summary>
            iCalendar components
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.Properties.NamespaceDoc">
            <summary>
            iCalendar components properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.PropertyParameters.NamespaceDoc">
            <summary>
            iCalendar PropertyParameters
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Serialization.NamespaceDoc">
            <summary>
            This namespace provides classes for storing and retriving iCalendars.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports used and free space reporting.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">
            <summary>
            Shall be thrown if quota limits are exceeded or there is no physical space left.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.QUOTA_NOT_EXCEEDED">
            <summary>
            Quota was exceeded.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.SUFFICIENT_DISK_SPACE">
            <summary>
            There is insufficient physical space to execute the request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor(System.String,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="message">Error message.</param>
            <param name="reason">One of </param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.IQuotaAsync">
            <summary>
            If your server implementation needs to support quotas, this interface must be
            implemented by collections (items which implement <see cref="T:ITHit.WebDAV.Server.Class1.IFolderAsync"/>, <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync"/> etc.
            interfaces).
            Optionally this interface can be implemented by other items depending on your requirements.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetAvailableBytesAsync">
            <summary>
            Value in bytes representing the amount of additional disk space beyond the current
            allocation that can be allocated to the folder (or other item) before further
            allocations will be refused.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes that can be additionally allocated in folder/file.</returns>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<long> GetAvailableBytesAsync()
{
    // Here you can return amount of bytes available for current user.
    // For the sake of simplicity we return entire available disk space.

    // Note: NTFS quotes retrieval for current user works very slowly.

    return await dirInfo.GetStorageFreeBytesAsync();
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetAvailableBytesAsync() As Task(Of Long) Implements IQuotaAsync.GetAvailableBytesAsync
    ' Here you can return amount of bytes available for current user.
    ' For the sake of simplicity we return entire available disk space.
    ' Note: NTFS quotes retrieval for current user works very slowly.
    Return Await dirInfo.GetStorageFreeBytesAsync()
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetUsedBytesAsync">
            <summary>
             Value in bytes representing the amount of space used by this folder/file
             and possibly a number of other similar folders/files, where the set of "similar" meets at least
             the criterion that allocating space to any folder/file in the set will
             count against the <see cref="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetAvailableBytesAsync" />. It MUST include the
             total count including usage derived from sub-items if
             appropriate. It SHOULD include metadata storage size if metadata
             storage is counted against the <see cref="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetAvailableBytesAsync" />
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes occupied by folder/file.</returns>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<long> GetUsedBytesAsync()
{
    // Here you can return amount of bytes used by current user.
    // For the sake of simplicity we return entire used disk space.

    //Note: NTFS quotes retrieval for current user works very slowly.

    return await dirInfo.GetStorageUsedBytesAsync();
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetUsedBytesAsync() As Task(Of Long) Implements IQuotaAsync.GetUsedBytesAsync
    ' Here you can return amount of bytes used by current user.
    ' For the sake of simplicity we return entire used disk space.
    'Note: NTFS quotes retrieval for current user works very slowly.
    Return Await dirInfo.GetStorageUsedBytesAsync()
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.NamespaceDoc">
            <summary>
            The ITHit.WebDav.Server.ResumableUpload namespace provides classes for handling resumable upload. You will use classes from this namespace to implement pause/resume/restore upload feature, upload process feature, upload via POST verb from AJAX client, non-cached upload in IIS.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync">
            <summary>
            Implemented by a file that supports updating parts of its content.
            </summary>
            <remarks>
            <para>
            You will implement this interface together with <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync"/> interface when you would like to
            provide one or more of the following features:
            <list type="bullet">
            <item><description>Pause/resume uploads.</description></item>
            <item><description>Restore broken uploads.</description></item>
            <item><description>Upload from AJAX using POST verb and create upload progress bars. Required in IE 9 and earlier only.</description></item>
            <item><description>Upload to ASP.NET/IIS-based server files over 2Gb.</description></item>
            </list>
            </para>
            <para>The WebDAV Server Engine can process two types of upload requests:
            <list type="bullet">
            <item><description> <b>PUT upload.</b> Files uploaded via PUT by most WebDAV compliant clients.</description></item>
            <item><description> <b>POST upload.</b> Files uploaded via POST verb by Ajax applications running in Microsoft Internet Explorer 9 and earlier. </description></item>
            </list>
            </para>
            <para>
            To provide information about what segment of a file is being uploaded, the client application will
            attach optional <c>Content-Range: bytes XXX-XXX/XXX</c> header to PUT request.
            </para>
            <para>
            Internet Explorer 9 and earlier limitations is unable to randomly read
            file content and upload content using PUT verb. To overcome this limitation the Engine can process files
            uploaded using POST verb. 
            Internet Explorer 9 and earlier still can display upload progress submitting upload-progress REPORT request
            (see <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync"/> interface description for more info).
            </para>
            </remarks>
            <example>The following example demonstrates upload to WebDAV server using POST with multipart encoding.
            The file will be created in /mydocs/ folder.
            <code>
            <![CDATA[
            <html>
                <head><title>POST Upload to WebDAV Server</title></head>
                <body>
                    <form action="/mydocs/" method="post" enctype="multipart/form-data">
                        <input type="file" name="dummyname" /><br />
                        <input type="submit" />
                    </form>
                </body>
            </html>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.CancelUploadAsync">
            <summary>
            In this method implementation you can delete partially uploaded file.
            </summary>    
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            Often during long-continued upload you will keep the old file 
            content to be returned by GET requests and store the new file content in a
            temporary file (or temporary field in database, etc).  To delete this partially
            uploaded content client can submit CANCELUPLOAD command, the Engine will call this method in this case.
            </para>
            <para>
            If the item was automatically checked-out by the Engine when upload started it will be automatically
            checked-in by the Engine after this call.
            </para>
            </remarks>
            <example>
            Request:
            <code>
            <![CDATA[
            CANCELUPLOAD /LargeFile.doc HTTP/1.1
            Host: http://server:8580/
            ]]>
            </code>
            
            Response:
            <code>
            <![CDATA[
            HTTP/1.1 200 OK
            ]]>
            </code>
            </example>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task CancelUploadAsync()
{
    await DeleteAsync(new MultistatusException());
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function CancelUploadAsync() As Task Implements IResumableUploadAsync.CancelUploadAsync
    Await DeleteAsync(New MultistatusException())
End Function

]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.LastChunkSaved">
            <summary>
            The date and time when the last chunk of file was saved in your storage.
            </summary>
            <remarks>
            Requested by the Engine during a call to <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync" />.
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public DateTime LastChunkSaved
{
    get { return fileInfo.Exists ? fileInfo.LastWriteTimeUtc : DateTime.MinValue; }
}
]]></code>
      <code lang="VB"><![CDATA[Public ReadOnly Property LastChunkSaved As DateTime Implements IResumableUploadAsync.LastChunkSaved
    Get
        Return If(fileInfo.Exists, fileInfo.LastWriteTimeUtc, DateTime.MinValue)
    End Get
End Property

]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.BytesUploaded">
            <summary>
            Amount of bytes successfully saved to your storage.
            </summary>
            <remarks>
            <para>Client will use value returned by this property to restore broken upload.
            This value shall always reflect number of bytes already stored to persistent medium.
            </para>
            <para>Requested by the Engine during a call to 
            <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync" />.</para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public long BytesUploaded
{
    get { return ContentLength; }
}
]]></code>
      <code lang="VB"><![CDATA[Public ReadOnly Property BytesUploaded As Long Implements IResumableUploadAsync.BytesUploaded
    Get
        Return ContentLength
    End Get
End Property

]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.TotalContentLength">
            <summary>Total file size that is being uploaded.</summary>
            <remarks>
            <para>This value is passed to <see cref="!:IContentAsync.WriteAsync" /> method.
             Usually AJAX/HTML based clients will use value returned by this property to display upload progress.</para>
            <para>Requested by the Engine during a call to <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync" />.</para>
            </remarks>
            <returns>Total file size in bytes.</returns>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public long TotalContentLength
{
    get; private set;
}
]]></code>
      <code lang="VB"><![CDATA[Public Property TotalContentLength As Long Implements IResumableUploadAsync.TotalContentLength

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadBase">
            <summary>
            Implemented on files and folders that supports updating parts of its content.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync">
             <summary>
             Implemented on files and folders to report upload progress.
             </summary>
             <remarks>
             <para>
             This interface should be implemented on files that can provide upload progress information to client
             application. Optionally it can be implemented on folder items.
             </para>
             <para>
             When implementing this interface you may need to configure <c>PutUploadProgressAndResumeModule</c> and 
             <c>PostUploadProgressModule</c> module in your web.config file if your WebDAV server is hosted in IIS/ASP.NET.
             </para>
             <para>
             Usually client application requests upload progress in following cases: 
             <list type="bullet">
             <item><description>If connection was broken (paused) and client would like to restore upload. Client will
             submit upload-progress request to get number of bytes successfully saved on server side and will start the
             upload from the next byte. You must add <c>PutUploadProgressAndResumeModule</c> in your web.config to support this 
             scenario if your application is running ASP.NET 2.0 pool. The <c>PutUploadProgressAndResumeModule"</c> is 
             not required if you are using ASP.NET 4.0 pool and is ignored if you include it in web.config</description></item>
             <item><description>When client application requires information about how much of the uploaded file
             was processed on server side. Usually this is required by Microsoft Internet Explorer 9 and earlier only.  
             IE 9 and earlier does not have any information about how much of the file was submitted to server. 
             It will submit upload-progress request to update its upload progress bar from time to time. You must 
             add <c>PostUploadProgressModule</c> in your web.config to support this scenario.</description></item>
             </list>
             </para>
             <para>
             To check if folder or file supports upload-progress report and resumable upload feature the client application
             will submit OPTIONS request to that item. If the item implements <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync"/> interface Engine will
             add 'resumable-upload' token to DAV response header. See example below.
             </para>
             <para>
             To get information about file upload progress client will submit REPORT request to that file with upload
             progress type. The Engine will call <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync"/> method in this case. You will return an
             <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains single item (this file implementing <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync"/>) from
             <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync"/> method implementation. The engine will extract necessary info from the
             returned <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync"/> interface and return it to client. The response will contain XML
              with information about upload progress for the requested file: url of the file, number or bytes uploaded,
             total size of the file and time when last save operation occurred. 
             </para>
             <para>The response returned by server Engine to client is a REPORT multistatus response that contains three
             properties for each file:
             </para>
             <para>
             <list type="bullet">
             <item> <description><b>ithit:bytes-uploaded</b> - integer value. Number of bytes uploaded and saved in
             persistent storage. If upload was broken or paused the client application will usually start upload from the
             next byte returned in this property.</description></item>
             <item> <description><b>ithit:last-chunk-saved</b> - date\timein in RFC 1123 format. Indicates when last chunk
             was saved. May be used in admin applications and automatic maintenance tools to remove files that were not
             fully uploaded.</description></item>
             <item> <description><b>ithit:total-content-length</b> - integer value. Total file size that is being uploaded
             to server. Thin client applications may use this value for displaying upload progress.</description></item>
             </list>
             </para>
             <para>
             See example of upload progress report below.
             </para>
             <para>
             The client application can also submit upload-progress REPORT request to a folder. In this case from your
             <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync"/> property implementation you will return IEnumerable containing files that are being uploaded
             that reside in the folder's subtree. The response XML will contain info about each file from the <see cref="T:System.Collections.Generic.IEnumerable`1"/> in a
             separate response tag. See example below.
             </para>
             <para>
             If item does not support upload-progress report and server is based on IT Hit WebDAV Server Engine the server
             will respond with '403 Forbidden' to
             REPORT request. The body will contain &lt;A:supported-report xmlns="DAV:"/>  element. If server does not support
             REPORT verb you will get 405 Method Not Allowed response.
             </para>
             </remarks>
             <example>
             <para>
             OPTIONS request is used to determine if folder or file supports resumable upload.
             <para>Request:</para>
             <code>
             <![CDATA[
             OPTIONS /Folder/ HTTP/1.1
             Host: davserver
             Content-Length: 0
             ]]>
             </code>
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 200 OK
             Content-Length: 0
             Accept-Ranges: none
             DAV: 1, 2, resumable-upload
             Public: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             Allow: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over file contains  info about single item.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:">
             <D:response>
                <D:href>http://server:8580/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>    
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over folder contains  info about all files being uploaded to subtree.
             <para>
             Request:
             </para>
             <code>
             <![CDATA[
             REPORT /folder HTTP/1.1
             Host: http://server:8580/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:" xmlns:ithit="ithit">
             <D:response>
                <D:href>http://server:8580/folder/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
             <D:response>
                <D:href>http://server:8580/folder/nestedfolder/AnotherLargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>47</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:16:12 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>6398</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             If item on server based on IT Hit WebDAV Server Engine does not support upload-progress the server will respond
             with 403 Forbidden response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 403 Forbidden
             Content-Length: 31
             Content-Type: application/xml;charset=UTF-8
            
             <supported-report xmlns="DAV"/>
             ]]>
             </code>
             </para>
             <para>
             If server does not support REPORT verb (often non-IT Hit Engine) you will get 405 Method Not Allowed response.
             <para>
             Request:
             </para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 405 Method Not Allowed
             Content-Length: 0
             Content-Type: application/xml;charset=UTF-8
            
             ]]>
             </code>
             </para>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync">
            <summary>Gets IEnumerable with items that are being uploaded to this item subtree.</summary>
            <returns>
            Information about upload progress.
            </returns>
            <remarks>
            <para>
            Returns <see cref="T:System.Collections.Generic.IEnumerable`1" /> with a single item if implemented on file items. Return all items that are being uploaded to
            this subtree if implemented on folder items.
            </para>
            <para>
            Engine calls <see cref="!:IHierarchyItemAsync.Path" />, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.LastChunkSaved" />, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.BytesUploaded" />, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.TotalContentLength" /> and returns this information to
            client.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<IEnumerable<IResumableUploadAsync>> GetUploadProgressAsync()
{
    return new[] { this };
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function GetUploadProgressAsync() As Task(Of IEnumerable(Of IResumableUploadAsync)) Implements IUploadProgressAsync.GetUploadProgressAsync
    Return {Me}
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports DASL server search.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.ISearchAsync">
            <summary>
            Represents an item that supports search according to DASL standard.
            </summary>
            <remarks>
            <para>
            Implement this interface on folders that suppoort search. When search request is 
            recived the <see cref="T:ITHit.WebDAV.Server.DavEngineAsync" /> calls <see cref="M:ITHit.WebDAV.Server.Search.ISearchAsync.SearchAsync(System.String,ITHit.WebDAV.Server.Search.SearchOptions,System.Collections.Generic.List{ITHit.WebDAV.Server.PropertyName},System.Nullable{System.Int64},System.Nullable{System.Int64})" /> method.
            </para>
            <para>
            If this interface is found on folder items, your server will include <b>DASL: &lt;DAV:basicsearch&gt;</b> 
            header and <b>SEARCH</b> token in <b>Allow</b> header in response to <b>OPTIONS</b> requests. The WebDAV clients that support DASL 
            search, including IT Hit Ajax File Browser, may rely on this header and token to display search user interface.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<PageResults> SearchAsync(string searchString, SearchOptions options, List<PropertyName> propNames, long? offset, long? nResults)
{
    bool includeSnippet = propNames.Any(s => s.Name == snippetProperty);

    // search both in file name and content
    string commandText =
        @"SELECT System.ItemPathDisplay" + (includeSnippet ? " ,System.Search.AutoSummary" : string.Empty) + " FROM SystemIndex " +
        @"WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " +
        @"ORDER BY System.Search.Rank DESC";

    commandText = PrepareCommand(commandText,
        "@Path", this.dirInfo.FullName,
        "@Name", searchString,
        "@Content", searchString);

    Dictionary<string, string> foundItems = new Dictionary<string, string>();
    try
    {
        // Sending SQL request to Windows Search. To get search results file system indexing must be enabled.
        // To find how to enable indexing follow this link: http://windows.microsoft.com/en-us/windows/improve-windows-searches-using-index-faq
        using (OleDbConnection connection = new OleDbConnection(windowsSearchProvider))
        using(OleDbCommand command = new OleDbCommand(commandText, connection))
        {
            connection.Open();
            using(OleDbDataReader reader = command.ExecuteReader())
            {
                while (await reader.ReadAsync())
                {
                    string snippet = string.Empty;
                    if (includeSnippet)
                    {
                        snippet = reader.GetValue(1) != DBNull.Value ? reader.GetString(1) : null;
                        // XML does not support control characters or permanently undefined Unicode characters. Removing them from snippet. https://www.w3.org/TR/xml/#charsets
                        if (!string.IsNullOrEmpty(snippet) && invalidXmlCharsPattern.IsMatch(snippet))
                        {
                            snippet = invalidXmlCharsPattern.Replace(snippet, String.Empty);
                        }
                    }
                    foundItems.Add(reader.GetString(0), snippet);
                }
            }
        }
    }
    catch (OleDbException ex) // explaining OleDbException
    {
        context.Logger.LogError(ex.Message, ex);
        switch (ex.ErrorCode)
        {
            case -2147217900: throw new DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT);
            default: throw new DavException("Unknown error.", DavStatus.INTERNAL_ERROR);
        }
    }

    IList<IHierarchyItemAsync> subtreeItems = new List<IHierarchyItemAsync>();
    foreach (string path in foundItems.Keys)
    {
        IHierarchyItemAsync item = await context.GetHierarchyItemAsync(GetRelativePath(path)) as IHierarchyItemAsync;
        if (item == null)
        {
            continue;
        }

        if (includeSnippet && item is DavFile)
            (item as DavFile).Snippet = HighlightKeywords(searchString.Trim('%'), foundItems[path]);

        subtreeItems.Add(item);
    }

    return new PageResults(offset.HasValue && nResults.HasValue ? subtreeItems.Skip((int)offset.Value).Take((int)nResults.Value) : subtreeItems, subtreeItems.Count);
    
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function SearchAsync(searchString As String, options As SearchOptions, propNames As List(Of PropertyName), offset As Long?, nResults As Long?) As Task(Of PageResults) Implements ISearchAsync.SearchAsync
    Dim includeSnippet As Boolean = propNames.Any(Function(s) s.Name = snippetProperty)
    ' search both in file name and content
    Dim commandText As String = "SELECT System.ItemPathDisplay" & (If(includeSnippet, " ,System.Search.AutoSummary", String.Empty)) & " FROM SystemIndex " & "WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " & "ORDER BY System.Search.Rank DESC"
    commandText = PrepareCommand(commandText,
                                "@Path", Me.dirInfo.FullName,
                                "@Name", searchString,
                                "@Content", searchString)
    Dim foundItems As Dictionary(Of String, String) = New Dictionary(Of String, String)()
    Try
        Using connection As OleDbConnection = New OleDbConnection(windowsSearchProvider)
            Using command As OleDbCommand = New OleDbCommand(commandText, connection)
                connection.Open()
                Using reader As OleDbDataReader = command.ExecuteReader()
                    While Await reader.ReadAsync()
                        Dim snippet As String = String.Empty
                        If includeSnippet Then
                            snippet = If(reader.GetValue(1) <> DBNull.Value, reader.GetString(1), Nothing)
                            ' XML does not support control characters or permanently undefined Unicode characters. Removing them from snippet. https:'www.w3.org/TR/xml/#charsets
                            If Not String.IsNullOrEmpty(snippet) AndAlso invalidXmlCharsPattern.IsMatch(snippet) Then
                                snippet = invalidXmlCharsPattern.Replace(snippet, [String].Empty)
                            End If
                        End If

                        foundItems.Add(reader.GetString(0), snippet)
                    End While
                End Using
            End Using
        End Using
    Catch ex As OleDbException
        context.Logger.LogError(ex.Message, ex)
        Select Case ex.ErrorCode
            Case -2147217900
                Throw New DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT)
            Case Else
                Throw New DavException("Unknown error.", DavStatus.INTERNAL_ERROR)
        End Select

    End Try

    Dim subtreeItems As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
    For Each path As String In foundItems.Keys
        Dim item As IHierarchyItemAsync = TryCast(Await context.GetHierarchyItemAsync(GetRelativePath(path)), IHierarchyItemAsync)
        If item Is Nothing Then
            Continue For
        End If

        If includeSnippet AndAlso TypeOf item Is DavFile Then TryCast(item, DavFile).Snippet = HighlightKeywords(searchString.Trim("%"c), foundItems(path))
        subtreeItems.Add(item)
    Next

    Return New PageResults(If(offset.HasValue AndAlso nResults.HasValue, subtreeItems.Skip(CInt(offset.Value)).Take(CInt(nResults.Value)), subtreeItems), subtreeItems.Count)
End Function

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Search.ISearchAsync.SearchAsync(System.String,ITHit.WebDAV.Server.Search.SearchOptions,System.Collections.Generic.List{ITHit.WebDAV.Server.PropertyName},System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            Returns a list of items that correspond to a search request. 
            </summary>
            <param name="searchString">A phrase to search.</param>
            <param name="options">Search parameters.</param>
            <param name="propNames">
            List of properties to retrieve with each item returned by this method. They will be requested by the 
            Engine in <see cref="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)" /> call.
            </param>
            <param name="offset">The number of items to skip before returning the remaining items.</param>
            <param name="nResults">The number of items to return.</param>   
            <returns>Instance of <see cref="T:ITHit.WebDAV.Server.Paging.PageResults" /> class that contains items on a requested page and total number of items in search results.</returns>
            <remarks>
            <para>
            This method is called by <see cref="T:ITHit.WebDAV.Server.DavEngineAsync" /> when client application is sending search request. 
            In your implementation you must return a list of items that correspond to the requested search phrase and options.
            </para>
            <para>The search phrase may contain wildcards:</para>
            <list type="bullet">
            <item><description>
            To indicate one or more characters the '%' is passed in search string.
            </description></item>
            <item><description>
            To indicate exactly one character the '_' is passed in search string.
            </description></item>
            </list>
            <para>To include '%', '_' and '\' characters in the search string thay are escaped with '\' character.</para>
            <para>Note that IT Hit Ajax File Browser is using '*' and '?' as wildcard characters. In case included in search they are replaced with '%' and '_'.</para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.FileSystemStorage.AspNet' C# &amp; VB samples provided with the SDK.</para>
      <code lang="C#"><![CDATA[public async Task<PageResults> SearchAsync(string searchString, SearchOptions options, List<PropertyName> propNames, long? offset, long? nResults)
{
    bool includeSnippet = propNames.Any(s => s.Name == snippetProperty);

    // search both in file name and content
    string commandText =
        @"SELECT System.ItemPathDisplay" + (includeSnippet ? " ,System.Search.AutoSummary" : string.Empty) + " FROM SystemIndex " +
        @"WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " +
        @"ORDER BY System.Search.Rank DESC";

    commandText = PrepareCommand(commandText,
        "@Path", this.dirInfo.FullName,
        "@Name", searchString,
        "@Content", searchString);

    Dictionary<string, string> foundItems = new Dictionary<string, string>();
    try
    {
        // Sending SQL request to Windows Search. To get search results file system indexing must be enabled.
        // To find how to enable indexing follow this link: http://windows.microsoft.com/en-us/windows/improve-windows-searches-using-index-faq
        using (OleDbConnection connection = new OleDbConnection(windowsSearchProvider))
        using(OleDbCommand command = new OleDbCommand(commandText, connection))
        {
            connection.Open();
            using(OleDbDataReader reader = command.ExecuteReader())
            {
                while (await reader.ReadAsync())
                {
                    string snippet = string.Empty;
                    if (includeSnippet)
                    {
                        snippet = reader.GetValue(1) != DBNull.Value ? reader.GetString(1) : null;
                        // XML does not support control characters or permanently undefined Unicode characters. Removing them from snippet. https://www.w3.org/TR/xml/#charsets
                        if (!string.IsNullOrEmpty(snippet) && invalidXmlCharsPattern.IsMatch(snippet))
                        {
                            snippet = invalidXmlCharsPattern.Replace(snippet, String.Empty);
                        }
                    }
                    foundItems.Add(reader.GetString(0), snippet);
                }
            }
        }
    }
    catch (OleDbException ex) // explaining OleDbException
    {
        context.Logger.LogError(ex.Message, ex);
        switch (ex.ErrorCode)
        {
            case -2147217900: throw new DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT);
            default: throw new DavException("Unknown error.", DavStatus.INTERNAL_ERROR);
        }
    }

    IList<IHierarchyItemAsync> subtreeItems = new List<IHierarchyItemAsync>();
    foreach (string path in foundItems.Keys)
    {
        IHierarchyItemAsync item = await context.GetHierarchyItemAsync(GetRelativePath(path)) as IHierarchyItemAsync;
        if (item == null)
        {
            continue;
        }

        if (includeSnippet && item is DavFile)
            (item as DavFile).Snippet = HighlightKeywords(searchString.Trim('%'), foundItems[path]);

        subtreeItems.Add(item);
    }

    return new PageResults(offset.HasValue && nResults.HasValue ? subtreeItems.Skip((int)offset.Value).Take((int)nResults.Value) : subtreeItems, subtreeItems.Count);
    
}
]]></code>
      <code lang="VB"><![CDATA[Public Async Function SearchAsync(searchString As String, options As SearchOptions, propNames As List(Of PropertyName), offset As Long?, nResults As Long?) As Task(Of PageResults) Implements ISearchAsync.SearchAsync
    Dim includeSnippet As Boolean = propNames.Any(Function(s) s.Name = snippetProperty)
    ' search both in file name and content
    Dim commandText As String = "SELECT System.ItemPathDisplay" & (If(includeSnippet, " ,System.Search.AutoSummary", String.Empty)) & " FROM SystemIndex " & "WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " & "ORDER BY System.Search.Rank DESC"
    commandText = PrepareCommand(commandText,
                                "@Path", Me.dirInfo.FullName,
                                "@Name", searchString,
                                "@Content", searchString)
    Dim foundItems As Dictionary(Of String, String) = New Dictionary(Of String, String)()
    Try
        Using connection As OleDbConnection = New OleDbConnection(windowsSearchProvider)
            Using command As OleDbCommand = New OleDbCommand(commandText, connection)
                connection.Open()
                Using reader As OleDbDataReader = command.ExecuteReader()
                    While Await reader.ReadAsync()
                        Dim snippet As String = String.Empty
                        If includeSnippet Then
                            snippet = If(reader.GetValue(1) <> DBNull.Value, reader.GetString(1), Nothing)
                            ' XML does not support control characters or permanently undefined Unicode characters. Removing them from snippet. https:'www.w3.org/TR/xml/#charsets
                            If Not String.IsNullOrEmpty(snippet) AndAlso invalidXmlCharsPattern.IsMatch(snippet) Then
                                snippet = invalidXmlCharsPattern.Replace(snippet, [String].Empty)
                            End If
                        End If

                        foundItems.Add(reader.GetString(0), snippet)
                    End While
                End Using
            End Using
        End Using
    Catch ex As OleDbException
        context.Logger.LogError(ex.Message, ex)
        Select Case ex.ErrorCode
            Case -2147217900
                Throw New DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT)
            Case Else
                Throw New DavException("Unknown error.", DavStatus.INTERNAL_ERROR)
        End Select

    End Try

    Dim subtreeItems As IList(Of IHierarchyItemAsync) = New List(Of IHierarchyItemAsync)()
    For Each path As String In foundItems.Keys
        Dim item As IHierarchyItemAsync = TryCast(Await context.GetHierarchyItemAsync(GetRelativePath(path)), IHierarchyItemAsync)
        If item Is Nothing Then
            Continue For
        End If

        If includeSnippet AndAlso TypeOf item Is DavFile Then TryCast(item, DavFile).Snippet = HighlightKeywords(searchString.Trim("%"c), foundItems(path))
        subtreeItems.Add(item)
    Next

    Return New PageResults(If(offset.HasValue AndAlso nResults.HasValue, subtreeItems.Skip(CInt(offset.Value)).Take(CInt(nResults.Value)), subtreeItems), subtreeItems.Count)
End Function

]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.SearchOptions">
            <summary>
            Represents DASL search parameters.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchContent">
            <summary>
            Gets the value indicating that the search is performed in a file content.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchName">
            <summary>
            Gets the value indicating that the search is performed in a file name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Paging.OrderProperty">
            <summary>
            Represents property used for sorting in ascending or descending order.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Paging.OrderProperty.Property">
            <summary>
            Property name.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Paging.OrderProperty.Ascending">
            <summary>
            Order direction.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Paging.OrderProperty.#ctor(ITHit.WebDAV.Server.PropertyName,System.Boolean)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name.</param>
            <param name="ascending">Order direction.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Paging.PageResults">
            <summary>
            Represents a sinle page results returned from the <see href="IPagingAsync.GetPageAsync" /> and <see href="IPagingSearchAsync.GetPageSearchAsync"/> methods.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Paging.PageResults.Page">
            <summary>
            Items that correspond to the requested page and sorting.
            </summary>
            <returns>List of <see cref="T:ITHit.WebDAV.Server.IHierarchyItemAsync"/> items that represent items on a page.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Paging.PageResults.TotalItems">
            <summary>
            Total number of items in the folder or in search results.
            </summary>
            <remarks>
            <para>This number can be used by the client application to display number of pages available.</para>
            <para>Set this property to null if total number of items is unknown. The total number of items will not be returned to the client in this case.</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Paging.PageResults.#ctor(System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.IHierarchyItemAsync})">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Paging.PageResults"/> class.
            </summary>
            <param name="page">Items that correspond to the requested page and sorting.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Paging.PageResults.#ctor(System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.IHierarchyItemAsync},System.Nullable{System.Int64})">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Paging.PageResults"/> class.
            </summary>
            <param name="page">Items that correspond to the requested page and sorting.</param>
            <param name="totalItems">Total number of items in the folder or in search results.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyName">
            <summary>
            Describes property name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_NAME">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionAsync.VersionName"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> / <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/>.
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL_RESTRICTIONS">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclRestrictionsAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ALTERNATE_URI_SET">
            <summary>
            Is not supported.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETETAG">
            <summary>
            Refers to <see cref="!:IContentAsync.Etag"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.COMMENT">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCommentAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATIONDATE">
            <summary>
            Refers to <see cref="!:IHierarchyItemAsync.Created"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATOR_DISPLAYNAME">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCreatorDisplayNameAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLANGUAGE">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLENGTH">
            <summary>
            Refers to <see cref="!:IContentAsync.ContentLength"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTTYPE">
            <summary>
            Refers to <see cref="!:IContentAsync.ContentType"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETLASTMODIFIED">
            <summary>
            Refers to <see cref="!:IHierarchyItemAsync.Modified"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetGroupAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBER_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembersAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBERSHIP">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembershipAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.INHERITED_ACL_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetInheritedAclSetAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.LOCKDISCOVERY">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Class2.ILockAsync.GetActiveLocksAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.OWNER">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetOwnerAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_COLLECTION_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_URL">
            <summary>
            Is not directly supported. Is the same as <see cref="!:IHierarchyItemAsync.Path"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEDGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCTAG">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.AUTO_VERSION">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.GetAutoVersionAsync"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_HISTORY">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRINCIPAL">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipalAsync.GetCurrentUserPrincipalAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_USED_BYTES">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetUsedBytesAsync"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_AVAILABLE_BYTES">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetAvailableBytesAsync"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property local name.</param>
            <param name="propNamespace">Property namespace.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property local name.</param>
            <param name="propNamespace">Property namespace.</param>
            <param name="prefix">Property prefix.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Prefix">
            <summary>
            Property prefix.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Namespace">
            <summary>
            Property namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Name">
            <summary>
            Property local name.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.ToString">
            <summary>
            Returns property name as string.
            </summary>
            <returns>String representation.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="other"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Equality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Equality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Inequality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Unequality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(System.Object)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="obj"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>       
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>        
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyValue">
            <summary>
            Describes one property associated with hierarchy item object.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.Value">
            <summary>
            The value of the property.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.QualifiedName">
            <summary>
            Name of the property.
            </summary>
        </member>
    </members>
</doc>
